1
00:00:00,000 --> 00:00:05,400
好,seq2seq,这个就是说你把一个句子翻译到另外一个句子

2
00:00:05,400 --> 00:00:11,000
我用的这个图是一个DNA转入RNA

3
00:00:11,000 --> 00:00:13,679
就是在生物学里面经常看到的事情

4
00:00:13,679 --> 00:00:16,839
就是把一个DNA转入成你要的什么形式

5
00:00:16,839 --> 00:00:18,800
它也是一个seq2seq,对吧

6
00:00:20,600 --> 00:00:24,600
好,我们seq2seq最早它是用来做机器翻译的

7
00:00:24,600 --> 00:00:28,160
我们其实已经讲过机器翻译是怎么样数据集了

8
00:00:28,359 --> 00:00:31,399
就是说给另一个原句子自动翻译成目标语言

9
00:00:31,399 --> 00:00:32,759
比如说我们这个就是

10
00:00:34,039 --> 00:00:38,359
我们就是把我们这个书里面一段英语放进去

11
00:00:38,359 --> 00:00:39,399
然后翻译成中文

12
00:00:39,679 --> 00:00:41,359
然后就是in code, decode

13
00:00:41,359 --> 00:00:42,759
然后Google翻译还行

14
00:00:42,759 --> 00:00:45,840
我觉得没想象那么差

15
00:00:45,840 --> 00:00:49,799
然后我们手工翻的话稍微我觉得更加口语化一点

16
00:00:49,799 --> 00:00:51,920
但是翻译的也不错

17
00:00:52,679 --> 00:00:54,960
最早Google翻译是用的seq2seq

18
00:00:55,119 --> 00:00:56,759
现在可能用的BERT

19
00:00:57,240 --> 00:00:58,520
可能会用的BERT

20
00:00:58,640 --> 00:01:01,120
我具体还不知道他们具体是用到哪个模型

21
00:01:02,880 --> 00:01:03,399
好

22
00:01:03,520 --> 00:01:04,879
seq2seq这个东西

23
00:01:05,159 --> 00:01:08,640
就是说它是一个in code和decode的架构

24
00:01:10,000 --> 00:01:10,799
它是干什么呢

25
00:01:10,840 --> 00:01:11,599
就是说

26
00:01:12,159 --> 00:01:12,719
你也看到

27
00:01:15,519 --> 00:01:17,400
这个地方是你的in code

28
00:01:17,519 --> 00:01:19,159
这个地方是你的decode

29
00:01:19,439 --> 00:01:21,760
你的in code就是给你一个句子

30
00:01:22,159 --> 00:01:23,240
比如Hello world

31
00:01:23,959 --> 00:01:28,280
然后你要翻译成你的法语的句子

32
00:01:29,919 --> 00:01:31,599
具体的实现就是说

33
00:01:32,079 --> 00:01:34,439
但整体来看就是说我给你一个句子

34
00:01:34,439 --> 00:01:36,519
然后你把它的信息压在这个地方

35
00:01:36,560 --> 00:01:37,959
然后再给解码器

36
00:01:37,959 --> 00:01:39,479
然后给你输出

37
00:01:40,799 --> 00:01:41,799
然后具体来讲

38
00:01:42,039 --> 00:01:42,879
seq2seq

39
00:01:43,280 --> 00:01:44,799
这是一篇论文

40
00:01:45,039 --> 00:01:47,079
它的算法的名字叫seq2seq

41
00:01:47,079 --> 00:01:48,719
它不是一个问题

42
00:01:49,079 --> 00:01:51,560
它是一个seq2seq的一个实际的问题

43
00:01:51,600 --> 00:01:53,920
但是它只是指一个特定的模型

44
00:01:54,280 --> 00:01:57,840
这个模型它的编码器用的是一个RN

45
00:01:58,719 --> 00:02:00,120
具体说你一个词

46
00:02:00,159 --> 00:02:01,400
它就是一个RN的cell

47
00:02:01,520 --> 00:02:02,879
就是你可以是LSTN

48
00:02:02,960 --> 00:02:04,879
你可以是GRE都行

49
00:02:05,200 --> 00:02:07,000
它每次就是不断的

50
00:02:07,040 --> 00:02:08,439
我们有讲过

51
00:02:08,759 --> 00:02:10,120
你可以拿一个seq进去

52
00:02:10,120 --> 00:02:12,480
然后RN会把你做成一个

53
00:02:12,520 --> 00:02:14,159
把你的状态都给记录下来

54
00:02:14,280 --> 00:02:17,439
然后把最后的时刻的隐藏状态

55
00:02:18,240 --> 00:02:19,920
传给解码器

56
00:02:20,120 --> 00:02:22,080
就是说你这个银行隐藏状态

57
00:02:22,080 --> 00:02:24,520
包括了整个语言句子的信息

58
00:02:25,640 --> 00:02:27,840
这个东西可以是双向的

59
00:02:28,840 --> 00:02:29,320
OK

60
00:02:29,320 --> 00:02:31,600
我们上次有讲过双向

61
00:02:31,600 --> 00:02:33,120
你不能用做语言模型

62
00:02:33,280 --> 00:02:34,880
但双向可以做翻译

63
00:02:34,880 --> 00:02:37,200
就双向可以做encode

64
00:02:37,240 --> 00:02:38,600
它不能做decode

65
00:02:38,960 --> 00:02:40,200
decode一定要预测

66
00:02:40,560 --> 00:02:41,720
encode不需要

67
00:02:41,800 --> 00:02:45,000
encode你基本上总是可以看到整个句子

68
00:02:45,280 --> 00:02:48,360
所以这个地方你可以正着来

69
00:02:48,360 --> 00:02:48,960
反过来来

70
00:02:49,159 --> 00:02:49,760
给一个句子

71
00:02:49,760 --> 00:02:50,960
我可以正向看一下

72
00:02:51,000 --> 00:02:52,200
反向看一下都可以

73
00:02:52,719 --> 00:02:53,200
OK

74
00:02:53,200 --> 00:02:55,280
所以基本上来说

75
00:02:55,640 --> 00:02:59,159
双向RN经常会用在encode里面

76
00:03:00,000 --> 00:03:00,560
OK

77
00:03:01,680 --> 00:03:04,560
然后解码器它也是用一个RN来输出

78
00:03:04,920 --> 00:03:06,159
你可以看到就是说

79
00:03:06,319 --> 00:03:08,240
我一个隐藏状态过来

80
00:03:08,360 --> 00:03:09,280
然后给他一个什么

81
00:03:09,439 --> 00:03:11,480
给他一个说句子开始了

82
00:03:11,760 --> 00:03:12,480
开始翻译

83
00:03:13,040 --> 00:03:15,319
他就OK给定隐藏状态

84
00:03:15,319 --> 00:03:16,680
给定原句子的隐藏状态

85
00:03:17,280 --> 00:03:18,360
给一个输出

86
00:03:18,480 --> 00:03:19,360
他开始翻译

87
00:03:19,640 --> 00:03:20,840
Bonjour应该是

88
00:03:21,720 --> 00:03:24,200
然后他把上一次的翻译

89
00:03:24,440 --> 00:03:26,880
作为下一个时刻的输入

90
00:03:27,040 --> 00:03:28,920
然后隐藏状态也是同样过来

91
00:03:29,120 --> 00:03:30,560
然后把这两个输出下一个

92
00:03:30,560 --> 00:03:32,360
然后不断的这样输出输出

93
00:03:32,520 --> 00:03:33,800
就会拿到了

94
00:03:34,400 --> 00:03:37,200
你整个原句子的输出

95
00:03:37,640 --> 00:03:38,240
OK

96
00:03:38,760 --> 00:03:40,040
你可以看到基本上是说

97
00:03:40,040 --> 00:03:43,360
你这样子对长度是可以变换的

98
00:03:43,840 --> 00:03:45,000
就是说直到我输出

99
00:03:45,000 --> 00:03:47,080
直到我碰到一个end of sentence

100
00:03:47,280 --> 00:03:48,840
看到EOS我就停掉了

101
00:03:49,160 --> 00:03:51,080
不然我就一直输出下去

102
00:03:51,719 --> 00:03:52,920
所以你可以看到是说

103
00:03:53,280 --> 00:03:53,960
这样的话

104
00:03:53,960 --> 00:03:56,560
他基本上你不管原句子多长

105
00:03:56,800 --> 00:03:59,560
和target的句子多长

106
00:04:00,200 --> 00:04:02,000
长度你不需要一样

107
00:04:02,000 --> 00:04:02,280
对吧

108
00:04:02,280 --> 00:04:04,760
因为反正就是按照时刻往前走

109
00:04:05,080 --> 00:04:06,040
走到停止为止

110
00:04:06,040 --> 00:04:08,160
就RNN做encoder

111
00:04:08,160 --> 00:04:10,160
可以take任意长的序列

112
00:04:10,160 --> 00:04:11,200
最后返回

113
00:04:11,240 --> 00:04:13,840
最后一个时刻的隐藏状态就行

114
00:04:14,240 --> 00:04:16,720
然后decoder反正一直往前走

115
00:04:16,720 --> 00:04:19,720
一直走到你最后看到句子的结束

116
00:04:20,160 --> 00:04:20,520
OK

117
00:04:20,520 --> 00:04:21,760
所以这就是说

118
00:04:21,920 --> 00:04:23,000
seq to seq

119
00:04:23,000 --> 00:04:25,640
怎么用RNN来处理一个

120
00:04:25,760 --> 00:04:27,440
任意长度的原句子

121
00:04:27,480 --> 00:04:29,440
到另外一个任意长度的

122
00:04:29,440 --> 00:04:30,920
target的句子的一个反应

123
00:04:31,640 --> 00:04:32,400
它也能够

124
00:04:32,400 --> 00:04:35,760
当然可以做任何这种一个变长的东西

125
00:04:35,760 --> 00:04:37,120
到另外一个变长东西的反应

126
00:04:37,320 --> 00:04:38,560
这当然是都可以做的

127
00:04:38,560 --> 00:04:40,560
所以它叫sequence to sequence

128
00:04:42,560 --> 00:04:44,720
但另外看到是一个细节

129
00:04:44,760 --> 00:04:47,240
就是说它隐藏状态是怎么传的

130
00:04:47,960 --> 00:04:48,920
这东西怎么传

131
00:04:49,560 --> 00:04:50,840
这东西具体是说

132
00:04:51,320 --> 00:04:53,520
它把最后一层的RNN

133
00:04:53,640 --> 00:04:54,840
我们RNN可能有很多层

134
00:04:54,880 --> 00:04:55,360
对吧

135
00:04:55,920 --> 00:04:58,560
它把最后一层的RNN

136
00:04:59,120 --> 00:05:04,120
在最后的时刻的隐藏状态

137
00:05:04,640 --> 00:05:06,280
它也就是它的输出了

138
00:05:07,400 --> 00:05:12,520
然后跟你句子的embedding的输入

139
00:05:12,720 --> 00:05:13,600
这两个东西

140
00:05:15,400 --> 00:05:16,120
弄起来

141
00:05:17,640 --> 00:05:20,120
然后作为你的输入

142
00:05:20,120 --> 00:05:21,880
就是说等于是把你

143
00:05:22,600 --> 00:05:24,200
incode的最后一层东西

144
00:05:24,360 --> 00:05:26,760
回到你这个东西最下一层

145
00:05:27,080 --> 00:05:28,480
跟你的输入放在一起

146
00:05:28,920 --> 00:05:29,320
进去

147
00:05:31,120 --> 00:05:31,520
OK

148
00:05:32,000 --> 00:05:35,520
所以其实说你的编码器

149
00:05:35,640 --> 00:05:36,720
你是不需要输出的

150
00:05:36,920 --> 00:05:38,360
就是你不需要全能阶层

151
00:05:39,240 --> 00:05:40,440
你只要拿到RNN的输入

152
00:05:40,800 --> 00:05:41,800
它的状态就行了

153
00:05:42,560 --> 00:05:44,600
然后就是说你最后时间步的状态

154
00:05:44,759 --> 00:05:46,199
作为它的初始状态

155
00:05:46,199 --> 00:05:48,000
和以及它的context

156
00:05:48,000 --> 00:05:49,639
就是说可以看到

157
00:05:49,639 --> 00:05:51,920
就是说不仅做影像状态

158
00:05:51,920 --> 00:05:54,360
还会作为它的跟输入

159
00:05:54,360 --> 00:05:55,560
给你合并起来一起做

160
00:05:55,560 --> 00:05:57,600
我们等会看代码怎么样

161
00:05:57,600 --> 00:05:58,680
具体实现它的

162
00:05:59,000 --> 00:06:01,280
所以这里很多种实现都有

163
00:06:01,439 --> 00:06:04,800
就是说它seq2seq用的是一种特定的实现

164
00:06:04,800 --> 00:06:07,160
给大家代码上解释一下

165
00:06:07,160 --> 00:06:08,280
这个更清楚一点

166
00:06:08,560 --> 00:06:13,760
训练跟推理会有一点点不一样

167
00:06:13,760 --> 00:06:16,920
训练反正encode是一样的

168
00:06:16,920 --> 00:06:18,200
encode反正你都能看到

169
00:06:18,200 --> 00:06:18,640
对吧

170
00:06:19,160 --> 00:06:20,280
decode会不一样一点

171
00:06:20,320 --> 00:06:21,520
decode就是说

172
00:06:21,560 --> 00:06:23,000
在训练的时候

173
00:06:23,480 --> 00:06:24,360
我是用

174
00:06:24,360 --> 00:06:26,480
我是知道我的目标句子的

175
00:06:27,080 --> 00:06:27,480
对吧

176
00:06:27,480 --> 00:06:29,120
我知道我的真正的翻译

177
00:06:29,240 --> 00:06:31,160
所以它的输入

178
00:06:31,280 --> 00:06:32,920
每个RNN的时候的输出

179
00:06:33,000 --> 00:06:36,720
是用的是真正的目标句子里面的输入

180
00:06:36,800 --> 00:06:38,960
所以就算你这个地方翻译错了

181
00:06:39,440 --> 00:06:40,720
就算你这里翻译错了

182
00:06:40,720 --> 00:06:41,560
我也没关系

183
00:06:41,560 --> 00:06:42,880
我给下一个时刻的输入

184
00:06:43,000 --> 00:06:44,320
还是正确的输入

185
00:06:45,040 --> 00:06:47,000
这样子的话就不会我们之前说

186
00:06:47,000 --> 00:06:48,640
我们做时序序列预测的时候

187
00:06:48,640 --> 00:06:50,280
预测长了就很难

188
00:06:50,880 --> 00:06:52,720
所以这个地方就是说在训练的时候

189
00:06:52,720 --> 00:06:54,960
我给你的是真正的句子

190
00:06:55,080 --> 00:06:58,480
真正的词是要帮助你做训练

191
00:06:58,760 --> 00:06:59,920
所以看到是说

192
00:07:00,200 --> 00:07:02,440
这个是你真正的句子

193
00:07:02,680 --> 00:07:04,480
就是把eos不要

194
00:07:04,520 --> 00:07:06,520
然后你每次预测它下一个词

195
00:07:07,720 --> 00:07:08,920
当推理的时候不一样

196
00:07:09,080 --> 00:07:09,520
推理的时候

197
00:07:09,520 --> 00:07:10,320
我们刚刚讲过了

198
00:07:10,320 --> 00:07:11,560
就是说推理的时候

199
00:07:11,560 --> 00:07:12,520
你没有真正的句子

200
00:07:12,520 --> 00:07:12,800
对吧

201
00:07:12,800 --> 00:07:14,160
所以你每一个时刻

202
00:07:14,360 --> 00:07:16,040
只能用上一个时刻的输出

203
00:07:16,120 --> 00:07:18,600
作为当前时刻的输入

204
00:07:18,640 --> 00:07:20,160
然后不断的预测下去

205
00:07:20,880 --> 00:07:21,440
OK

206
00:07:21,480 --> 00:07:23,600
但我们代码上会给大家讲一下

207
00:07:23,600 --> 00:07:25,400
这一些细节的区别

208
00:07:27,200 --> 00:07:28,560
然后另外一个是

209
00:07:28,720 --> 00:07:32,320
我们现在要去生成一个句子了

210
00:07:32,760 --> 00:07:34,120
之前我们做的是

211
00:07:34,120 --> 00:07:37,000
那个生成一个

212
00:07:37,000 --> 00:07:38,120
就预测一个词

213
00:07:38,360 --> 00:07:39,120
预测一个词

214
00:07:39,240 --> 00:07:40,920
预测一个bundle box都行

215
00:07:40,959 --> 00:07:42,600
但现在我要预测一个句子

216
00:07:42,800 --> 00:07:44,840
这个就是说我预测的句子

217
00:07:45,000 --> 00:07:47,040
可能跟你真实的句子

218
00:07:47,040 --> 00:07:48,399
长度就不一样了

219
00:07:48,680 --> 00:07:49,399
不一样的时候

220
00:07:49,399 --> 00:07:50,560
你怎么样去衡量

221
00:07:50,560 --> 00:07:52,079
它两个句子的好坏

222
00:07:52,519 --> 00:07:53,360
当然最简单

223
00:07:53,360 --> 00:07:54,600
你可以用edit distance

224
00:07:54,759 --> 00:07:56,360
就是说你要通过多少次变换

225
00:07:56,360 --> 00:07:58,079
可以把一个句子变成另外一个句子

226
00:07:58,879 --> 00:08:02,879
但是在机器翻译里面

227
00:08:02,879 --> 00:08:04,240
最常用的衡量状态

228
00:08:04,240 --> 00:08:05,839
一个叫做blue

229
00:08:06,480 --> 00:08:08,600
这个东西叫做blue

230
00:08:08,959 --> 00:08:11,439
我也不记得它那个英语是怎么说的

231
00:08:11,439 --> 00:08:12,519
反正叫blue

232
00:08:13,279 --> 00:08:14,159
它是怎么算的

233
00:08:14,319 --> 00:08:15,199
就是说

234
00:08:15,319 --> 00:08:17,439
它算所谓的n-grand

235
00:08:17,800 --> 00:08:19,439
就所谓的n-grand的精度

236
00:08:20,319 --> 00:08:22,839
pn就是预测里面所有n-grand的精度

237
00:08:23,120 --> 00:08:24,279
n-grand给大家解释一下

238
00:08:24,279 --> 00:08:25,159
是什么东西

239
00:08:25,240 --> 00:08:26,560
就是说n-grand大家都知道

240
00:08:26,680 --> 00:08:30,399
就是unigrand就是一个词

241
00:08:30,719 --> 00:08:32,080
background就是两个词

242
00:08:32,879 --> 00:08:35,439
然后所以n-grand的精度是什么意思

243
00:08:36,480 --> 00:08:37,519
精度是说

244
00:08:37,519 --> 00:08:37,919
首先

245
00:08:38,439 --> 00:08:40,519
e-grand就是unigrand是什么意思

246
00:08:40,639 --> 00:08:42,120
unigrand的精度是说

247
00:08:43,399 --> 00:08:45,559
我考虑我预测序列里面

248
00:08:45,559 --> 00:08:47,039
所有的unigrand

249
00:08:47,039 --> 00:08:48,720
这里就我的预测是这个

250
00:08:48,919 --> 00:08:50,399
就5个对吧

251
00:08:50,439 --> 00:08:51,720
我有5个unigrand

252
00:08:51,759 --> 00:08:53,480
所以放在这个地方

253
00:08:54,000 --> 00:08:56,320
然后我们看每一个unigrand

254
00:08:56,519 --> 00:09:00,039
是不是在真实的ground truth里面

255
00:09:00,039 --> 00:09:00,759
出现了

256
00:09:01,480 --> 00:09:02,120
a出现了

257
00:09:02,120 --> 00:09:02,679
对吧

258
00:09:03,159 --> 00:09:04,480
a在这里面出现了

259
00:09:04,519 --> 00:09:05,559
b出现了

260
00:09:06,360 --> 00:09:07,399
第二个b没有

261
00:09:07,399 --> 00:09:08,320
因为第二个b没了

262
00:09:08,360 --> 00:09:09,600
你就一个b对吧

263
00:09:09,799 --> 00:09:11,240
只match到了一个b

264
00:09:11,279 --> 00:09:12,200
c出现了

265
00:09:12,200 --> 00:09:12,879
d出现了

266
00:09:12,919 --> 00:09:17,759
所以精度是match到了是4

267
00:09:17,759 --> 00:09:19,200
然后一共的是5

268
00:09:20,120 --> 00:09:21,000
p2是什么意思

269
00:09:21,399 --> 00:09:23,039
p2就是background

270
00:09:23,039 --> 00:09:25,759
background就是abbccd

271
00:09:26,559 --> 00:09:27,840
然后一共有4个对吧

272
00:09:27,840 --> 00:09:28,759
反正你常为5

273
00:09:28,960 --> 00:09:30,639
你的二观就有4个

274
00:09:31,279 --> 00:09:32,039
ab有没有

275
00:09:32,039 --> 00:09:32,919
ab有

276
00:09:33,759 --> 00:09:36,000
bcbb没有对吧

277
00:09:36,240 --> 00:09:36,959
bc有没有

278
00:09:36,959 --> 00:09:38,679
bc在原句子里面有

279
00:09:38,679 --> 00:09:39,439
cd也有

280
00:09:39,439 --> 00:09:41,639
所以你有一个没有match到

281
00:09:41,679 --> 00:09:44,079
最后是说你的精度是3

282
00:09:44,319 --> 00:09:45,319
p3也是一样的

283
00:09:45,399 --> 00:09:46,799
就是abb有没有

284
00:09:46,839 --> 00:09:47,839
abb没有

285
00:09:47,839 --> 00:09:49,000
bbc没有

286
00:09:49,000 --> 00:09:50,240
bcd有

287
00:09:50,240 --> 00:09:51,399
对这个地方有

288
00:09:51,439 --> 00:09:52,759
所以你有三个

289
00:09:52,759 --> 00:09:55,199
一共有三个3g

290
00:09:55,240 --> 00:09:56,959
所以你的精度是3分之一

291
00:09:57,199 --> 00:09:58,039
4g就没有了

292
00:09:58,039 --> 00:09:59,399
就是abbc

293
00:10:00,000 --> 00:10:02,759
abbcbbcd都没有

294
00:10:03,240 --> 00:10:03,919
Ok

295
00:10:04,319 --> 00:10:06,120
所以基本上就是后面都是0了

296
00:10:07,360 --> 00:10:09,120
然后你有了这些东西之后

297
00:10:09,319 --> 00:10:11,240
他去算这个东西这么算了

298
00:10:12,079 --> 00:10:13,919
然后首先他有两项

299
00:10:14,480 --> 00:10:15,360
第一项是说

300
00:10:15,360 --> 00:10:16,319
你的

301
00:10:16,759 --> 00:10:18,000
你预测的长度

302
00:10:18,000 --> 00:10:19,799
和你的标签的长度

303
00:10:20,000 --> 00:10:21,559
假设你的预测长度

304
00:10:21,559 --> 00:10:22,399
比你的标签

305
00:10:22,399 --> 00:10:24,360
真实的长度小很多的话

306
00:10:24,399 --> 00:10:25,559
那么这个数就大于1

307
00:10:25,559 --> 00:10:26,039
对吧

308
00:10:26,039 --> 00:10:28,000
1减它之后就变成一个负数

309
00:10:28,200 --> 00:10:29,600
exp的负数

310
00:10:29,600 --> 00:10:31,000
就变成一个很小的数了

311
00:10:31,120 --> 00:10:31,960
就是说

312
00:10:32,159 --> 00:10:34,080
你的就不是越大越好

313
00:10:34,159 --> 00:10:34,840
首先

314
00:10:36,120 --> 00:10:37,519
它是完美是1

315
00:10:37,519 --> 00:10:38,279
1是最高

316
00:10:38,279 --> 00:10:40,039
然后越小就是越差

317
00:10:40,080 --> 00:10:41,919
所以如果你原句子

318
00:10:41,919 --> 00:10:43,679
你的真实的标签

319
00:10:44,679 --> 00:10:45,679
目标就很长

320
00:10:45,679 --> 00:10:46,720
你预测很短的话

321
00:10:46,919 --> 00:10:49,720
这一项会导致你会惩罚比较严重

322
00:10:50,120 --> 00:10:50,960
因为你越短

323
00:10:50,960 --> 00:10:52,399
你越容易命中你的精度

324
00:10:52,399 --> 00:10:52,919
对吧

325
00:10:54,039 --> 00:10:56,120
假设我就是说预测一个a出来

326
00:10:56,120 --> 00:10:57,519
我的精度就是全部是1

327
00:10:57,519 --> 00:10:58,039
对吧

328
00:10:58,519 --> 00:11:01,439
所以这里就是防止你预测过短

329
00:11:01,679 --> 00:11:03,039
第二个是说

330
00:11:03,679 --> 00:11:04,919
p是一个pn

331
00:11:04,919 --> 00:11:06,480
反正是一个小于1的一个数

332
00:11:06,840 --> 00:11:07,519
小于等于1

333
00:11:08,000 --> 00:11:09,960
所以然后它如果n

334
00:11:10,519 --> 00:11:11,120
n比较大

335
00:11:11,120 --> 00:11:12,439
就是预测比较长

336
00:11:12,759 --> 00:11:15,279
它就是说长匹配有高权重

337
00:11:15,279 --> 00:11:17,039
因为你2n分之1

338
00:11:18,120 --> 00:11:19,960
然后我们这个项就是n越大的话

339
00:11:19,960 --> 00:11:21,279
你这个项就越小

340
00:11:21,319 --> 00:11:22,439
对于一个小于1的数

341
00:11:22,679 --> 00:11:23,559
你这个东西越小

342
00:11:23,559 --> 00:11:24,919
它的值就会越大

343
00:11:24,919 --> 00:11:25,480
对吧

344
00:11:25,720 --> 00:11:28,080
所以就是说你的n越大

345
00:11:28,080 --> 00:11:30,320
你整个给你的权重

346
00:11:30,320 --> 00:11:31,360
你会变得更大

347
00:11:31,519 --> 00:11:32,720
要把所有东西乘起来

348
00:11:33,480 --> 00:11:33,840
OK

349
00:11:33,840 --> 00:11:35,680
这就是最后你的blue的score

350
00:11:35,800 --> 00:11:39,440
就是用来处理你的两个句子的匹配

351
00:11:39,480 --> 00:11:40,680
而且这两句子的长度

352
00:11:40,680 --> 00:11:41,879
可以是不一样的

353
00:11:43,039 --> 00:11:43,279
OK

354
00:11:43,279 --> 00:11:45,000
我们等会会给大家看一下实现

355
00:11:47,080 --> 00:11:48,000
最后总结一下

356
00:11:48,000 --> 00:11:50,159
就是说seek to seek

357
00:11:50,320 --> 00:11:52,399
就是说从一个句子

358
00:11:52,920 --> 00:11:54,399
生成到另外一个句子

359
00:11:54,399 --> 00:11:55,600
它就是要解决这个问题

360
00:11:55,799 --> 00:11:57,399
积极翻译是其中一个

361
00:11:57,879 --> 00:12:00,840
然后也是一个大类问题

362
00:12:00,919 --> 00:12:04,159
我们之后都会再给大家多讲两个

363
00:12:04,679 --> 00:12:06,919
另外他用的是编码器

364
00:12:06,919 --> 00:12:07,840
解码器的架构

365
00:12:08,039 --> 00:12:10,159
然后他两个都用的是RN

366
00:12:10,720 --> 00:12:13,519
他具体说RN这个东西定了之后

367
00:12:13,679 --> 00:12:15,399
具体它怎么传你他状态

368
00:12:15,519 --> 00:12:17,159
就是说将编码器

369
00:12:17,159 --> 00:12:18,919
最后时间的引状态

370
00:12:18,919 --> 00:12:20,960
来初始化解码器的引状态

371
00:12:21,240 --> 00:12:24,360
以及那个东西也会作为输入进去

372
00:12:24,600 --> 00:12:26,000
来完成信息传递

373
00:12:26,759 --> 00:12:28,959
另外一个说这种积极翻译

374
00:12:29,120 --> 00:12:30,399
这种句子翻译

375
00:12:30,519 --> 00:12:33,840
经常会用blue来衡量生成序列的好坏

