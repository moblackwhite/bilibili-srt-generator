1
00:00:00,000 --> 00:00:02,919
我们来讲感知机

2
00:00:02,919 --> 00:00:08,160
这个是1960年的时候的感知机的一个原型图

3
00:00:08,160 --> 00:00:10,560
从wikipedia上copy过来的

4
00:00:10,919 --> 00:00:14,359
还可以看到是说每根线它真的就是你一个权重

5
00:00:14,359 --> 00:00:15,839
它真的就是一根线连过去

6
00:00:15,839 --> 00:00:18,199
所以它是一个特别巨大的一个模型

7
00:00:19,559 --> 00:00:22,679
然后我们来讲一下感知机

8
00:00:22,679 --> 00:00:26,719
这个是人工智能最早的一个模型了

9
00:00:26,719 --> 00:00:28,359
就是70年前

10
00:00:28,960 --> 00:00:30,320
60年70年前

11
00:00:30,640 --> 00:00:33,240
感知机其实是一个很简单的模型

12
00:00:33,280 --> 00:00:36,560
我们说给定输入x

13
00:00:37,679 --> 00:00:39,320
x是一个向量

14
00:00:40,480 --> 00:00:44,159
权重是一个w也是一个向量

15
00:00:44,480 --> 00:00:46,799
然后偏移是一个标量

16
00:00:47,439 --> 00:00:49,359
那么感知机的输出是

17
00:00:51,120 --> 00:00:53,640
w和x做类机

18
00:00:53,679 --> 00:00:57,320
就是你的权重和你的输入两个向量做类机

19
00:00:57,439 --> 00:00:59,079
加上你的偏移b

20
00:00:59,679 --> 00:01:02,039
然后再在上面做一个sigma函数

21
00:01:02,079 --> 00:01:04,120
sigma这里有很多种选择

22
00:01:04,280 --> 00:01:08,040
第一个选择是说你可以把它改成

23
00:01:08,040 --> 00:01:10,480
一个是如果你的输入是大于0的话

24
00:01:10,480 --> 00:01:11,879
我就是输出0

25
00:01:11,920 --> 00:01:12,920
输出1

26
00:01:13,200 --> 00:01:14,760
如果是小于等于0的话

27
00:01:14,760 --> 00:01:16,079
那我就输出0

28
00:01:16,799 --> 00:01:19,519
就是说感知机其实就是一个二分类的问题

29
00:01:19,879 --> 00:01:21,159
如果你输入大于0

30
00:01:21,200 --> 00:01:21,840
就是1

31
00:01:21,879 --> 00:01:22,560
正类

32
00:01:22,599 --> 00:01:23,400
如果小于0

33
00:01:23,439 --> 00:01:25,240
可以是0

34
00:01:25,280 --> 00:01:27,000
当然你可以改成0和1

35
00:01:27,000 --> 00:01:28,079
当然你随便怎么改了

36
00:01:28,119 --> 00:01:29,839
我们当然可以改成说

37
00:01:29,879 --> 00:01:32,879
比如说我们可以改成-1也行

38
00:01:32,879 --> 00:01:35,079
比如说改成-1

39
00:01:35,839 --> 00:01:37,359
就是说你输出正义和-1

40
00:01:37,839 --> 00:01:40,599
所以感知机从图形上来看

41
00:01:40,599 --> 00:01:43,479
就是说你的输入是x1到xd

42
00:01:43,479 --> 00:01:45,359
假设你有第1个输入的话

43
00:01:45,399 --> 00:01:49,199
你的输出就是你一个单一个元素

44
00:01:49,560 --> 00:01:50,759
我们之前看过

45
00:01:51,119 --> 00:01:52,479
就是单一个元素的输出

46
00:01:52,479 --> 00:01:54,759
你可以做成一个二分类的问题

47
00:01:55,400 --> 00:01:57,960
好

48
00:01:57,960 --> 00:02:00,040
所以这就是一个二分类

49
00:02:00,040 --> 00:02:03,040
我们输出可以是1或者-1

50
00:02:03,040 --> 00:02:05,000
1和0也是可以的

51
00:02:05,120 --> 00:02:08,480
所以跟我们之前的现行回归的输出不一样

52
00:02:08,480 --> 00:02:10,879
是说虽然它都是一个输出

53
00:02:10,879 --> 00:02:13,360
但是现行回归是一个实数

54
00:02:13,960 --> 00:02:16,439
这里我们输出的是一个离散的类

55
00:02:17,760 --> 00:02:19,760
比如说另外一个是说

56
00:02:19,800 --> 00:02:22,240
跟我们的softmax的区别是说

57
00:02:22,280 --> 00:02:24,640
softmax如果有n个类的话

58
00:02:24,640 --> 00:02:26,640
它就会输出n个元素

59
00:02:26,840 --> 00:02:29,000
所以是可以是一个多分类的问题

60
00:02:29,040 --> 00:02:30,840
而这里我们就输出一个元素

61
00:02:30,840 --> 00:02:33,040
所以它只能最多做一个二分类的问题

62
00:02:33,240 --> 00:02:33,800
OK

63
00:02:36,200 --> 00:02:36,400
好

64
00:02:36,400 --> 00:02:37,880
这就是一个感知机

65
00:02:37,880 --> 00:02:41,040
我们来看一下当年是怎么训练感知机的

66
00:02:41,560 --> 00:02:44,240
这个算法也是非常简单

67
00:02:44,240 --> 00:02:45,520
大家可以看一下

68
00:02:45,840 --> 00:02:50,320
首先 w动词0和bios也是0

69
00:02:50,360 --> 00:02:51,760
所以跟我们之前会不一样

70
00:02:51,919 --> 00:02:54,000
我们之前w是一个随机的

71
00:02:54,159 --> 00:02:55,120
一个权重

72
00:02:55,319 --> 00:02:56,439
这里就直接给0了

73
00:02:56,439 --> 00:02:57,319
简单起见

74
00:02:57,679 --> 00:02:59,959
然后我们对一个样本i

75
00:03:00,359 --> 00:03:02,359
从0开始一直到最后

76
00:03:02,879 --> 00:03:03,599
假设你的

77
00:03:03,599 --> 00:03:05,959
假设当前是第i一个样本

78
00:03:06,000 --> 00:03:09,840
那就是如果你的yi就是你的标号

79
00:03:09,840 --> 00:03:12,319
再假设是正义和负义两个标号

80
00:03:12,799 --> 00:03:14,120
然后乘以

81
00:03:16,120 --> 00:03:18,840
w和x做类迹

82
00:03:19,120 --> 00:03:20,359
加上bios

83
00:03:20,640 --> 00:03:22,400
就如果它小于等于0

84
00:03:22,680 --> 00:03:23,360
那是什么意思

85
00:03:23,800 --> 00:03:25,480
就是说你小于等于0

86
00:03:25,480 --> 00:03:27,600
意味着是说你分类感知机

87
00:03:27,600 --> 00:03:29,320
把样本预测错了

88
00:03:29,520 --> 00:03:32,480
因为如果你是首先看yi

89
00:03:32,840 --> 00:03:34,080
我们来我们有笔

90
00:03:34,080 --> 00:03:35,080
现在我们有笔

91
00:03:35,080 --> 00:03:37,080
我们就比较高级一点

92
00:03:37,080 --> 00:03:37,560
好

93
00:03:38,040 --> 00:03:38,640
假设

94
00:03:39,520 --> 00:03:40,520
假如像

95
00:03:40,680 --> 00:03:43,240
如果是大于0的话

96
00:03:43,440 --> 00:03:46,360
那么就意味着你要分类成一个正类

97
00:03:46,560 --> 00:03:49,520
那么假设你的yi是正义的话

98
00:03:49,680 --> 00:03:51,640
那么它就是一个大于0的一个数

99
00:03:51,760 --> 00:03:53,080
假设你小于等于0

100
00:03:53,080 --> 00:03:55,840
那意味着yi那就是一个负义

101
00:03:56,280 --> 00:03:58,280
所以就表示你分类分错了

102
00:03:58,600 --> 00:03:59,400
反过来讲

103
00:03:59,920 --> 00:04:02,560
如果你是小于等于0的话

104
00:04:03,120 --> 00:04:04,600
但是你的正义

105
00:04:04,600 --> 00:04:05,000
这样子

106
00:04:05,000 --> 00:04:06,200
你的预测应该是一个负义

107
00:04:06,200 --> 00:04:06,719
对不对

108
00:04:06,879 --> 00:04:08,400
但如果你的yi

109
00:04:08,400 --> 00:04:10,360
你的真实的又是一个正义的话

110
00:04:10,719 --> 00:04:12,480
那就是你分类又分错了

111
00:04:12,520 --> 00:04:14,680
那就是满足这个情况的话

112
00:04:14,680 --> 00:04:16,720
一定是说当前的权重

113
00:04:16,720 --> 00:04:18,000
对我们的样本的分类

114
00:04:18,000 --> 00:04:19,080
是一个错误的

115
00:04:20,519 --> 00:04:22,919
那么如果是分类错了

116
00:04:22,919 --> 00:04:23,639
那我怎么做

117
00:04:23,839 --> 00:04:25,039
就是对w

118
00:04:25,240 --> 00:04:26,439
我们做一次更新

119
00:04:26,799 --> 00:04:30,519
w等于w加上yi乘以xi

120
00:04:31,039 --> 00:04:34,079
就是说你的标号乘以你的样本

121
00:04:34,240 --> 00:04:36,000
然后把它做权重更新

122
00:04:36,199 --> 00:04:37,240
那么你的标量

123
00:04:37,680 --> 00:04:39,000
就是你的偏差

124
00:04:39,039 --> 00:04:41,799
就是b等于b加上y

125
00:04:41,799 --> 00:04:43,519
就是你再加上你的标号

126
00:04:44,079 --> 00:04:46,079
然后就这一步就结束了

127
00:04:46,399 --> 00:04:48,319
然后你一直做

128
00:04:48,319 --> 00:04:50,639
直到你所有的类都分类正确了

129
00:04:51,759 --> 00:04:53,399
这也是一个很有意思的

130
00:04:53,399 --> 00:04:55,319
一个停止条件

131
00:04:56,480 --> 00:04:58,199
那么它的等价于

132
00:04:58,519 --> 00:04:59,439
就是说这个算法

133
00:04:59,439 --> 00:05:02,040
其实就是一个梯度下降了

134
00:05:02,240 --> 00:05:03,959
它等价于使用一个

135
00:05:03,959 --> 00:05:06,560
批量大小为1的梯度下降

136
00:05:07,319 --> 00:05:08,079
我们理解一下

137
00:05:08,480 --> 00:05:09,639
批量大小为1

138
00:05:09,639 --> 00:05:11,680
就是说每一次你拿一个样本

139
00:05:11,680 --> 00:05:13,399
去做算梯度

140
00:05:13,399 --> 00:05:14,480
然后进行更新

141
00:05:14,719 --> 00:05:15,680
然后我们没有说

142
00:05:15,680 --> 00:05:17,719
它是随机梯度下降

143
00:05:17,720 --> 00:05:20,200
是因为感知机最原始的模型

144
00:05:20,200 --> 00:05:22,920
就是你不断一遍一遍的扫数据

145
00:05:22,920 --> 00:05:24,880
没有说要随机去弄

146
00:05:26,120 --> 00:05:28,520
如果你是使用梯度下降的话

147
00:05:28,520 --> 00:05:31,600
那么感知机就等价于使用

148
00:05:31,760 --> 00:05:32,960
下面梯度函数

149
00:05:33,800 --> 00:05:35,480
下面损失函数

150
00:05:35,480 --> 00:05:37,840
它的损失函数是说

151
00:05:37,960 --> 00:05:39,440
首先你算一下

152
00:05:39,800 --> 00:05:44,920
标号y乘以w和x的类迹

153
00:05:45,120 --> 00:05:46,440
然后有个负号在这里

154
00:05:46,560 --> 00:05:48,279
然后取了一个max0

155
00:05:48,279 --> 00:05:49,680
max0是干嘛的

156
00:05:49,959 --> 00:05:51,480
就是说max0这个东西

157
00:05:52,079 --> 00:05:53,160
这个东西就是说

158
00:05:53,160 --> 00:05:54,240
我又换一个颜色

159
00:05:54,399 --> 00:05:55,839
max0其实是对应的

160
00:05:56,120 --> 00:05:57,079
IF的语句

161
00:05:58,199 --> 00:06:01,800
就如果你的分类正确的话

162
00:06:02,360 --> 00:06:03,319
分类正确的话

163
00:06:03,319 --> 00:06:07,720
那么说这一个项是要大于0的

164
00:06:08,759 --> 00:06:10,040
那么你的负的话

165
00:06:10,040 --> 00:06:11,480
那么就是一个负数

166
00:06:11,480 --> 00:06:13,680
那么你的max就输出为0

167
00:06:13,680 --> 00:06:15,159
那么你的梯度是一个常数

168
00:06:15,160 --> 00:06:17,120
我就不会去做更新

169
00:06:17,120 --> 00:06:18,720
就是对应的if上面

170
00:06:18,720 --> 00:06:20,080
这个if语句不成立

171
00:06:20,840 --> 00:06:23,000
如果是说你分类错了的话

172
00:06:23,040 --> 00:06:24,640
那么这时候你就有梯度了

173
00:06:24,680 --> 00:06:26,880
所以进入到上面if的语句

174
00:06:26,880 --> 00:06:28,200
里面进行更新

175
00:06:28,440 --> 00:06:30,840
所以说为什么你要加一个max在里面

176
00:06:30,960 --> 00:06:32,200
所以这个就是说

177
00:06:32,240 --> 00:06:35,520
感知机等价于我们用损失函数

178
00:06:35,879 --> 00:06:38,720
然后使用批量大小为1

179
00:06:38,720 --> 00:06:39,840
做梯度下降

180
00:06:40,120 --> 00:06:42,400
这就是当年60年代

181
00:06:42,400 --> 00:06:43,800
我们发明的一个算法

182
00:06:43,840 --> 00:06:46,639
怎么样对应到现在的技术

183
00:06:46,960 --> 00:06:48,680
而且它之所以叫感知机

184
00:06:48,680 --> 00:06:50,360
确实是因为跟神经网络

185
00:06:50,560 --> 00:06:53,160
跟人的神经网络是相关的

186
00:06:53,160 --> 00:06:53,879
perceptron

187
00:06:55,040 --> 00:06:55,520
OK

188
00:06:57,000 --> 00:06:57,240
好

189
00:06:57,240 --> 00:06:58,520
接下来我们看一个例子

190
00:06:59,400 --> 00:07:01,319
首先我们假设有两个

191
00:07:01,319 --> 00:07:02,840
我们要分狗和猫

192
00:07:03,120 --> 00:07:04,680
然后我们有两个轴

193
00:07:04,680 --> 00:07:06,400
第一个轴和第二个轴

194
00:07:06,400 --> 00:07:07,800
就是一个二元的输入

195
00:07:08,120 --> 00:07:10,360
假设我们有一个狗和一个猫

196
00:07:10,360 --> 00:07:12,800
那么我们权重

197
00:07:12,800 --> 00:07:15,000
现在的分类就是我们的一个

198
00:07:15,000 --> 00:07:16,480
这根黑色的线

199
00:07:17,360 --> 00:07:18,360
下一次

200
00:07:18,480 --> 00:07:20,400
假设来了一只新的狗

201
00:07:21,439 --> 00:07:23,040
那么刚刚那个线

202
00:07:23,040 --> 00:07:25,040
如果我们还画在这里的话

203
00:07:25,040 --> 00:07:25,639
刚刚这个线

204
00:07:25,639 --> 00:07:27,879
大概是在这个地方指的样子

205
00:07:28,319 --> 00:07:30,080
那么就是说你会发现

206
00:07:30,080 --> 00:07:32,120
他对狗分类分错了

207
00:07:32,160 --> 00:07:32,759
那么就是说

208
00:07:32,759 --> 00:07:34,040
我会对样本做一次更新

209
00:07:34,040 --> 00:07:35,840
就把这个线往下一点点

210
00:07:36,600 --> 00:07:37,960
比如说你们狗在下面

211
00:07:38,280 --> 00:07:40,160
然后你分个面

212
00:07:40,160 --> 00:07:41,360
加上狗的权重

213
00:07:41,360 --> 00:07:44,680
他就会把分界面往下拉

214
00:07:45,639 --> 00:07:46,879
然后你再来一只狗

215
00:07:46,879 --> 00:07:48,040
他就再往下拉

216
00:07:48,280 --> 00:07:49,080
你下面一只猫

217
00:07:49,080 --> 00:07:50,439
也会往回推一点点

218
00:07:50,879 --> 00:07:53,759
然后你再不断的做几次

219
00:07:56,280 --> 00:07:59,720
基本上你可以一直做

220
00:07:59,720 --> 00:08:01,560
做到最后发现

221
00:08:01,680 --> 00:08:02,800
所有的样本看完

222
00:08:02,800 --> 00:08:04,040
所有的分类都没问题

223
00:08:04,040 --> 00:08:05,520
那么我们就可以停止了

224
00:08:06,040 --> 00:08:08,800
所以这一个奇怪的停止条件是说

225
00:08:08,920 --> 00:08:11,240
你得对所有的类都分类正确

226
00:08:12,360 --> 00:08:13,280
我们看一下

227
00:08:13,280 --> 00:08:15,120
它的收敛定理是什么样子

228
00:08:15,680 --> 00:08:16,960
所谓的收敛定理

229
00:08:16,960 --> 00:08:18,759
是说我什么时候能够停

230
00:08:18,759 --> 00:08:20,240
我是不是真的能够停

231
00:08:20,680 --> 00:08:22,560
感知机是一个很简单的模型

232
00:08:22,560 --> 00:08:25,120
所以它有一个很好的收敛定理

233
00:08:25,520 --> 00:08:27,639
我们做这么几个假设

234
00:08:28,960 --> 00:08:30,800
假设我们的数据

235
00:08:30,800 --> 00:08:33,399
在一个半径为r的一个区域里面

236
00:08:33,399 --> 00:08:37,120
就是说假设这一个区域

237
00:08:37,120 --> 00:08:39,159
是它是为r的

238
00:08:40,159 --> 00:08:43,959
然后我假设有个余量rho

239
00:08:44,240 --> 00:08:46,799
使得我存在一个分解面

240
00:08:47,199 --> 00:08:50,600
存在一个这样子的分解面

241
00:08:51,000 --> 00:08:54,759
它的权重的l2ln加起来是小于等于1的

242
00:08:55,039 --> 00:08:57,600
使得我分解面

243
00:08:57,600 --> 00:09:00,079
能够对所有的分类都是正确的

244
00:09:00,079 --> 00:09:00,519
记得吗

245
00:09:00,679 --> 00:09:02,799
这个东西要大于等于0

246
00:09:02,799 --> 00:09:03,959
才是分类正确的

247
00:09:04,679 --> 00:09:07,639
就是说对它所有东西都分类正确

248
00:09:07,639 --> 00:09:09,799
而且它是有一定余量的

249
00:09:09,799 --> 00:09:12,199
就是说你看到是这里有个rho

250
00:09:12,199 --> 00:09:13,759
rho是一个大于0的东西

251
00:09:14,319 --> 00:09:15,720
就是说你可以对应的话

252
00:09:15,720 --> 00:09:19,039
就是这一个头像换一点

253
00:09:19,039 --> 00:09:21,279
就是说这个地方是有个rho在这里的

254
00:09:21,519 --> 00:09:23,879
就存在一个margin

255
00:09:24,120 --> 00:09:26,439
使得我刚好能够把所有的类别都分开

256
00:09:27,120 --> 00:09:29,519
那么如果是这样的情况下

257
00:09:29,600 --> 00:09:32,799
感知机确信能够找到我们的最优解

258
00:09:33,000 --> 00:09:36,919
而且它保证我只会在r平方

259
00:09:36,919 --> 00:09:39,599
加上除以rho平方之后收敛

260
00:09:39,599 --> 00:09:40,519
就是会停止

261
00:09:41,479 --> 00:09:43,279
这个地方可以大家理解一下

262
00:09:43,439 --> 00:09:44,360
这个就是说

263
00:09:44,559 --> 00:09:47,000
r的话就是说你的数据的大小

264
00:09:47,199 --> 00:09:49,240
当你是一个很大很大的区域的时候

265
00:09:49,240 --> 00:09:50,959
当然你的收敛就会变慢

266
00:09:51,319 --> 00:09:51,599
对吧

267
00:09:51,599 --> 00:09:52,839
假设你要在一个很大区域

268
00:09:52,839 --> 00:09:54,479
一开始我们的w是0

269
00:09:54,759 --> 00:09:57,000
所以就是说假设你的数据在一个很大区域的话

270
00:09:57,000 --> 00:09:58,199
然后我看你要走很多步

271
00:09:58,799 --> 00:10:00,360
第二个是说你的rho

272
00:10:00,719 --> 00:10:03,599
就是说看你的数据是不是很好

273
00:10:03,639 --> 00:10:04,279
很好的话

274
00:10:04,279 --> 00:10:07,439
就是说我能够真的两个点分的特别开

275
00:10:07,480 --> 00:10:08,559
如果分很开的话

276
00:10:08,559 --> 00:10:10,240
当然我这就很简单的数据

277
00:10:10,240 --> 00:10:11,519
我很快就收敛了

278
00:10:12,600 --> 00:10:13,919
如果你不行的话

279
00:10:14,519 --> 00:10:15,559
那么就是说

280
00:10:16,319 --> 00:10:18,279
如果你的分隔面特别小

281
00:10:18,279 --> 00:10:19,559
那么我要找到这个地方

282
00:10:19,559 --> 00:10:21,000
就会花更多的时间

283
00:10:21,199 --> 00:10:23,639
这就是感知机的收敛定理

284
00:10:24,159 --> 00:10:25,720
我们这里就是解释一下

285
00:10:25,720 --> 00:10:30,679
感知机在收敛定理长什么样子

286
00:10:30,720 --> 00:10:32,279
我们不讲证明了

287
00:10:32,480 --> 00:10:34,079
大家有兴趣的话

288
00:10:34,079 --> 00:10:35,480
可以作为一个练习题

289
00:10:35,480 --> 00:10:36,839
去看一下怎么证明

290
00:10:36,839 --> 00:10:38,679
它的证明其实也是挺简单的

291
00:10:38,679 --> 00:10:40,559
大概可能10行

292
00:10:40,559 --> 00:10:41,480
代码不行

293
00:10:41,480 --> 00:10:42,720
10行公式能够搞定

294
00:10:43,480 --> 00:10:44,079
好

295
00:10:44,919 --> 00:10:46,679
所以我们刚刚讲到的是

296
00:10:47,639 --> 00:10:49,480
感知机的一个收敛定理

297
00:10:50,039 --> 00:10:52,799
接下来说感知机有什么问题

298
00:10:53,439 --> 00:10:56,480
感知机它不能理和XOR这个函数

299
00:10:57,519 --> 00:10:59,279
XOR这个是什么意思呢

300
00:10:59,319 --> 00:11:00,120
就是说

301
00:11:01,120 --> 00:11:03,480
假设我们来画一下

302
00:11:04,560 --> 00:11:05,519
我们有笔了

303
00:11:05,519 --> 00:11:06,759
现在比较高级

304
00:11:07,200 --> 00:11:09,240
选一个不一样的颜色

305
00:11:10,279 --> 00:11:12,480
假设我这里画一个两个轴的话

306
00:11:13,200 --> 00:11:14,879
就是X和Y的话

307
00:11:15,039 --> 00:11:16,320
那么这个点是1

308
00:11:16,320 --> 00:11:17,000
这个点是1

309
00:11:17,240 --> 00:11:18,120
这个点是-1

310
00:11:18,320 --> 00:11:18,840
-1

311
00:11:19,000 --> 00:11:20,279
XOR是说

312
00:11:20,320 --> 00:11:23,759
当我的输入X和Y都是1的时候

313
00:11:23,759 --> 00:11:26,120
那么它就是一个-1类

314
00:11:26,480 --> 00:11:27,799
就是不一样

315
00:11:27,800 --> 00:11:30,520
我就是除0

316
00:11:30,520 --> 00:11:32,040
就除一个0

317
00:11:32,320 --> 00:11:33,800
我就认为是一个-1类

318
00:11:33,800 --> 00:11:35,200
或者0类都没关系

319
00:11:35,240 --> 00:11:37,200
如果是不相同的话

320
00:11:37,200 --> 00:11:38,600
那就是正一类

321
00:11:39,360 --> 00:11:41,240
就是说这就是说

322
00:11:41,240 --> 00:11:43,120
红色两个点是同样一个类

323
00:11:43,320 --> 00:11:45,440
绿色两个点是同样一个类

324
00:11:46,240 --> 00:11:47,360
感知机大家知道

325
00:11:47,360 --> 00:11:49,840
如果是二维的输入的话

326
00:11:49,840 --> 00:11:50,960
那么它的分隔面

327
00:11:50,960 --> 00:11:52,160
因为它是一个线性模型

328
00:11:52,160 --> 00:11:53,320
一定是一道线

329
00:11:54,000 --> 00:11:54,800
可以看到是说

330
00:11:54,800 --> 00:11:56,400
你不管怎么切它

331
00:11:56,879 --> 00:11:58,519
你的无法在一条线

332
00:11:58,519 --> 00:12:00,159
把整个数据给分对

333
00:12:00,360 --> 00:12:04,279
比如说你切在这个地方的话

334
00:12:04,319 --> 00:12:07,639
那么你的红色在一边

335
00:12:07,639 --> 00:12:09,039
但是绿色就分开了

336
00:12:09,199 --> 00:12:10,600
如果你切在下面的话

337
00:12:11,240 --> 00:12:13,039
如果是绿色分对了

338
00:12:13,039 --> 00:12:14,639
但是红色有一个是错误的

339
00:12:16,279 --> 00:12:18,000
所以就是说感知机

340
00:12:18,000 --> 00:12:19,679
不能理和XOR这个函数

341
00:12:19,679 --> 00:12:22,600
因为它只能产生线性分隔面

342
00:12:23,080 --> 00:12:26,639
这个是Minsky和在1969年

343
00:12:26,639 --> 00:12:27,879
提出的一个说

344
00:12:27,879 --> 00:12:29,440
你们感知机什么时候不work

345
00:12:30,080 --> 00:12:32,240
这个事情直接导入了

346
00:12:32,240 --> 00:12:34,519
导致了AI的第一个寒冬

347
00:12:34,519 --> 00:12:37,759
觉得你模型搞那么复杂

348
00:12:37,759 --> 00:12:39,159
我建一个那么大的机器

349
00:12:39,159 --> 00:12:41,000
结果发现我连个最简单

350
00:12:41,000 --> 00:12:42,720
XOR函数都不能做的话

351
00:12:42,720 --> 00:12:45,399
那么我用你们这一套干什么

352
00:12:45,399 --> 00:12:48,279
因为接下来大家就会去转到

353
00:12:48,279 --> 00:12:50,000
一个别的一个方向去

354
00:12:50,120 --> 00:12:52,559
这个方向我们不会在这里介绍了

355
00:12:52,559 --> 00:12:55,519
就是说在神经网络这一块

356
00:12:55,519 --> 00:12:58,159
甚至是机器学习这一块

357
00:12:58,159 --> 00:12:59,360
在1969年

358
00:12:59,360 --> 00:13:02,279
因为大家发现感知机不能理和XOR函数

359
00:13:02,279 --> 00:13:03,360
导致大家

360
00:13:05,600 --> 00:13:07,279
都去转行了

361
00:13:07,519 --> 00:13:08,159
OK

362
00:13:08,879 --> 00:13:13,960
所以到10年还是15年之后

363
00:13:14,559 --> 00:13:15,679
大家才发现

364
00:13:15,720 --> 00:13:17,919
我其实有办法来做这个事情了

365
00:13:18,200 --> 00:13:22,760
做这个事情的办法叫做多层感知机

366
00:13:25,000 --> 00:13:25,280
好

367
00:13:25,280 --> 00:13:26,280
我们先总结一下

368
00:13:26,280 --> 00:13:29,720
感知机是一个offline的模型

369
00:13:30,400 --> 00:13:33,680
就是它输出1或者0或者1或者-1

370
00:13:33,800 --> 00:13:36,680
它是最早的AI模型之一

371
00:13:37,080 --> 00:13:38,200
它的求解算法

372
00:13:38,200 --> 00:13:40,160
当时候就是感知机有自己的算法

373
00:13:40,160 --> 00:13:42,240
现在来看就是等价于一个

374
00:13:42,240 --> 00:13:44,480
毗然大笑唯一的一个梯度下降

375
00:13:44,920 --> 00:13:46,720
但是因为感知机过于简单

376
00:13:46,759 --> 00:13:48,320
它不能理和XOR函数

377
00:13:48,320 --> 00:13:50,680
导致了我们第一次AI的寒冬

378
00:13:50,960 --> 00:13:51,120
好

379
00:13:51,120 --> 00:13:52,800
这就是一个总结

