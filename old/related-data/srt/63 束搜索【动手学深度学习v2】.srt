1
00:00:00,000 --> 00:00:04,639
好,我们的最后一个topic就是叫做bin search

2
00:00:04,639 --> 00:00:07,440
或者叫做树搜索

3
00:00:07,440 --> 00:00:11,560
这个图片用的好像是某一年春运的时候搞铁

4
00:00:11,560 --> 00:00:14,759
反正有很多很多树的东西在里面

5
00:00:14,759 --> 00:00:17,559
我找了半天找了张图片出来

6
00:00:20,120 --> 00:00:21,600
就是说我们回一下

7
00:00:21,600 --> 00:00:25,080
我们在前面讲的sequence到sequence里面

8
00:00:25,080 --> 00:00:29,160
我们用的是滩星算法

9
00:00:29,879 --> 00:00:32,200
用滩星搜索来预测序列

10
00:00:32,200 --> 00:00:38,960
就是说我们将当前时刻的预测的概率最大的词输出

11
00:00:39,719 --> 00:00:40,960
作为下一个序列

12
00:00:42,399 --> 00:00:45,679
但是滩星通常不是最优的

13
00:00:45,679 --> 00:00:46,920
这里举个例子

14
00:00:47,840 --> 00:00:48,879
可以看一下这个例子

15
00:00:49,280 --> 00:00:50,240
这个例子怎么回事

16
00:00:50,359 --> 00:00:56,640
就是说假设我有三个词ABC和一个end of sentence

17
00:00:57,640 --> 00:00:59,200
时间一的时候

18
00:00:59,200 --> 00:01:01,640
假设我这是我这四个词它的预测

19
00:01:01,759 --> 00:01:02,799
就是softmax预测

20
00:01:02,840 --> 00:01:04,799
假设那么就是0.5

21
00:01:04,799 --> 00:01:05,439
0.2

22
00:01:05,439 --> 00:01:05,920
0.2

23
00:01:05,920 --> 00:01:06,319
0.1

24
00:01:06,319 --> 00:01:07,799
那么我如果滩星的话

25
00:01:07,799 --> 00:01:08,640
那我就时间一

26
00:01:08,640 --> 00:01:10,519
就是说我就输出的是A

27
00:01:10,840 --> 00:01:16,480
那就是说我说把A作为输入放作为输入放到下一个时刻二

28
00:01:18,799 --> 00:01:20,120
然后下一个时刻二

29
00:01:20,719 --> 00:01:22,840
它就会根据你的A

30
00:01:22,960 --> 00:01:23,680
因为你选了A

31
00:01:23,680 --> 00:01:25,599
所以我的东西变成了一个B

32
00:01:26,760 --> 00:01:28,640
然后我又把B选中

33
00:01:28,799 --> 00:01:29,560
因为它最大

34
00:01:29,560 --> 00:01:31,200
所以放到再下一个时刻

35
00:01:31,200 --> 00:01:32,480
下一个时刻根据你前面

36
00:01:32,480 --> 00:01:33,519
因为选了个A和B

37
00:01:33,519 --> 00:01:35,000
然后它又生成一个新的序列

38
00:01:35,000 --> 00:01:35,640
它会生

39
00:01:35,640 --> 00:01:37,920
比如说成一个分件C最大

40
00:01:38,159 --> 00:01:39,120
然后是0.4

41
00:01:39,319 --> 00:01:40,359
最后是end of sequence

42
00:01:40,359 --> 00:01:43,799
就是说你会生成一个ABC和句子结束一个序列

43
00:01:46,640 --> 00:01:48,760
但是我可以考虑一个

44
00:01:48,760 --> 00:01:50,519
我可以给你构造一个别的东西

45
00:01:50,960 --> 00:01:52,200
我构造什么呢

46
00:01:52,200 --> 00:01:58,719
假设我第一步还是这样

47
00:01:58,719 --> 00:01:59,520
我选A

48
00:01:59,840 --> 00:02:01,760
但第二步的时候不选B

49
00:02:02,079 --> 00:02:03,000
我不选最大的

50
00:02:03,000 --> 00:02:04,960
我选C

51
00:02:05,840 --> 00:02:07,560
我如果选了次大的

52
00:02:07,560 --> 00:02:10,240
然后我到第三步的时候

53
00:02:10,240 --> 00:02:11,319
第三步的结果

54
00:02:11,319 --> 00:02:12,520
因为我选了C

55
00:02:12,520 --> 00:02:13,439
我选了选了AC

56
00:02:13,439 --> 00:02:16,199
所有我的输出变了

57
00:02:16,400 --> 00:02:18,800
就我的时间线发生变更了

58
00:02:18,800 --> 00:02:19,520
就是平行宇宙

59
00:02:19,879 --> 00:02:20,439
对吧

60
00:02:20,599 --> 00:02:21,800
所以你会发现

61
00:02:21,800 --> 00:02:23,400
它可能它的预测发现是

62
00:02:23,560 --> 00:02:25,159
这个东西和第三点是不一样的

63
00:02:25,159 --> 00:02:25,599
对吧

64
00:02:25,599 --> 00:02:27,639
然后如果我再选B作为输出

65
00:02:27,639 --> 00:02:28,719
选了0.6

66
00:02:28,719 --> 00:02:30,520
然后最后这个时刻也会不变

67
00:02:30,639 --> 00:02:31,680
最后也是个0.6

68
00:02:31,840 --> 00:02:35,159
就是说根据你前面选的是A C B

69
00:02:35,159 --> 00:02:36,240
然后最后输出了

70
00:02:37,240 --> 00:02:37,639
好

71
00:02:37,639 --> 00:02:39,680
这时候你发现你选了

72
00:02:39,759 --> 00:02:40,919
你选这4个

73
00:02:40,919 --> 00:02:42,439
然后你把概率乘了

74
00:02:42,879 --> 00:02:45,560
前面这4个概率乘是0.048

75
00:02:46,079 --> 00:02:48,680
你后面第二步没有选最优

76
00:02:48,719 --> 00:02:51,680
你会发现你的概率是一个0.054

77
00:02:52,080 --> 00:02:53,200
你发现是说

78
00:02:53,240 --> 00:02:54,319
我第二步的时候

79
00:02:54,319 --> 00:02:55,319
我没有选最优

80
00:02:55,319 --> 00:02:57,280
最后生成了整个sequence的概率

81
00:02:57,280 --> 00:02:58,439
还更高一些

82
00:02:59,080 --> 00:03:04,000
这是因为说当前不选的最优的词

83
00:03:04,040 --> 00:03:06,000
不一定是在从整个句子来看

84
00:03:06,000 --> 00:03:06,680
是最优的

85
00:03:07,400 --> 00:03:08,000
OK

86
00:03:08,040 --> 00:03:09,400
所以就是说贪心搜索

87
00:03:09,400 --> 00:03:11,680
可能是效率最高的

88
00:03:11,680 --> 00:03:14,000
因为它直接过去了

89
00:03:14,000 --> 00:03:15,520
但是可能不是最优的

90
00:03:17,040 --> 00:03:18,560
那么你要想最优怎么办

91
00:03:18,719 --> 00:03:21,520
最优的话

92
00:03:21,520 --> 00:03:22,319
就是说

93
00:03:24,200 --> 00:03:25,439
你怎么做

94
00:03:25,560 --> 00:03:26,760
就是说你就是

95
00:03:26,800 --> 00:03:27,719
反过来讲

96
00:03:27,719 --> 00:03:28,840
就是说最优

97
00:03:28,840 --> 00:03:31,719
就是说我编理所有的可能的序列

98
00:03:33,000 --> 00:03:34,319
然后对每一个序列

99
00:03:35,080 --> 00:03:35,719
我就说白了

100
00:03:36,200 --> 00:03:37,680
当前我就不管预测了

101
00:03:37,680 --> 00:03:38,719
我的就是说

102
00:03:39,080 --> 00:03:41,280
我比如说我选一个取一个ABCD

103
00:03:41,640 --> 00:03:43,080
那就是说我把A放进去

104
00:03:43,080 --> 00:03:43,920
算一下A的概率

105
00:03:43,920 --> 00:03:45,640
然后再把B放进去

106
00:03:45,640 --> 00:03:46,360
算一下B的概率

107
00:03:46,360 --> 00:03:48,080
然后就是说我用我的模型

108
00:03:48,360 --> 00:03:49,840
把我用这个模型

109
00:03:49,840 --> 00:03:52,000
把ABCD这个序列

110
00:03:52,480 --> 00:03:54,000
算一下它的整个概率

111
00:03:54,000 --> 00:03:55,040
或者算一下它的

112
00:03:56,520 --> 00:03:59,560
然后我把所有的这些序列拿进去

113
00:04:00,120 --> 00:04:01,920
把所有的概率算出来

114
00:04:02,360 --> 00:04:03,800
那么最后选出最好的

115
00:04:03,800 --> 00:04:05,240
那一个一定是最优的

116
00:04:05,240 --> 00:04:06,720
是我的模型

117
00:04:06,840 --> 00:04:09,360
能够预测里面最优的

118
00:04:10,120 --> 00:04:12,120
因为我把所有的序列

119
00:04:12,120 --> 00:04:13,320
我把所有的可能序列

120
00:04:13,320 --> 00:04:15,040
都用我的模型评估一下

121
00:04:15,039 --> 00:04:18,159
那么这个东西的问题是什么

122
00:04:18,199 --> 00:04:20,279
假设你的vocab的大小是n

123
00:04:20,439 --> 00:04:21,719
你的序列长处是t

124
00:04:21,719 --> 00:04:22,839
那么你要便利

125
00:04:22,839 --> 00:04:23,879
nt个序列

126
00:04:23,879 --> 00:04:24,839
就是每一个时刻

127
00:04:24,839 --> 00:04:25,719
你就n个选择

128
00:04:25,719 --> 00:04:26,199
对吧

129
00:04:27,000 --> 00:04:29,199
m如果你n是等于1万的话

130
00:04:29,199 --> 00:04:30,240
我们刚刚就是1万

131
00:04:30,480 --> 00:04:31,279
t等于10的话

132
00:04:31,279 --> 00:04:32,360
就是刚刚我们选的10

133
00:04:32,719 --> 00:04:35,839
nt等于10的40次方

134
00:04:35,839 --> 00:04:37,120
那计算是不可能的

135
00:04:37,279 --> 00:04:37,759
对吧

136
00:04:37,759 --> 00:04:40,079
实际上40次方可能宇宙也就那么多

137
00:04:40,800 --> 00:04:42,120
宇宙有那么多原子吗

138
00:04:42,120 --> 00:04:44,439
可能就那么多原子

139
00:04:45,200 --> 00:04:46,560
所以是npcomplete

140
00:04:46,560 --> 00:04:48,080
所以穷举脱锁

141
00:04:48,319 --> 00:04:49,360
就是反正大家都知道

142
00:04:49,560 --> 00:04:50,720
学计算机的都知道

143
00:04:50,800 --> 00:04:52,439
就是贪心是最快的

144
00:04:52,439 --> 00:04:54,319
但是我法是最好的

145
00:04:54,319 --> 00:04:56,200
穷举永远是最好的

146
00:04:56,200 --> 00:04:58,240
但是通常算不动的

147
00:04:58,400 --> 00:05:00,560
所以我们要取一个中间的东西

148
00:05:02,560 --> 00:05:05,400
中间的东西叫做bin search

149
00:05:06,480 --> 00:05:07,920
这bin search是什么意思

150
00:05:08,400 --> 00:05:09,520
bin search就是说

151
00:05:09,520 --> 00:05:10,879
在每个时刻

152
00:05:11,319 --> 00:05:16,600
我保存现在k个最好的候选序列

153
00:05:18,319 --> 00:05:19,839
然后对每一个候选序列

154
00:05:22,319 --> 00:05:23,519
扫一遍下一个

155
00:05:23,519 --> 00:05:26,279
就是说下一个词

156
00:05:26,279 --> 00:05:28,040
然后是所有的vocabulary

157
00:05:28,040 --> 00:05:29,439
每一个词的序列的个数

158
00:05:29,439 --> 00:05:30,800
然后在这里面

159
00:05:30,800 --> 00:05:31,879
k一个选项中

160
00:05:31,879 --> 00:05:33,319
选出最好的k个

161
00:05:33,480 --> 00:05:34,480
我们举个具体例子

162
00:05:36,639 --> 00:05:38,159
假设我们k等于2

163
00:05:38,839 --> 00:05:39,759
我们怎么开始

164
00:05:39,879 --> 00:05:42,480
我们一开始当然是说句子开始

165
00:05:43,199 --> 00:05:44,039
句子开始

166
00:05:44,039 --> 00:05:45,560
然后我说句子开始

167
00:05:45,560 --> 00:05:48,199
我把我就可以把所有的

168
00:05:48,199 --> 00:05:48,879
反正我预测

169
00:05:48,879 --> 00:05:50,480
会把所有的东西预测出来

170
00:05:50,480 --> 00:05:50,959
对吧

171
00:05:51,920 --> 00:05:53,000
所有东西就是说

172
00:05:53,000 --> 00:05:53,800
等于是句子开始

173
00:05:53,800 --> 00:05:55,360
我softmax会输出

174
00:05:55,360 --> 00:05:57,000
下一个词所有的概率

175
00:05:57,839 --> 00:05:59,480
之前我们贪心是选最好的

176
00:05:59,480 --> 00:06:01,159
现在我们说我选两个

177
00:06:01,519 --> 00:06:03,839
假设ac是当前最好的

178
00:06:04,680 --> 00:06:07,920
那么下一个时刻

179
00:06:08,319 --> 00:06:11,080
我会做两次预测

180
00:06:11,480 --> 00:06:12,960
我的batch size变成2了

181
00:06:13,720 --> 00:06:16,080
你第一个就是你的a这个句子

182
00:06:16,080 --> 00:06:17,680
就是说开始到a

183
00:06:17,680 --> 00:06:19,360
第二个就是开始到c

184
00:06:19,360 --> 00:06:20,360
就这两个

185
00:06:20,360 --> 00:06:23,200
然后每一个我会去看一下

186
00:06:23,680 --> 00:06:25,000
每一个就是它的输出

187
00:06:25,000 --> 00:06:25,360
对吧

188
00:06:26,439 --> 00:06:27,560
然后你输出的话

189
00:06:27,720 --> 00:06:29,040
这里面一共就有

190
00:06:30,560 --> 00:06:33,080
你现在是有10个这样子输出

191
00:06:33,080 --> 00:06:34,040
然后在这里面

192
00:06:34,240 --> 00:06:35,960
所以这里面我选出

193
00:06:36,639 --> 00:06:37,280
最好的两个

194
00:06:37,440 --> 00:06:39,200
就是把所有这些东西放在一起

195
00:06:39,480 --> 00:06:41,600
然后选出概率最高的那两个

196
00:06:43,320 --> 00:06:44,120
等于是说

197
00:06:44,120 --> 00:06:46,240
你当前的softmax的输出

198
00:06:46,240 --> 00:06:47,520
乘以你这个序列

199
00:06:47,520 --> 00:06:49,480
整个序列的前面的概率

200
00:06:49,720 --> 00:06:50,720
乘起来比一下

201
00:06:51,720 --> 00:06:52,960
选中了b和e

202
00:06:54,640 --> 00:06:55,240
Ok

203
00:06:55,440 --> 00:06:57,680
这时候最好的两个序列是谁

204
00:06:57,840 --> 00:06:59,160
就是ab和ce

205
00:06:59,360 --> 00:07:02,880
这是我们当前到时间

206
00:07:03,320 --> 00:07:04,680
e完成的时候

207
00:07:04,680 --> 00:07:06,960
我们觉得最好的两个序列

208
00:07:07,600 --> 00:07:08,960
这是时间二完成之后

209
00:07:08,960 --> 00:07:11,920
我们当前最好的两个是ab和ce

210
00:07:12,560 --> 00:07:15,280
那么我们接下来选

211
00:07:15,880 --> 00:07:16,640
对每个序列

212
00:07:16,720 --> 00:07:18,320
这两个序列同样一样的

213
00:07:18,320 --> 00:07:20,080
我会再往下预测一次

214
00:07:20,080 --> 00:07:23,560
然后把中间最好的两个又存下来

215
00:07:23,560 --> 00:07:24,760
最后就是说

216
00:07:25,120 --> 00:07:25,760
完成的时候

217
00:07:25,760 --> 00:07:28,760
就是abd和ced

218
00:07:30,720 --> 00:07:31,280
Ok

219
00:07:31,320 --> 00:07:33,480
所以就是说之前我们在

220
00:07:33,920 --> 00:07:35,240
我们在探信的时候

221
00:07:35,319 --> 00:07:37,000
我们做的是

222
00:07:37,000 --> 00:07:39,240
每一个是只有一个最好的候选

223
00:07:39,360 --> 00:07:41,519
现在我们去k是可以选的

224
00:07:42,199 --> 00:07:44,000
我们看一下复杂度

225
00:07:45,160 --> 00:07:48,079
它的时间复杂度是knt

226
00:07:48,920 --> 00:07:51,000
因为对每一个时刻t

227
00:07:51,680 --> 00:07:54,280
你需要做kn次搜索

228
00:07:55,800 --> 00:07:57,840
这个东西其实不错

229
00:07:58,040 --> 00:07:59,800
就是说k是等于5

230
00:08:00,360 --> 00:08:01,319
比如k等于5

231
00:08:01,439 --> 00:08:02,720
n还是以前的10万

232
00:08:02,720 --> 00:08:04,400
然后是1万

233
00:08:04,720 --> 00:08:05,600
t等于10的话

234
00:08:06,240 --> 00:08:08,320
knt5就是5乘以10的5次方

235
00:08:08,440 --> 00:08:10,200
基本上就可以实时可以做了

236
00:08:10,200 --> 00:08:11,640
就是基本上复杂度很低

237
00:08:13,680 --> 00:08:15,560
最后我们假设我们选

238
00:08:16,920 --> 00:08:17,600
你会发现说

239
00:08:17,600 --> 00:08:19,600
最后我们会选出来很多

240
00:08:19,800 --> 00:08:20,600
很多这样子

241
00:08:20,600 --> 00:08:23,520
我们可能最后不仅仅是用最后的k个选择

242
00:08:23,520 --> 00:08:26,280
我们可以把过去那些子序列

243
00:08:26,440 --> 00:08:27,840
全部可以存下都可以

244
00:08:28,080 --> 00:08:29,520
最后我们会怎么算

245
00:08:29,960 --> 00:08:34,519
就是说我们要算它的概率的时候

246
00:08:34,519 --> 00:08:35,440
我们发现说

247
00:08:35,600 --> 00:08:37,240
长句子的概率

248
00:08:37,840 --> 00:08:40,400
因为是乘起来

249
00:08:40,400 --> 00:08:41,000
或者加起来

250
00:08:41,000 --> 00:08:42,080
取log是加起来

251
00:08:42,080 --> 00:08:43,080
就是说句子越长

252
00:08:43,080 --> 00:08:44,280
你的概率越低

253
00:08:44,519 --> 00:08:45,040
对吧

254
00:08:45,800 --> 00:08:48,360
因为你一个句子的概率远远没有

255
00:08:48,360 --> 00:08:52,240
总是比一个子句子的概率要低那么一点点

256
00:08:52,840 --> 00:08:55,080
因为你的后面都是概率都是小于1

257
00:08:55,200 --> 00:08:56,920
你连乘起来就变小了

258
00:08:57,479 --> 00:08:59,599
所以你就是说你如果候选的时候

259
00:08:59,599 --> 00:09:01,079
他你如果这样子的话

260
00:09:01,079 --> 00:09:02,679
你总会去选那些短句子

261
00:09:03,199 --> 00:09:05,799
所以你一般是bin search里面搜索

262
00:09:05,799 --> 00:09:07,719
就是说他会把这个句子

263
00:09:07,799 --> 00:09:09,639
这是整个句子概率

264
00:09:09,799 --> 00:09:10,399
就是说

265
00:09:11,159 --> 00:09:14,319
就每一次softmax就是每次softmax输出

266
00:09:14,439 --> 00:09:16,599
把概率一乘起来取个log

267
00:09:17,120 --> 00:09:21,039
所以你最后他会乘一个l是你的长度

268
00:09:21,039 --> 00:09:22,480
他会做一个alpha

269
00:09:22,679 --> 00:09:24,240
比如说l的0.75

270
00:09:24,480 --> 00:09:25,919
这样的好处是说

271
00:09:26,680 --> 00:09:27,879
假设你的

272
00:09:31,600 --> 00:09:33,440
取log之后就会变成一个负数

273
00:09:33,519 --> 00:09:35,039
这是一个变负数的东西

274
00:09:35,080 --> 00:09:38,480
所以这个东西就是说让你的长的句子

275
00:09:39,960 --> 00:09:42,279
把你的就是说把你的负数变小一点

276
00:09:42,279 --> 00:09:45,360
等于就是说对长句子给你一点点好处

277
00:09:46,039 --> 00:09:48,120
就不然的话你总是选的短句子

278
00:09:48,279 --> 00:09:48,600
OK

279
00:09:48,600 --> 00:09:51,000
这也是一个有点像有点像blue

280
00:09:51,799 --> 00:09:55,120
就是说当你在比较n个不同长度的东西的时候

281
00:09:55,120 --> 00:09:56,399
你怎么选一个

282
00:09:56,399 --> 00:09:57,600
不要总是选最小的

283
00:09:57,600 --> 00:09:59,519
要选一个你可能是长一点的

284
00:09:59,519 --> 00:10:00,879
可能效果还更好一点

285
00:10:01,240 --> 00:10:02,879
这就是bin search的选择

286
00:10:04,879 --> 00:10:06,799
然后就是说总结一下就是说

287
00:10:07,200 --> 00:10:10,080
bin search就是在每次搜索的时候

288
00:10:10,360 --> 00:10:12,840
保存k个最好的候选

289
00:10:13,960 --> 00:10:16,000
我们看到是k等于的时候

290
00:10:16,000 --> 00:10:17,320
k等于就是贪心

291
00:10:17,519 --> 00:10:20,360
就总是把当前最好的结果

292
00:10:20,360 --> 00:10:22,720
就每一步就看最好的东西一直下去

293
00:10:23,399 --> 00:10:25,440
k的n的时候就是重举

294
00:10:25,440 --> 00:10:28,399
就是把所有东西都存下来

295
00:10:29,960 --> 00:10:30,919
然后

296
00:10:32,720 --> 00:10:34,159
k的n其实不是重举

297
00:10:34,240 --> 00:10:34,840
所以写错了

298
00:10:34,840 --> 00:10:35,919
k的n不是重举

299
00:10:35,919 --> 00:10:38,200
k的n其实也不是

300
00:10:39,279 --> 00:10:40,800
那还行

301
00:10:40,800 --> 00:10:41,440
可以

302
00:10:41,879 --> 00:10:42,560
这个我写错了

303
00:10:42,560 --> 00:10:44,800
重举是一个更复杂的一个case

304
00:10:44,960 --> 00:10:46,360
所以通常来说

305
00:10:46,360 --> 00:10:49,039
bin search一般k会去5或者10

306
00:10:49,199 --> 00:10:51,279
就是说通常说k取得越高

307
00:10:51,279 --> 00:10:52,480
当然是说你的

308
00:10:53,120 --> 00:10:56,000
你可以在更多的候选里面选一个更好的

309
00:10:56,000 --> 00:10:56,480
但是

310
00:10:58,319 --> 00:10:58,799
越大

311
00:10:58,799 --> 00:11:01,039
你的实施的效果可能就越差

312
00:11:01,039 --> 00:11:03,679
就是说你可能说翻译或者是语音

313
00:11:03,839 --> 00:11:04,879
这个东西的时候

314
00:11:05,159 --> 00:11:07,199
语音的也是语音就是一个

315
00:11:07,839 --> 00:11:08,599
你这么说起来

316
00:11:08,599 --> 00:11:11,439
我突然想到刚刚那个问题

317
00:11:15,639 --> 00:11:16,240
OK

318
00:11:20,000 --> 00:11:20,319
对

319
00:11:20,319 --> 00:11:21,399
就是语音的时候

320
00:11:21,399 --> 00:11:23,879
你比如说你要实施的翻译的时候

321
00:11:23,919 --> 00:11:24,919
你那就是

322
00:11:25,759 --> 00:11:27,480
k可能你不能取代的

323
00:11:27,480 --> 00:11:31,000
因为这样子都说我在实施演讲的时候

324
00:11:31,000 --> 00:11:32,679
你下面字幕弹的

325
00:11:32,839 --> 00:11:35,360
发现慢个几秒钟就不行了

326
00:11:35,360 --> 00:11:36,439
所以你为了实施性

327
00:11:36,439 --> 00:11:38,399
你可能把k取得小一点点

328
00:11:38,839 --> 00:11:39,399
OK

329
00:11:39,439 --> 00:11:42,159
所以这就是bin search

