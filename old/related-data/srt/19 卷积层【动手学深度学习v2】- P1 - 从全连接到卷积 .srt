1
00:00:00,000 --> 00:00:04,120
开始了我们真正的卷积

2
00:00:04,120 --> 00:00:11,000
卷积是整个深度学习里面最重要的概念之一

3
00:00:11,000 --> 00:00:17,120
我们今天就讲一下卷积的一些基本的知识

4
00:00:17,120 --> 00:00:23,600
我们从一个简单的例子出发

5
00:00:23,600 --> 00:00:26,920
假设我们做一个很简单的图片分类问题

6
00:00:27,840 --> 00:00:30,120
我们分类猫和狗

7
00:00:31,400 --> 00:00:33,840
假设我们是用手机拍照片了

8
00:00:34,400 --> 00:00:38,439
我们手机现在一般手机至少你大概有1000万像素

9
00:00:38,439 --> 00:00:39,359
1200万像素

10
00:00:39,359 --> 00:00:43,079
这是还是三年前的手机

11
00:00:43,079 --> 00:00:44,920
现在手机上亿像素都有

12
00:00:46,200 --> 00:00:50,120
假设你用手机拍了一个1200万像素的图片

13
00:00:50,719 --> 00:00:52,439
而且你是RGB图片的话

14
00:00:52,439 --> 00:00:54,560
你有RGB三个channel

15
00:00:55,000 --> 00:00:58,600
那就是说你有3600万个元素

16
00:00:59,400 --> 00:01:01,440
就每个像素有个值

17
00:01:03,359 --> 00:01:07,520
假设我用一个单隐藏层的MLP来训练

18
00:01:07,520 --> 00:01:10,680
然后这个隐藏层大小是100的话

19
00:01:10,680 --> 00:01:14,240
那么这个模型有36亿个元素

20
00:01:14,240 --> 00:01:15,320
这整个模型的参数

21
00:01:16,920 --> 00:01:22,159
这个东西远远的多于世界上所有的猫和狗的种数

22
00:01:22,200 --> 00:01:24,280
狗大概就是9亿只

23
00:01:24,280 --> 00:01:26,239
猫大概是6亿只

24
00:01:26,239 --> 00:01:28,359
所以当然肯定就不对嘛

25
00:01:28,359 --> 00:01:34,759
如果这个世界上的猫和狗才那么15亿只的话

26
00:01:34,759 --> 00:01:37,239
你整个模型有36亿个元素

27
00:01:37,239 --> 00:01:40,719
那我还不如把所有的猫和狗给你记住了

28
00:01:41,799 --> 00:01:46,519
所以当你用MLP来处理图片的时候会遇到这个问题

29
00:01:46,519 --> 00:01:48,400
特别是比较大的图片的时候

30
00:01:48,400 --> 00:01:51,039
这个就会让我们去想说怎么样解决这个问题

31
00:01:53,159 --> 00:01:55,719
我们来看一下就是MLP

32
00:01:55,719 --> 00:01:58,759
我们刚刚是讲了这个东西

33
00:01:58,759 --> 00:02:08,079
就是说你的输入就是有3600万个元素

34
00:02:08,079 --> 00:02:10,599
然后你的Hinder Size是100

35
00:02:10,599 --> 00:02:14,759
那么你的全重就是100×3600万

36
00:02:14,759 --> 00:02:17,280
那就是36亿

37
00:02:17,280 --> 00:02:18,240
36亿的话

38
00:02:18,240 --> 00:02:21,800
你要存下来的话大概是14个GB

39
00:02:21,840 --> 00:02:25,880
然后你基本上你的有很好的GPU才能存下来

40
00:02:25,880 --> 00:02:27,040
那肯定不对嘛

41
00:02:27,040 --> 00:02:30,719
就是我用单层就会要14GB的内存

42
00:02:30,719 --> 00:02:33,160
还不算去做运算

43
00:02:33,160 --> 00:02:35,000
那我怎么做多层那就做不了了

44
00:02:39,280 --> 00:02:40,720
好我们来看一下说

45
00:02:41,640 --> 00:02:42,880
图片我们要干嘛

46
00:02:42,880 --> 00:02:44,320
就是说整个图片

47
00:02:44,320 --> 00:02:46,560
我们是跟之前有什么不一样的地方

48
00:02:47,600 --> 00:02:49,320
我们看一个简单的例子

49
00:02:49,359 --> 00:02:53,359
就是说这个是一个应该是德国比较流行的一个游戏

50
00:02:54,280 --> 00:02:57,359
就是说在一个小孩子的一本书里面

51
00:02:57,359 --> 00:02:59,079
给小孩子说

52
00:02:59,079 --> 00:03:00,079
Word在哪里

53
00:03:00,079 --> 00:03:01,639
Word就是这个人

54
00:03:01,639 --> 00:03:03,840
这个人就是叫Word

55
00:03:03,840 --> 00:03:06,400
然后他就会在图片里面画很多东西

56
00:03:06,400 --> 00:03:08,159
然后Word藏在里面

57
00:03:08,159 --> 00:03:09,759
然后让小朋友去找这个东西

58
00:03:11,359 --> 00:03:12,000
所以那就是说

59
00:03:12,000 --> 00:03:14,919
比如说我在这个图片里面把Word找出来

60
00:03:14,919 --> 00:03:16,199
很容易找对吧

61
00:03:16,199 --> 00:03:17,719
你有很多很多

62
00:03:17,719 --> 00:03:19,599
所以给大家讲一下说

63
00:03:19,599 --> 00:03:21,400
我们找的话有两个原则

64
00:03:21,400 --> 00:03:22,000
你可以认为

65
00:03:23,039 --> 00:03:24,400
一个是说

66
00:03:24,400 --> 00:03:27,560
你假设你Word出现在这个地方

67
00:03:27,560 --> 00:03:29,120
长这个样子

68
00:03:29,120 --> 00:03:30,800
你假设出现在别的地方的话

69
00:03:30,800 --> 00:03:32,919
也应该是差不多的

70
00:03:32,919 --> 00:03:36,280
就是说我有一个分类器去在这个地方看

71
00:03:36,280 --> 00:03:38,479
我这个Word长在这个地方

72
00:03:38,479 --> 00:03:42,000
那么我同样的分类器可以用在一个别的地方

73
00:03:43,000 --> 00:03:48,159
不能说我在这个地方的分类器找Word的那个pattern

74
00:03:48,159 --> 00:03:49,280
是这样子的

75
00:03:49,280 --> 00:03:50,599
换一个地方就不一样了

76
00:03:50,599 --> 00:03:51,439
那应该是不行的

77
00:03:51,439 --> 00:03:53,560
应该是说在图片任何地方

78
00:03:53,560 --> 00:03:55,199
我能够识别一个东西

79
00:03:55,199 --> 00:03:58,240
这个识别器应该是不会要发生

80
00:03:58,240 --> 00:04:01,800
不会因你的图片像素出现的位置而进行改变

81
00:04:01,800 --> 00:04:05,000
这我们可以认为叫做平移不变性

82
00:04:06,879 --> 00:04:08,560
第二个叫做局部性

83
00:04:08,560 --> 00:04:09,840
就我要找你这个东西

84
00:04:09,840 --> 00:04:11,800
那么我其实不用看太远

85
00:04:11,800 --> 00:04:13,240
我就要看这一块就行了

86
00:04:13,240 --> 00:04:14,960
我不需要看那么远的地方

87
00:04:15,200 --> 00:04:17,079
就是说我只要看局部的信息就行了

88
00:04:17,079 --> 00:04:18,720
我不需要看到全局的信息

89
00:04:19,360 --> 00:04:22,160
所以说这两个原则

90
00:04:22,199 --> 00:04:26,560
就是说在图片里面找模式的原则

91
00:04:26,680 --> 00:04:29,639
可以启发了我们之后的整个的设计

92
00:04:30,960 --> 00:04:31,600
OK

93
00:04:32,439 --> 00:04:33,000
好

94
00:04:33,000 --> 00:04:34,840
我们接下来就来看说

95
00:04:36,080 --> 00:04:38,720
怎么样从全连接程出发

96
00:04:39,240 --> 00:04:41,960
应用这两个原则得到卷迹

97
00:04:42,800 --> 00:04:44,560
这就是我们之前说的卷迹

98
00:04:44,560 --> 00:04:46,640
就是一个特殊的全连接程

99
00:04:47,280 --> 00:04:47,520
好

100
00:04:47,520 --> 00:04:49,160
我们来看一下我们这个怎么做的

101
00:04:50,040 --> 00:04:51,680
首先我们全连接程

102
00:04:51,680 --> 00:04:54,880
我们之前是虽然一个图片是有一个高和宽

103
00:04:54,880 --> 00:04:55,520
是一个矩阵

104
00:04:55,520 --> 00:04:59,440
我们是把它做成一个一维的向量了

105
00:05:01,200 --> 00:05:02,880
现在我们还是还原成一个矩阵

106
00:05:02,880 --> 00:05:05,840
因为我们要考虑你的空间的一些信息

107
00:05:05,880 --> 00:05:07,360
你必须要用矩阵来存

108
00:05:07,759 --> 00:05:10,319
所以假设我们这个地方将我们的输入和

109
00:05:10,319 --> 00:05:12,560
输出从向量变成一个矩阵

110
00:05:12,720 --> 00:05:15,280
那么这个矩阵有宽度和高度的两个维度

111
00:05:17,160 --> 00:05:19,759
那么我们对应的可以把我们的权重变成

112
00:05:19,759 --> 00:05:21,920
一个四维的张量

113
00:05:22,439 --> 00:05:24,480
就之前是一个输入的

114
00:05:25,000 --> 00:05:27,520
长度到一个输出的长度变化

115
00:05:27,720 --> 00:05:31,879
现在是变一个输入的高宽到输出的高宽的

116
00:05:31,879 --> 00:05:32,319
一个变化

117
00:05:32,319 --> 00:05:35,439
所以它可以把它reshape成一个4D的一个

118
00:05:35,439 --> 00:05:35,920
张量

119
00:05:37,360 --> 00:05:39,680
然后我们可以写下来就是这样子

120
00:05:40,080 --> 00:05:42,400
Hij就是我们的输出了

121
00:05:42,560 --> 00:05:45,040
现在我们之前是就是Hi对吧

122
00:05:45,040 --> 00:05:46,360
我们现在把它变成一个矩阵

123
00:05:46,360 --> 00:05:48,080
就要两个维度叫ij

124
00:05:49,680 --> 00:05:51,040
X是我们的输入

125
00:05:51,360 --> 00:05:53,040
同样的我们变成了矩阵之后

126
00:05:53,040 --> 00:05:54,920
我们有个K和L这个选项

127
00:05:56,199 --> 00:05:59,639
那么我们W就是我们之前的全连接程

128
00:05:59,639 --> 00:06:00,920
那个权重

129
00:06:00,920 --> 00:06:02,960
我们之前是一个二维的东西

130
00:06:02,960 --> 00:06:04,160
我们变成了一个四维

131
00:06:04,760 --> 00:06:07,520
我们知道我们的得到一个输出的值

132
00:06:07,520 --> 00:06:09,760
就是你矩阵的一行

133
00:06:10,200 --> 00:06:12,240
乘以你输入的那个向量

134
00:06:13,280 --> 00:06:14,560
现在我们变矩阵了

135
00:06:14,560 --> 00:06:16,360
其实就是我们的求和的

136
00:06:16,360 --> 00:06:18,560
是有个K和L这两个坐标了

137
00:06:19,080 --> 00:06:22,000
可以看到我们就K在这个地方

138
00:06:22,480 --> 00:06:23,560
L在这个地方

139
00:06:23,840 --> 00:06:25,879
就是说我们变你两个维度

140
00:06:25,879 --> 00:06:26,760
然后做求和

141
00:06:28,200 --> 00:06:28,480
对吧

142
00:06:28,480 --> 00:06:31,200
这个是等价于我们之前二维的一个输出

143
00:06:31,400 --> 00:06:32,080
就二维的话

144
00:06:32,079 --> 00:06:34,399
就是一个W比如说i的一撇

145
00:06:36,279 --> 00:06:38,599
j的一撇乘以x

146
00:06:39,000 --> 00:06:39,680
j的一撇

147
00:06:40,159 --> 00:06:42,359
然后对j一撇求和

148
00:06:42,359 --> 00:06:43,479
这个是二维的情况

149
00:06:43,479 --> 00:06:46,360
我们就是把i一撇分裂成了ij

150
00:06:46,680 --> 00:06:48,039
j一撇分裂成了KL

151
00:06:48,039 --> 00:06:50,199
就是一个轴的一个分裂

152
00:06:51,799 --> 00:06:51,919
好

153
00:06:51,919 --> 00:06:53,399
我们写成这个形式之后

154
00:06:53,680 --> 00:06:56,039
我们接下来做一个重新的对

155
00:06:56,560 --> 00:06:57,919
W做一个重新索引

156
00:06:58,199 --> 00:07:01,799
就是把W一些元素重新排列一下

157
00:07:02,079 --> 00:07:03,120
做到一个V上面

158
00:07:04,000 --> 00:07:05,719
然后我们的索引是说

159
00:07:05,719 --> 00:07:11,199
使得Vijab等于Wij

160
00:07:11,759 --> 00:07:12,639
i加上a

161
00:07:12,639 --> 00:07:13,439
j加上b

162
00:07:15,039 --> 00:07:16,879
所以你如果是这样的话

163
00:07:16,879 --> 00:07:18,439
那么我这个元素

164
00:07:18,439 --> 00:07:19,799
就是说我把这个元素

165
00:07:20,399 --> 00:07:21,919
写成这个样子的话

166
00:07:21,919 --> 00:07:25,240
那么它对应的要对x做一些变化

167
00:07:26,279 --> 00:07:29,279
就是说你看到是说xij

168
00:07:29,280 --> 00:07:33,120
本来是要对应的W的i加上a

169
00:07:33,120 --> 00:07:33,600
对吧

170
00:07:33,600 --> 00:07:35,600
和j加上b

171
00:07:36,560 --> 00:07:39,360
但是因为我们做了变化

172
00:07:39,360 --> 00:07:40,160
我们做了变化

173
00:07:40,160 --> 00:07:42,320
所以i加上a就变成了a

174
00:07:42,680 --> 00:07:43,480
就V的a

175
00:07:44,120 --> 00:07:45,200
然后j加上b

176
00:07:46,200 --> 00:07:50,600
接上b就变成了V的b

177
00:07:51,800 --> 00:07:56,000
就是说我们可以对W做重新的索引

178
00:07:56,480 --> 00:07:59,080
使得我可以把下标稍微变换一下

179
00:07:59,079 --> 00:08:02,120
这样子能够引出我们卷积是怎么做的

180
00:08:03,120 --> 00:08:03,639
OK

181
00:08:03,639 --> 00:08:04,839
这个还是全连接程

182
00:08:05,199 --> 00:08:07,279
我们就是说把全连接重新写一下

183
00:08:07,279 --> 00:08:09,519
做成一个二维的输入输出

184
00:08:09,519 --> 00:08:11,800
然后把下标做一些变化

185
00:08:14,439 --> 00:08:14,839
好

186
00:08:14,839 --> 00:08:15,879
我们接下来看一下

187
00:08:15,879 --> 00:08:17,399
我们用第一个原则

188
00:08:18,120 --> 00:08:19,319
平移不变形

189
00:08:21,039 --> 00:08:22,639
就我们看一下现在有什么问题

190
00:08:23,759 --> 00:08:24,759
现在是说

191
00:08:24,759 --> 00:08:27,199
我的在输入的平移

192
00:08:27,479 --> 00:08:29,360
会导致你h的平移

193
00:08:30,519 --> 00:08:31,039
就举个例子

194
00:08:33,319 --> 00:08:33,919
就是说

195
00:08:34,639 --> 00:08:37,720
我的hij是等于我这样子算出来

196
00:08:37,720 --> 00:08:38,120
对吧

197
00:08:39,679 --> 00:08:41,480
那么我如果在

198
00:08:43,360 --> 00:08:46,759
我一个东西在x平移了一点点的话

199
00:08:46,759 --> 00:08:48,039
换了一个新的坐标的话

200
00:08:48,039 --> 00:08:49,879
那么它对应算它的时候

201
00:08:49,879 --> 00:08:51,919
那个vijab

202
00:08:52,960 --> 00:08:54,279
它也会发生了变化

203
00:08:54,279 --> 00:08:56,080
就是这个是我们的权重

204
00:08:56,240 --> 00:08:59,440
这就是我们来识别我们图片的一些

205
00:08:59,440 --> 00:09:00,520
我们的识别器

206
00:09:02,560 --> 00:09:03,360
现在是说

207
00:09:03,360 --> 00:09:05,440
假设我x的位置变换

208
00:09:06,120 --> 00:09:07,120
i和

209
00:09:08,840 --> 00:09:11,400
这个东西变换的话

210
00:09:11,400 --> 00:09:15,200
那么整个这个东西也会发生变化

211
00:09:16,960 --> 00:09:17,960
所以我的想法是说

212
00:09:17,960 --> 00:09:21,200
你的i阶变换就不应该会引起

213
00:09:21,200 --> 00:09:23,160
你这个v发生了变化

214
00:09:24,159 --> 00:09:25,439
意味着是说

215
00:09:25,439 --> 00:09:27,679
我不管你的i阶是什么样子

216
00:09:27,679 --> 00:09:29,439
不管你的数字在变

217
00:09:29,439 --> 00:09:30,399
i阶怎么变

218
00:09:30,399 --> 00:09:32,679
那么我的v应该是要不变的

219
00:09:34,559 --> 00:09:36,360
那就是说我的解决方案是说

220
00:09:36,360 --> 00:09:38,039
我加一个限制

221
00:09:38,039 --> 00:09:42,159
使得vijab它等于vab

222
00:09:42,159 --> 00:09:43,679
就是说你不管

223
00:09:43,679 --> 00:09:46,639
就等于是说你前面两个维度

224
00:09:47,199 --> 00:09:50,159
基本上就是全部是不变的

225
00:09:50,159 --> 00:09:51,120
就是一些常数

226
00:09:51,759 --> 00:09:54,240
就是说我把前两个维度抹掉

227
00:09:55,080 --> 00:09:56,159
这样指的话

228
00:09:56,159 --> 00:10:00,000
我的hij就是它等于vab

229
00:10:00,000 --> 00:10:02,000
乘以xi加a

230
00:10:02,000 --> 00:10:03,279
j加b

231
00:10:03,279 --> 00:10:04,879
就不管i阶怎么变化

232
00:10:05,039 --> 00:10:05,759
我的输出

233
00:10:05,759 --> 00:10:06,799
就是说我的输出

234
00:10:06,799 --> 00:10:07,799
我的输出的位置

235
00:10:07,799 --> 00:10:08,960
怎么样挪到这个地方

236
00:10:08,960 --> 00:10:10,240
挪到那个地方

237
00:10:10,240 --> 00:10:11,960
那么不管挪到哪里

238
00:10:11,960 --> 00:10:14,720
我去看的那个模式

239
00:10:14,720 --> 00:10:16,960
我那个识别器还是不变的

240
00:10:16,960 --> 00:10:19,680
就是vab是不会发生变化的

241
00:10:22,120 --> 00:10:24,840
所以这个就叫做

242
00:10:25,120 --> 00:10:26,840
我们一般叫二维卷迹

243
00:10:27,879 --> 00:10:31,840
但是这就是一个误会

244
00:10:32,080 --> 00:10:33,519
其实在严格上来说

245
00:10:33,519 --> 00:10:34,440
在数学上来说

246
00:10:34,440 --> 00:10:37,480
这个东西叫做二维的交叉相关

247
00:10:37,919 --> 00:10:41,799
这就是说看到我的i阶输入

248
00:10:41,799 --> 00:10:43,799
就是我输出里面的像素

249
00:10:43,799 --> 00:10:45,680
是等于我的输入的

250
00:10:45,680 --> 00:10:49,200
i阶的对应的像素

251
00:10:49,200 --> 00:10:52,600
它在于在它以它为中心做

252
00:10:52,600 --> 00:10:54,759
不断做offset的时候

253
00:10:54,759 --> 00:10:55,720
加一点减一点

254
00:10:55,720 --> 00:10:57,160
就我们边上挪的时候

255
00:10:57,160 --> 00:11:01,400
和它的模式做一个累积

256
00:11:01,640 --> 00:11:03,000
就是一个这样子的关系

257
00:11:03,280 --> 00:11:04,440
我们之后再来

258
00:11:04,840 --> 00:11:06,920
更详细演示一下这个东西的效果

259
00:11:07,200 --> 00:11:08,200
所以就是说

260
00:11:08,440 --> 00:11:09,440
第一原则

261
00:11:09,560 --> 00:11:10,640
平易不变性

262
00:11:10,640 --> 00:11:14,160
使得我们对于我们的权衡做了限制

263
00:11:14,520 --> 00:11:17,000
然后我们把i阶这个维度干掉了

264
00:11:17,240 --> 00:11:18,960
就只剩以ab这个维度

265
00:11:19,680 --> 00:11:20,240
Ok

266
00:11:20,240 --> 00:11:23,160
然后这就直接得到了我们的二维卷积

267
00:11:23,160 --> 00:11:25,759
或者交叉相关的一个计算

268
00:11:25,920 --> 00:11:28,640
所以你现在可以认为是说二维卷积

269
00:11:28,640 --> 00:11:30,360
就是我的权连接

270
00:11:30,360 --> 00:11:31,759
或者说一个局段乘法

271
00:11:31,759 --> 00:11:33,000
但是我的权重

272
00:11:33,000 --> 00:11:36,400
使得它的一些东西是重复的

273
00:11:37,520 --> 00:11:40,640
就它不是每一个元素都可以自由变化

274
00:11:41,200 --> 00:11:42,320
我们要知道说

275
00:11:42,320 --> 00:11:44,800
当我把一个模型的取值的范围

276
00:11:44,800 --> 00:11:45,800
做了限制的话

277
00:11:45,800 --> 00:11:47,840
我就把模型的复杂度降低了

278
00:11:49,200 --> 00:11:50,120
同样的话

279
00:11:50,160 --> 00:11:52,040
也就意味着是说

280
00:11:52,040 --> 00:11:53,680
我不要存那么多元素了

281
00:11:54,759 --> 00:11:56,480
我们来看一下第二个

282
00:11:57,120 --> 00:11:58,200
原则是什么样子

283
00:11:59,360 --> 00:12:01,040
第二个原则叫做局部性

284
00:12:01,879 --> 00:12:03,480
局部性的意思是说

285
00:12:03,800 --> 00:12:08,080
假设我要去算i j这个输出的话

286
00:12:08,840 --> 00:12:11,600
我去我现在会去看所有

287
00:12:11,600 --> 00:12:14,640
i j就a可以任意变换

288
00:12:14,640 --> 00:12:16,440
就是说以它为i j为中心

289
00:12:16,440 --> 00:12:18,280
你的输入和任所有的地方

290
00:12:18,280 --> 00:12:19,040
我都会去看

291
00:12:19,600 --> 00:12:20,840
但实际上来说

292
00:12:20,840 --> 00:12:23,840
我们就不应该去看那么远的地方

293
00:12:24,800 --> 00:12:26,200
i和j的结果

294
00:12:26,200 --> 00:12:30,480
只应该有x ij输入附近的那些点就行了

295
00:12:34,160 --> 00:12:34,759
就是说

296
00:12:35,960 --> 00:12:37,120
我们可以做一些限制

297
00:12:38,240 --> 00:12:39,520
我们的解决方案是说

298
00:12:39,520 --> 00:12:41,400
当你的a的绝对值

299
00:12:41,400 --> 00:12:42,640
或者b的绝对值

300
00:12:42,640 --> 00:12:44,440
大于一个delta的时候

301
00:12:45,520 --> 00:12:47,840
我们就使得v ab等于0

302
00:12:48,560 --> 00:12:52,480
就是说我在i和j那个点远离

303
00:12:52,480 --> 00:12:55,120
我超过delta的位置的时候

304
00:12:55,120 --> 00:12:56,560
那些地方我就不再去看了

305
00:12:58,240 --> 00:12:59,879
所以你这么写下来就等于是说

306
00:13:00,560 --> 00:13:01,720
等于我要做

307
00:13:02,440 --> 00:13:03,519
求和的时候

308
00:13:03,519 --> 00:13:07,360
对于i我只会对于a

309
00:13:07,360 --> 00:13:09,320
从负delta到delta进行变化

310
00:13:10,360 --> 00:13:13,240
就是宽度这个维度上

311
00:13:13,240 --> 00:13:16,800
我只要当切点往前去

312
00:13:17,080 --> 00:13:18,360
delta和往后去delta

313
00:13:20,000 --> 00:13:21,320
我可以写一下的话

314
00:13:21,320 --> 00:13:21,920
就是说

315
00:13:22,480 --> 00:13:24,280
我的我写在这个地方

316
00:13:26,480 --> 00:13:27,600
假设是x的话

317
00:13:28,120 --> 00:13:29,640
我说i和j的话

318
00:13:29,640 --> 00:13:34,640
那么我就应该只去看它附近那一个delta的

319
00:13:34,640 --> 00:13:36,640
这是一个delta

320
00:13:36,640 --> 00:13:38,320
这是一个delta的附近

321
00:13:38,320 --> 00:13:42,680
会得到我的输出h ij

322
00:13:43,680 --> 00:13:45,280
就是说我就意味着

323
00:13:45,280 --> 00:13:48,680
我只去看这一块的区域

324
00:13:48,680 --> 00:13:49,680
这就是局部性

325
00:13:54,080 --> 00:13:56,120
所以这个就是说白了

326
00:13:56,120 --> 00:13:57,200
就是我们的卷积了

327
00:13:58,360 --> 00:13:59,400
所以总结一下

328
00:14:02,680 --> 00:14:03,240
总结一下

329
00:14:03,240 --> 00:14:08,120
就是说对全联阶层使用

330
00:14:08,520 --> 00:14:10,920
平移不变性和局部性

331
00:14:11,040 --> 00:14:12,920
就会得到我们的卷积层

332
00:14:14,640 --> 00:14:18,320
所以为什么说卷积是一个特殊的全联阶层

333
00:14:19,120 --> 00:14:19,920
它的做法是说

334
00:14:20,360 --> 00:14:25,000
使得在我们就是这个地方

335
00:14:25,000 --> 00:14:28,560
我们可以把它重新写成一个二维的输入

336
00:14:28,560 --> 00:14:29,400
二维的输出

337
00:14:29,400 --> 00:14:31,880
然后对我们的权重做些重新的索引

338
00:14:32,320 --> 00:14:36,840
那么就是首先我们把所有的前面两个

339
00:14:36,840 --> 00:14:37,720
位数我们不要了

340
00:14:39,000 --> 00:14:40,880
就把它压成一个两个维度的东西

341
00:14:41,520 --> 00:14:43,360
就是说你在别的维度都是一样的元素

342
00:14:43,920 --> 00:14:48,480
第二个是说我们A和B把它限制

343
00:14:48,480 --> 00:14:50,720
从一个在负delta和delta之间的一个值

344
00:14:50,720 --> 00:14:51,840
就变成一个很小的值

345
00:14:52,720 --> 00:14:57,080
OK这就是我们的全联阶层到卷积层的

346
00:14:57,080 --> 00:14:58,760
一个变化是这么来的

