1
00:00:00,000 --> 00:00:02,240
好 我们接下来讲毛框

2
00:00:03,320 --> 00:00:10,120
就是说因为我们在目标检测里面需要预测边缘框

3
00:00:10,759 --> 00:00:14,880
边缘框所以给我们的预测带来了很大的问题

4
00:00:15,480 --> 00:00:18,600
就是我们在卷迹神级网络里面做图片分类的时候

5
00:00:18,600 --> 00:00:20,559
整个代码写起来看上去非常简单

6
00:00:20,559 --> 00:00:21,000
对吧

7
00:00:21,080 --> 00:00:23,640
就是一个softmax出去就完事了

8
00:00:24,039 --> 00:00:26,679
但是因为有边缘框的加入

9
00:00:26,800 --> 00:00:30,600
使得我们在预测麻烦的特别多

10
00:00:31,280 --> 00:00:33,840
今天我们这里讲的是毛框一个技术

11
00:00:33,840 --> 00:00:38,320
就是说毛框就是计算机视觉的算法

12
00:00:38,320 --> 00:00:40,600
生成的一些框用来预测边缘框

13
00:00:40,600 --> 00:00:42,119
用来框叫做毛框

14
00:00:42,560 --> 00:00:43,719
就在anchor box

15
00:00:46,239 --> 00:00:50,799
就是说一大类的目标检测算法是起毛框的

16
00:00:51,159 --> 00:00:55,480
现在也有非不需要毛框的算法

17
00:00:55,480 --> 00:01:00,360
但是主流的其实目前看起来还是基于毛框操作

18
00:01:01,120 --> 00:01:02,280
毛框是个什么东西

19
00:01:02,280 --> 00:01:07,400
就是说对一个计算机视觉一个算法来讲

20
00:01:07,400 --> 00:01:12,760
它先提出多个被毛框

21
00:01:12,760 --> 00:01:15,400
它也是一个框

22
00:01:16,359 --> 00:01:17,520
它就是一个box

23
00:01:17,600 --> 00:01:20,719
所以我们一般来说边缘框就bonding box

24
00:01:21,159 --> 00:01:22,600
就我翻译成边缘框

25
00:01:23,000 --> 00:01:27,240
bonding box一般是讲你真实的位置

26
00:01:27,240 --> 00:01:29,240
就是你标号里面的位置

27
00:01:29,680 --> 00:01:36,280
毛框就是说我先我算法对边框的一个位置的一个猜测

28
00:01:37,840 --> 00:01:40,920
就是说因为我并不知道你到底框在什么地方

29
00:01:40,920 --> 00:01:44,360
我如果直接去预测4个数字其实比较难

30
00:01:44,600 --> 00:01:45,360
它一般怎么做

31
00:01:45,720 --> 00:01:49,960
一般说我先提出多个框在这个地方

32
00:01:49,960 --> 00:01:51,200
比如说这里一张图片

33
00:01:51,200 --> 00:01:53,200
我们等会看图片怎么生成出来的

34
00:01:53,480 --> 00:01:57,079
就他说我提出了这里面有5个框

35
00:01:57,079 --> 00:01:59,600
就我先画算法给你画出5个框

36
00:02:00,159 --> 00:02:04,079
所以我说我去看5个框里面有没有我要的物体

37
00:02:06,079 --> 00:02:07,200
就如果有的话

38
00:02:07,400 --> 00:02:12,080
比如说这一个框最小的框可能你觉得没有

39
00:02:12,080 --> 00:02:13,439
就是说因为他其实以为有

40
00:02:13,439 --> 00:02:19,599
就是说他可能觉得看到那一块就基本上是一个特别局部

41
00:02:19,599 --> 00:02:20,800
你也可以说没有

42
00:02:21,120 --> 00:02:25,640
然后这一个蓝色的你看起来基本上跟我们的那个Bound box

43
00:02:25,640 --> 00:02:28,160
就是跟我们的真实的标号已经很近了

44
00:02:28,400 --> 00:02:31,240
就是说蓝色的话我们这个框提出的非常好

45
00:02:31,920 --> 00:02:35,920
就是说这个意思是说那个蓝色框其实应该是有我们那只口

46
00:02:37,360 --> 00:02:40,000
就是说如果一个毛框里面

47
00:02:41,160 --> 00:02:43,240
含有我要关注的物体的话

48
00:02:43,760 --> 00:02:45,720
就是我先分类说是还是不是

49
00:02:46,760 --> 00:02:49,920
或者是说是哪一个来类物体

50
00:02:50,400 --> 00:02:51,920
如果你发现有的话

51
00:02:52,160 --> 00:02:55,680
接下来我会基于这个毛框去预测

52
00:02:55,800 --> 00:02:59,880
他到我真实的Bound box是怎么样移过去的

53
00:03:01,000 --> 00:03:05,960
就是说我不再是真的跟你直接去预测的4个Bound box

54
00:03:05,960 --> 00:03:08,000
就是边缘框的那个坐标

55
00:03:08,120 --> 00:03:10,440
而是说我基于我的一系列

56
00:03:10,440 --> 00:03:13,520
我先提出很多个毛框

57
00:03:13,920 --> 00:03:18,520
然后再我觉得跟你大差不多含

58
00:03:18,520 --> 00:03:20,520
包含了我管性区的物体的时候

59
00:03:20,560 --> 00:03:23,719
再做一次调整把那个边把毛框

60
00:03:23,719 --> 00:03:27,000
然后慢调整到真实的边框的位置

61
00:03:28,640 --> 00:03:29,040
OK

62
00:03:29,040 --> 00:03:32,120
所以这个地方你可以看到是说我们要做两次预测

63
00:03:32,160 --> 00:03:36,640
一测试你这个毛框里面是不是还能哪一类物体

64
00:03:37,400 --> 00:03:40,000
而另外一颗是说你这个位置的预测

65
00:03:40,560 --> 00:03:42,560
这也对应的是我们的目标检测里面

66
00:03:42,560 --> 00:03:46,520
需要预测物体的类别和我的物体的位置

67
00:03:49,520 --> 00:03:49,880
OK

68
00:03:49,880 --> 00:03:54,159
然后这个基于毛框这一类算法

69
00:03:54,439 --> 00:03:55,840
另外一块还有一类算法

70
00:03:55,840 --> 00:03:57,879
就是说直接说我不需要深层的毛框

71
00:03:57,879 --> 00:03:58,920
直接去预测了

72
00:03:58,920 --> 00:03:59,760
这是另外一类

73
00:04:00,000 --> 00:04:02,800
但是基于毛框这一块还是相对来说

74
00:04:03,280 --> 00:04:04,560
目前来说更加主流

75
00:04:04,960 --> 00:04:10,360
所以我们整个这一届就是讲怎么样去处理这样子的毛框

76
00:04:12,000 --> 00:04:12,760
处理毛框的话

77
00:04:12,760 --> 00:04:18,400
首先我们要看一个是说要比较两个框之间的相似度

78
00:04:18,680 --> 00:04:20,680
OK

79
00:04:20,680 --> 00:04:21,919
就是说我有两个框

80
00:04:21,919 --> 00:04:27,039
说我要说毛框跟我的真实框之间的相似度有多少的话

81
00:04:27,039 --> 00:04:28,000
我要怎么办呢

82
00:04:28,399 --> 00:04:32,279
一般来说它用的是一个叫做IOU的一个计算标准

83
00:04:33,479 --> 00:04:37,319
叫做Intersection over Unit

84
00:04:37,319 --> 00:04:38,719
就是交并比

85
00:04:40,519 --> 00:04:43,359
就是说如果它是一个0到1之间的一个数值

86
00:04:44,000 --> 00:04:44,759
如果它是0

87
00:04:44,879 --> 00:04:47,120
表示你两个框间没有充电

88
00:04:47,720 --> 00:04:49,399
1表示它是完全重合

89
00:04:50,680 --> 00:04:51,399
越接近1

90
00:04:51,560 --> 00:04:53,840
它的重合度就会相似度就越高

91
00:04:54,600 --> 00:04:56,560
它的算法其实很简单

92
00:04:56,560 --> 00:04:57,040
可以看一下

93
00:04:57,040 --> 00:04:59,160
就是我给了一个两个毛框

94
00:04:59,160 --> 00:05:00,680
一个叫比如说一个是A

95
00:05:01,480 --> 00:05:02,439
一个是B的话

96
00:05:02,879 --> 00:05:05,160
我要算我的A和B之间的相似度

97
00:05:05,439 --> 00:05:08,360
我先去算它A和B之间的交集

98
00:05:09,399 --> 00:05:10,759
交的区域是多少

99
00:05:11,800 --> 00:05:12,800
交的区域就是这一块

100
00:05:14,000 --> 00:05:15,199
就是这一块地方

101
00:05:16,039 --> 00:05:17,039
然后它做分母

102
00:05:17,800 --> 00:05:19,639
它的做分子

103
00:05:20,279 --> 00:05:22,879
它的分母就是这两个框它的并集

104
00:05:24,240 --> 00:05:24,479
OK

105
00:05:24,879 --> 00:05:25,920
所以你可以看到是说

106
00:05:26,240 --> 00:05:30,719
基本上肯定是并集大于等于交集

107
00:05:30,920 --> 00:05:33,639
所以一定是0和1之间的一个数字

108
00:05:34,439 --> 00:05:36,240
如果你两个框之间没有充电

109
00:05:36,560 --> 00:05:38,039
那么交就是为0

110
00:05:38,800 --> 00:05:40,480
那么所以它IOU优势等于0的

111
00:05:41,199 --> 00:05:42,399
如果是完全充电的话

112
00:05:42,400 --> 00:05:44,320
那么它的交集和它的并集

113
00:05:44,320 --> 00:05:47,240
都等于它们两个的各自的面积

114
00:05:47,240 --> 00:05:48,280
那么它就等于1

115
00:05:49,320 --> 00:05:49,560
OK

116
00:05:49,560 --> 00:05:50,440
这就是IOU

117
00:05:50,880 --> 00:05:51,800
就IOU就是说

118
00:05:51,800 --> 00:05:53,120
它其实可以认为是

119
00:05:53,520 --> 00:05:55,920
不是一个首创的东西

120
00:05:56,080 --> 00:05:58,000
它是一个常用的一个东西

121
00:05:58,000 --> 00:05:59,920
叫做甲铐比的指数

122
00:06:00,440 --> 00:06:02,320
就是说它给定两个集合

123
00:06:02,720 --> 00:06:04,640
我要算两个集合的相似度怎么算

124
00:06:06,520 --> 00:06:08,840
这两个集合的交集的大小

125
00:06:08,840 --> 00:06:10,360
绝对只是它大小的意思

126
00:06:10,560 --> 00:06:11,200
它的并集

127
00:06:11,199 --> 00:06:11,759
它的大小

128
00:06:11,759 --> 00:06:12,639
然后一除

129
00:06:12,839 --> 00:06:15,479
就是叫做甲铐比指数

130
00:06:15,719 --> 00:06:18,920
大家可能大学大学书学过这个东西

131
00:06:19,479 --> 00:06:21,120
所以如果你说你把一个框

132
00:06:21,839 --> 00:06:23,199
它的每一个像素

133
00:06:23,199 --> 00:06:24,920
当做是一个元素的话

134
00:06:25,000 --> 00:06:27,759
那么一个框其就是一个像素的集合

135
00:06:28,719 --> 00:06:29,759
那么接下来就是说

136
00:06:29,759 --> 00:06:30,959
让你的IOU就等价

137
00:06:30,959 --> 00:06:33,000
就是说你的甲铐比指数了

138
00:06:33,240 --> 00:06:38,599
这就是怎么样衡量两个框之间的相似度

139
00:06:39,120 --> 00:06:39,599
OK

140
00:06:41,319 --> 00:06:43,639
接下来

141
00:06:44,519 --> 00:06:48,000
我们要给毛框标号

142
00:06:49,800 --> 00:06:50,560
这是个什么意思

143
00:06:50,719 --> 00:06:51,479
就是说

144
00:06:52,800 --> 00:06:53,959
我真实的算

145
00:06:53,959 --> 00:06:56,120
就基于毛框的算法怎么做的

146
00:06:56,560 --> 00:06:59,240
我先说我提出

147
00:06:59,800 --> 00:07:00,759
比如说一张图片

148
00:07:00,759 --> 00:07:02,719
我提出1万个毛框

149
00:07:04,039 --> 00:07:05,079
1万个毛框的话

150
00:07:05,079 --> 00:07:07,199
那么就是说我去对每个毛框预测

151
00:07:07,199 --> 00:07:10,439
它是不是有某一个框住的某个物体

152
00:07:10,920 --> 00:07:15,480
和这个毛框到一个真实的标号

153
00:07:15,480 --> 00:07:18,240
就是边缘框之间是怎么移过去的

154
00:07:20,839 --> 00:07:21,839
那么就是说

155
00:07:23,000 --> 00:07:24,480
我就做预测问题

156
00:07:24,480 --> 00:07:26,199
所以在训练的时候

157
00:07:26,879 --> 00:07:27,720
训练的时候

158
00:07:27,720 --> 00:07:29,879
每一个毛框是一个训练样本

159
00:07:32,439 --> 00:07:33,399
那么对每个毛框

160
00:07:33,399 --> 00:07:34,720
它的标号是什么呢

161
00:07:35,120 --> 00:07:37,360
就是说对每个毛框来讲

162
00:07:37,399 --> 00:07:39,560
它要么标示成背景

163
00:07:39,560 --> 00:07:41,040
就什么东西都没有

164
00:07:41,040 --> 00:07:42,759
它只框住了背景

165
00:07:44,079 --> 00:07:45,439
要么就是说我们认为

166
00:07:45,439 --> 00:07:47,920
它跟某一个真实边缘框

167
00:07:47,920 --> 00:07:50,560
就是某一个物体是相关联的

168
00:07:51,160 --> 00:07:52,920
也就是说这个毛框

169
00:07:52,920 --> 00:07:54,399
它框住的物体

170
00:07:54,399 --> 00:07:55,160
它的标号

171
00:07:55,160 --> 00:07:56,199
那个物体标号

172
00:07:56,199 --> 00:07:58,600
就是这个bonding box

173
00:07:59,199 --> 00:08:01,399
它的ground choose bonding box

174
00:08:01,600 --> 00:08:05,040
它框住的物体的标号

175
00:08:05,759 --> 00:08:07,959
以及它毛框的偏移

176
00:08:08,240 --> 00:08:11,400
就是它到这一个真实边缘框的偏移

177
00:08:13,200 --> 00:08:14,760
所以复印毛框标号

178
00:08:14,760 --> 00:08:15,760
就是说你要么就是说

179
00:08:15,760 --> 00:08:18,120
这个毛框是一个复理样本

180
00:08:18,120 --> 00:08:19,280
就是说只有背景

181
00:08:19,400 --> 00:08:20,080
要么就是说

182
00:08:20,080 --> 00:08:23,600
你得把它跟一个标好的边缘框

183
00:08:23,600 --> 00:08:24,840
给你关联上

184
00:08:26,880 --> 00:08:27,520
OK

185
00:08:28,000 --> 00:08:28,800
一般来说

186
00:08:28,920 --> 00:08:29,800
你一个算法

187
00:08:29,840 --> 00:08:32,400
会生成很多大量的毛框

188
00:08:32,400 --> 00:08:33,519
就是说一件图片

189
00:08:33,519 --> 00:08:34,680
我可能生成上万

190
00:08:34,680 --> 00:08:36,639
或上百万个毛框

191
00:08:37,519 --> 00:08:39,679
然后你的真实边框又不多

192
00:08:39,679 --> 00:08:41,279
就是你标号又不多

193
00:08:41,279 --> 00:08:42,399
可能就10个

194
00:08:42,519 --> 00:08:43,759
那么就是说

195
00:08:44,480 --> 00:08:46,919
你可能对于一个毛框来讲

196
00:08:46,919 --> 00:08:48,159
绝大部分毛框

197
00:08:48,159 --> 00:08:49,439
它都是一个背景

198
00:08:51,199 --> 00:08:54,759
这样子会导致大量的负累的样本

199
00:08:54,960 --> 00:08:56,000
这也就是说

200
00:08:56,000 --> 00:09:00,120
整个目标检测算法

201
00:09:00,120 --> 00:09:01,399
它要处理的是说

202
00:09:01,399 --> 00:09:04,200
你要处理你每个毛框是样本

203
00:09:04,200 --> 00:09:05,919
你大量的毛框是一个

204
00:09:06,639 --> 00:09:07,319
负累样本

205
00:09:07,319 --> 00:09:08,559
因为它只有背景

206
00:09:10,799 --> 00:09:12,559
所以我们可以看一个具体来讲

207
00:09:12,559 --> 00:09:14,199
是怎么样去

208
00:09:16,080 --> 00:09:17,679
赋予标号的一个办法

209
00:09:19,720 --> 00:09:22,919
首先我们这里有一个

210
00:09:25,039 --> 00:09:26,480
有一个矩阵

211
00:09:26,919 --> 00:09:28,000
它的列是什么

212
00:09:28,000 --> 00:09:28,799
它列是说

213
00:09:28,799 --> 00:09:32,080
这里有4个标注好的边缘框

214
00:09:32,639 --> 00:09:33,559
1234

215
00:09:33,639 --> 00:09:35,879
这就是你真实图片有4个物体

216
00:09:35,879 --> 00:09:38,240
每个物体有对4个框

217
00:09:39,120 --> 00:09:39,919
毛框的话

218
00:09:39,919 --> 00:09:43,000
假设我生成了9个毛框出来

219
00:09:44,720 --> 00:09:46,679
那么如果是这样子情况下

220
00:09:46,679 --> 00:09:49,080
我会说每个毛框

221
00:09:49,120 --> 00:09:51,080
去跟边缘框

222
00:09:51,559 --> 00:09:53,200
算IOU值

223
00:09:53,320 --> 00:09:54,120
然后算了值

224
00:09:54,120 --> 00:09:56,240
就填在里面的每一项里面

225
00:09:59,759 --> 00:10:01,840
然后接下来就第一个干的什么事情

226
00:10:02,200 --> 00:10:03,440
整个矩阵里面

227
00:10:03,480 --> 00:10:06,040
最大的值挑出来

228
00:10:06,280 --> 00:10:07,760
假设是这个值的话

229
00:10:09,280 --> 00:10:10,720
那么我们就会把

230
00:10:11,880 --> 00:10:14,080
标号边缘框3

231
00:10:14,800 --> 00:10:16,320
给它毛框2

232
00:10:16,320 --> 00:10:17,480
就是把毛框2

233
00:10:18,440 --> 00:10:21,600
你的任务就是去预测边缘框3的位置

234
00:10:21,640 --> 00:10:22,440
它的物体

235
00:10:22,960 --> 00:10:24,840
因为里面的重合度最高

236
00:10:26,520 --> 00:10:27,360
那么接下来就是说

237
00:10:27,360 --> 00:10:28,800
我会把这一行

238
00:10:28,840 --> 00:10:31,520
这一列给你删掉

239
00:10:32,519 --> 00:10:32,960
然后

240
00:10:34,960 --> 00:10:37,480
不在刚刚删掉的里面

241
00:10:37,480 --> 00:10:39,519
我们再把最大值取出来

242
00:10:39,519 --> 00:10:41,279
假设是你这个的话

243
00:10:41,480 --> 00:10:44,360
那么接下来我会把毛框7

244
00:10:44,639 --> 00:10:48,039
跟边缘框1给你关联起来

245
00:10:48,319 --> 00:10:49,120
同样道理的话

246
00:10:49,120 --> 00:10:51,159
我会把这两个删掉

247
00:10:51,960 --> 00:10:53,840
然后接下来会在那些蓝色的

248
00:10:53,840 --> 00:10:55,879
没有被删掉的那些格里面

249
00:10:55,879 --> 00:10:57,720
再找一个最大的

250
00:10:58,799 --> 00:10:59,679
就找它

251
00:11:00,440 --> 00:11:01,840
那就是说把毛框

252
00:11:02,160 --> 00:11:03,840
跟它又给你对应起来

253
00:11:04,320 --> 00:11:04,560
OK

254
00:11:04,560 --> 00:11:08,160
就是说直到我们把所有的边框

255
00:11:08,160 --> 00:11:10,520
给你assign完

256
00:11:11,720 --> 00:11:13,160
就是说把所有的边框

257
00:11:13,160 --> 00:11:15,120
都至少找到了一个毛框

258
00:11:15,120 --> 00:11:16,240
给你关联起来

259
00:11:16,640 --> 00:11:18,040
那么剩下的毛框里面

260
00:11:18,040 --> 00:11:19,040
你有很多办法

261
00:11:19,200 --> 00:11:20,320
就是一个简单是说

262
00:11:20,320 --> 00:11:22,040
我就直接把全部放成

263
00:11:22,720 --> 00:11:23,560
复利样本

264
00:11:23,840 --> 00:11:25,480
就这样子会导致太多了

265
00:11:25,480 --> 00:11:28,200
假设你是100万个毛框的话

266
00:11:28,240 --> 00:11:30,200
你边框就那么5个的话

267
00:11:30,200 --> 00:11:31,720
那么就是说你会生成

268
00:11:32,160 --> 00:11:32,879
5个占领

269
00:11:32,879 --> 00:11:34,480
就剩下全是复利

270
00:11:34,800 --> 00:11:35,640
所以一般的做法

271
00:11:35,640 --> 00:11:37,320
就是说剩下那些毛框里面

272
00:11:37,320 --> 00:11:38,480
去看一看说

273
00:11:38,960 --> 00:11:41,960
跟谁的边框的IOU值比较大

274
00:11:42,080 --> 00:11:44,160
我就是就assign过去了

275
00:11:44,160 --> 00:11:45,400
这也是另外一种做法

276
00:11:46,480 --> 00:11:47,040
OK

277
00:11:47,440 --> 00:11:48,200
另外反过来讲

278
00:11:48,320 --> 00:11:50,759
就是说这里面有两点值得注意的

279
00:11:51,080 --> 00:11:52,200
一个是说

280
00:11:52,560 --> 00:11:54,040
毛框一般来说

281
00:11:54,960 --> 00:11:56,879
你要么就是固定生产的

282
00:11:57,000 --> 00:11:58,879
要么就是会根据图片

283
00:11:58,879 --> 00:11:59,720
图片进来

284
00:11:59,720 --> 00:12:01,519
我会根据图片去生成毛框

285
00:12:02,399 --> 00:12:05,480
那么边缘框这个东西

286
00:12:05,480 --> 00:12:07,080
是你标好的东西

287
00:12:07,080 --> 00:12:08,120
是已经存好的

288
00:12:08,120 --> 00:12:09,240
就是硬盘读进来了

289
00:12:09,639 --> 00:12:12,679
那么复以毛框标号这个过程

290
00:12:12,679 --> 00:12:15,240
是一个每次把图片读进来之后

291
00:12:15,240 --> 00:12:16,639
要做一次的一个操作

292
00:12:17,679 --> 00:12:19,480
就说你读一张图片进来

293
00:12:19,879 --> 00:12:22,000
然后就说一张图片读进来

294
00:12:22,000 --> 00:12:24,639
假设你有9个毛框的话

295
00:12:24,879 --> 00:12:27,919
我就会生成9个训练样本出来

296
00:12:30,319 --> 00:12:30,919
OK

297
00:12:30,960 --> 00:12:33,199
这个是第一点值得注意的

298
00:12:33,199 --> 00:12:35,600
所以跟你的图片分类会不一样

299
00:12:35,639 --> 00:12:36,519
一个图片读进来

300
00:12:36,519 --> 00:12:38,439
你可能会生成很多个训练样本

301
00:12:38,480 --> 00:12:40,799
所以导致说你在目标检测的时候

302
00:12:40,799 --> 00:12:42,679
很有可能是一张一张图片读的

303
00:12:43,360 --> 00:12:45,720
因为你内存可能放不下

304
00:12:46,360 --> 00:12:47,639
第二个是说

305
00:12:47,919 --> 00:12:49,039
你的

306
00:12:51,679 --> 00:12:53,720
复以标号的算法

307
00:12:53,720 --> 00:12:55,600
我们再给了一个算法

308
00:12:55,639 --> 00:12:56,680
其实有很多种

309
00:12:57,680 --> 00:13:00,040
就是说任何这种我们讲的

310
00:13:00,040 --> 00:13:01,480
今天我们接下来讲的东西

311
00:13:01,480 --> 00:13:03,200
都相对说比较复杂

312
00:13:03,240 --> 00:13:04,840
就是说里面逻辑性很强

313
00:13:04,879 --> 00:13:05,600
所以这样子

314
00:13:05,600 --> 00:13:07,279
它不代表说

315
00:13:07,840 --> 00:13:09,040
大家都是这么做的

316
00:13:09,040 --> 00:13:11,160
就是说这是一个常用的做法

317
00:13:11,200 --> 00:13:13,519
但是具体的模型

318
00:13:13,519 --> 00:13:15,920
具体的实现可能用的方法会不一样

319
00:13:15,960 --> 00:13:16,879
因为你会觉得说

320
00:13:17,000 --> 00:13:17,720
其实这种东西

321
00:13:17,720 --> 00:13:20,240
都有太多设计的东西在里面了

322
00:13:20,279 --> 00:13:22,160
而且可能这有细节的区别

323
00:13:22,200 --> 00:13:23,320
对于最后的结果

324
00:13:23,320 --> 00:13:26,040
其实大家也不是那么的弄得清楚

325
00:13:26,040 --> 00:13:29,120
所以会发现很多种不同的做法

326
00:13:29,160 --> 00:13:29,879
所以我们这里

327
00:13:29,879 --> 00:13:31,879
因为没有时间去给所有

328
00:13:31,879 --> 00:13:33,600
给大家介绍所有的办法

329
00:13:33,879 --> 00:13:37,760
所以给大家介绍几种常见的做法

330
00:13:40,680 --> 00:13:40,960
OK

331
00:13:40,960 --> 00:13:41,760
另外一个

332
00:13:41,960 --> 00:13:44,480
另外一个核心技术叫做NMS

333
00:13:45,320 --> 00:13:48,360
叫做非极大抑制

334
00:13:48,400 --> 00:13:51,920
就是non-maximum suspension

335
00:13:52,920 --> 00:13:54,200
它的一个想法

336
00:13:54,200 --> 00:13:55,200
它的一个目的是什么

337
00:13:55,360 --> 00:13:56,120
就是说

338
00:13:56,160 --> 00:13:57,960
因为我们每个毛框

339
00:13:58,200 --> 00:14:00,160
都要去预测一个边缘框

340
00:14:01,600 --> 00:14:02,640
那么你预测出来

341
00:14:02,640 --> 00:14:03,520
只你可能是

342
00:14:03,720 --> 00:14:05,200
比如说我会预测

343
00:14:05,440 --> 00:14:06,400
比如说这种图片

344
00:14:06,400 --> 00:14:10,000
我会预测出三个四个框出来

345
00:14:11,080 --> 00:14:13,680
里面当然很多框是很相似的

346
00:14:15,360 --> 00:14:16,720
就是说你很多相似的框

347
00:14:16,720 --> 00:14:19,440
我需要把这些框相似的预测框

348
00:14:19,440 --> 00:14:21,880
基本上给你除掉

349
00:14:22,680 --> 00:14:24,600
就是说让你的输出比较干净

350
00:14:24,600 --> 00:14:26,160
就是说输出成一个干净的

351
00:14:26,160 --> 00:14:27,880
是下面一个这样子的

352
00:14:27,920 --> 00:14:28,880
干净一样的输出

353
00:14:28,880 --> 00:14:31,880
就是说相似的预测那些框

354
00:14:31,880 --> 00:14:33,560
我要去掉

355
00:14:34,800 --> 00:14:37,840
就是MS就是其中一个去除的方法

356
00:14:38,640 --> 00:14:39,440
它怎么做的

357
00:14:42,000 --> 00:14:44,320
首先它选中

358
00:14:44,720 --> 00:14:46,480
所有的预测里面

359
00:14:47,480 --> 00:14:48,840
所有的框预测里面

360
00:14:48,840 --> 00:14:52,800
是非背景类的最大预测值

361
00:14:53,120 --> 00:14:54,120
就预测值是什么

362
00:14:54,120 --> 00:14:58,320
预测值是对类的预测的softmax的值

363
00:14:58,680 --> 00:15:00,720
越接近于1就是说越知性

364
00:15:01,600 --> 00:15:04,840
所以我找出我所有的框里面

365
00:15:04,960 --> 00:15:07,279
所有的模块的预测里面

366
00:15:07,320 --> 00:15:10,480
它对应的类别的预测值

367
00:15:11,039 --> 00:15:12,680
而且类别不是背景类

368
00:15:12,680 --> 00:15:14,440
而是一个真正的物体类

369
00:15:14,440 --> 00:15:15,720
背景类我们不关心

370
00:15:16,120 --> 00:15:18,480
把里面最大的预测定出来

371
00:15:19,560 --> 00:15:20,560
所以框

372
00:15:20,759 --> 00:15:22,080
所以我们这个值

373
00:15:22,080 --> 00:15:22,720
就是说

374
00:15:22,840 --> 00:15:24,000
就dog等于0.9

375
00:15:24,000 --> 00:15:27,440
就是等于是我的预测值

376
00:15:28,399 --> 00:15:29,440
所以这个地方就是说

377
00:15:29,440 --> 00:15:31,160
我就是说你可以看到是0.9

378
00:15:31,160 --> 00:15:31,480
0.8

379
00:15:31,480 --> 00:15:32,240
0.7

380
00:15:32,279 --> 00:15:33,120
0.9

381
00:15:33,759 --> 00:15:36,000
那么我就说我反正两个0.9

382
00:15:36,120 --> 00:15:39,320
我比如说我先把狗0.9拎出来

383
00:15:40,720 --> 00:15:44,360
然后我去除掉所有和它最大预测值

384
00:15:44,360 --> 00:15:49,840
和它IUC值大于某一个threshold

385
00:15:50,600 --> 00:15:52,080
就sielta的预测

386
00:15:52,480 --> 00:15:54,759
假设我的预测值是0.5的话

387
00:15:54,800 --> 00:15:57,440
那么这两个框目测来看

388
00:15:57,440 --> 00:15:59,519
它的相似度应该是大于0.5

389
00:15:59,639 --> 00:16:00,759
跟蓝色的框

390
00:16:00,800 --> 00:16:03,360
但猫跟它就是不像

391
00:16:03,360 --> 00:16:04,759
应该是IOU等于0

392
00:16:04,759 --> 00:16:05,919
所以就没关系

393
00:16:05,960 --> 00:16:08,519
所以它就会把这两个狗的框

394
00:16:08,519 --> 00:16:09,320
给你去掉

395
00:16:10,600 --> 00:16:11,800
那么接下来就剩

396
00:16:12,320 --> 00:16:13,280
我就把剩下的

397
00:16:15,280 --> 00:16:15,960
那么剩下的

398
00:16:16,960 --> 00:16:18,520
里面还没有被去掉

399
00:16:18,520 --> 00:16:19,600
或被保留的里面

400
00:16:19,600 --> 00:16:21,760
那就是猫把最大值给拿出来

401
00:16:21,880 --> 00:16:23,640
就一直重复这个过程

402
00:16:23,680 --> 00:16:26,560
使得你所有的预测的框

403
00:16:26,800 --> 00:16:28,640
要么就是被留住

404
00:16:29,960 --> 00:16:31,960
要么就是被去掉

405
00:16:32,760 --> 00:16:33,640
就是一直这么做

406
00:16:33,640 --> 00:16:36,520
做到你会得到一个比较干净的输出

407
00:16:36,520 --> 00:16:38,360
就是NMS的输出

408
00:16:39,960 --> 00:16:40,440
OK

409
00:16:42,720 --> 00:16:43,560
所以就是说

410
00:16:45,560 --> 00:16:46,240
总结一下

411
00:16:46,240 --> 00:16:47,120
就是说

412
00:16:47,680 --> 00:16:48,760
我们这一节就是讲

413
00:16:48,760 --> 00:16:50,840
毛框新的一个概念

414
00:16:51,440 --> 00:16:52,280
这是因为我们讲

415
00:16:52,400 --> 00:16:55,040
是因为有一大类的目标

416
00:16:55,040 --> 00:16:55,680
检测算法

417
00:16:55,680 --> 00:16:57,600
都是基于毛框来预测的

418
00:16:57,960 --> 00:16:59,000
所以这类算法是干嘛

419
00:16:59,440 --> 00:17:01,680
就首先它会生成大量的毛框

420
00:17:01,960 --> 00:17:04,360
不同算法的生成毛框的方法不一样

421
00:17:04,400 --> 00:17:08,000
我们会接下来给大家讲一个

422
00:17:08,000 --> 00:17:09,360
具体的生成方法

423
00:17:10,200 --> 00:17:10,920
生成完之后

424
00:17:10,920 --> 00:17:13,560
我们会给每个毛框一个标号

425
00:17:14,600 --> 00:17:15,960
就是根据你有很多的办法

426
00:17:16,120 --> 00:17:18,320
就是根据我们刚刚介绍了一个办法

427
00:17:18,680 --> 00:17:20,680
这样子每一个毛框就会有一个标号

428
00:17:20,720 --> 00:17:23,800
然后有一个它的真实框的偏移

429
00:17:24,160 --> 00:17:25,360
这样子我们就可以训练了

430
00:17:26,480 --> 00:17:27,720
在预测的时候

431
00:17:27,720 --> 00:17:31,200
我们就是会要对每一个毛框

432
00:17:31,200 --> 00:17:32,360
都会预测一下

433
00:17:33,440 --> 00:17:34,039
那么就是说

434
00:17:34,039 --> 00:17:37,480
我们会生成大量的冗余的预测

435
00:17:37,519 --> 00:17:40,279
我们会用一个叫做NMS的技术

436
00:17:40,359 --> 00:17:42,039
来去掉那些冗余的预测

437
00:17:43,200 --> 00:17:43,519
OK

438
00:17:44,519 --> 00:17:44,960
所以好

439
00:17:45,000 --> 00:17:47,000
接下来我们就是会来讲

440
00:17:48,480 --> 00:17:51,000
他们这几种东西代码的实现

441
00:17:51,519 --> 00:17:53,319
因为毛框的引入

442
00:17:53,879 --> 00:17:56,799
使得我们整个目标检测的算法

443
00:17:56,799 --> 00:18:01,079
它的复杂度远远的高于图片分类

444
00:18:01,440 --> 00:18:02,559
它有很多细节性的

445
00:18:02,559 --> 00:18:04,240
你要去处理这个框的东西

446
00:18:04,240 --> 00:18:06,000
我们接下来给大家讲一讲

