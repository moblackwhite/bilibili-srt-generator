1
00:00:00,000 --> 00:00:02,560
接下来我们要看的是说

2
00:00:02,560 --> 00:00:05,160
假设我们已经定义好我们的类了

3
00:00:05,160 --> 00:00:09,200
我们的参数怎么样去访问

4
00:00:11,200 --> 00:00:11,439
好

5
00:00:11,439 --> 00:00:13,040
首先我们还是跟之前一样

6
00:00:13,040 --> 00:00:15,000
我们定义的一个

7
00:00:16,760 --> 00:00:18,519
一个很简单的一个类

8
00:00:18,719 --> 00:00:20,080
就是一个线性层

9
00:00:20,120 --> 00:00:21,879
一个relu的一个激活函数

10
00:00:21,920 --> 00:00:23,000
再一个线性层

11
00:00:23,480 --> 00:00:25,480
然后我们给一个random x

12
00:00:25,480 --> 00:00:26,760
就是一个二乘四

13
00:00:26,800 --> 00:00:27,199
进去

14
00:00:27,199 --> 00:00:28,640
然后得到一个输出

15
00:00:28,800 --> 00:00:30,640
这是一个最简单的一个

16
00:00:30,800 --> 00:00:32,640
有单隐藏层的MLP

17
00:00:34,799 --> 00:00:35,000
好

18
00:00:35,000 --> 00:00:36,719
接下来我们要干的事情是说

19
00:00:36,760 --> 00:00:39,159
我们要把里面的每一层里面的

20
00:00:39,159 --> 00:00:40,640
那些权重拿出来

21
00:00:41,120 --> 00:00:42,280
具体来说

22
00:00:42,719 --> 00:00:44,079
我们记得我们的

23
00:00:44,480 --> 00:00:47,040
net是一个n sequential的东西

24
00:00:47,200 --> 00:00:49,240
sequential它其实就是一个list

25
00:00:49,240 --> 00:00:51,040
你可以简单认为是一个python的

26
00:00:51,040 --> 00:00:51,840
一个list

27
00:00:52,519 --> 00:00:55,679
所以net r拿到的是谁呢

28
00:00:56,280 --> 00:00:58,000
net r拿到的就是

29
00:00:58,119 --> 00:01:00,000
这是net0

30
00:01:00,200 --> 00:01:01,240
这是net1

31
00:01:01,399 --> 00:01:02,399
这是net2

32
00:01:02,439 --> 00:01:06,640
net2拿到的就是我们最后的输出层

33
00:01:08,040 --> 00:01:09,480
然后它就是一个八乘一的

34
00:01:10,599 --> 00:01:11,960
然后我们就可以说

35
00:01:12,000 --> 00:01:14,439
net2我们的state

36
00:01:14,879 --> 00:01:15,439
dict

37
00:01:15,439 --> 00:01:17,200
就state就是一个状态

38
00:01:17,240 --> 00:01:19,519
因为它的权重可以认为

39
00:01:19,519 --> 00:01:22,000
从一个自动机的角度来讲

40
00:01:22,000 --> 00:01:23,599
它的权重是它的一个状态

41
00:01:23,599 --> 00:01:25,240
因为它的权重可以被改变

42
00:01:26,319 --> 00:01:27,439
所以它的state

43
00:01:27,519 --> 00:01:29,879
就我们知道全连接层有两个参数

44
00:01:29,879 --> 00:01:30,679
一个是weight

45
00:01:30,679 --> 00:01:31,480
一个是bias

46
00:01:31,519 --> 00:01:32,000
对吧

47
00:01:32,039 --> 00:01:33,599
所以你可以看到是说

48
00:01:33,640 --> 00:01:34,599
它的dict

49
00:01:34,719 --> 00:01:36,239
它就是其实理论上

50
00:01:36,239 --> 00:01:38,439
它就是下滑梯的modules

51
00:01:38,439 --> 00:01:39,120
那个东西

52
00:01:39,200 --> 00:01:41,079
可以看到它是order的dict

53
00:01:41,480 --> 00:01:42,400
就我们之前有讲过

54
00:01:42,560 --> 00:01:43,680
它是一个排好序的

55
00:01:43,840 --> 00:01:46,599
接下来它第一个是它的weight

56
00:01:47,479 --> 00:01:50,439
它就是一个八乘一的一个东西

57
00:01:50,879 --> 00:01:54,439
然后它的偏移它的bias

58
00:01:54,719 --> 00:01:56,840
那就是一个标量了

59
00:01:57,000 --> 00:01:59,799
这就是说最后一层的

60
00:01:59,840 --> 00:02:01,760
它里面它的参数

61
00:02:02,079 --> 00:02:04,280
可以通过一个state的dict拿出来

62
00:02:07,920 --> 00:02:10,080
当然然后我们可以去直接访问

63
00:02:10,080 --> 00:02:11,520
某一个具体的参数

64
00:02:11,840 --> 00:02:14,800
比如说我们把最后一层的偏移

65
00:02:15,240 --> 00:02:16,000
它的偏移的

66
00:02:16,000 --> 00:02:18,680
首先我们看一下它的是什么类型

67
00:02:19,039 --> 00:02:20,719
它的类型是一个

68
00:02:20,960 --> 00:02:23,879
nn的parameter的一个parameter

69
00:02:23,879 --> 00:02:25,240
就是这个都是module

70
00:02:25,240 --> 00:02:27,159
核心的是它是一个parameter

71
00:02:27,200 --> 00:02:29,080
parameter定义的是一个

72
00:02:29,120 --> 00:02:32,040
可以优化的一个参数

73
00:02:33,680 --> 00:02:36,120
所以它的bios偏移就是一个parameter

74
00:02:36,480 --> 00:02:37,800
所以你把它打印一下

75
00:02:37,800 --> 00:02:39,400
就是说你直接把它打印的话

76
00:02:39,400 --> 00:02:40,080
它会告诉你

77
00:02:40,360 --> 00:02:41,360
这个parameter里面

78
00:02:43,000 --> 00:02:45,040
就有一个这样子的tensor

79
00:02:46,160 --> 00:02:46,840
这个东西

80
00:02:48,080 --> 00:02:50,240
这个东西我可以通过点data

81
00:02:50,240 --> 00:02:52,200
来真正的访问

82
00:02:52,360 --> 00:02:54,320
它的值

83
00:02:54,599 --> 00:02:55,479
它是点data

84
00:02:55,799 --> 00:02:57,680
所以它为什么是点data

85
00:02:58,039 --> 00:02:59,719
因为它还有个t度

86
00:03:00,439 --> 00:03:01,479
就是说你这个参数

87
00:03:01,479 --> 00:03:02,639
它其实点data

88
00:03:02,639 --> 00:03:03,919
就是参数的本身

89
00:03:04,079 --> 00:03:07,120
你可以通过点grad来访问它的t度

90
00:03:07,599 --> 00:03:07,959
就是说

91
00:03:08,639 --> 00:03:09,599
Net还是这样子

92
00:03:09,599 --> 00:03:11,400
最后一个全连接层

93
00:03:11,519 --> 00:03:12,759
它的点weight

94
00:03:13,120 --> 00:03:14,039
它的grad

95
00:03:14,079 --> 00:03:16,359
就是点data是访问它的weight

96
00:03:16,400 --> 00:03:18,000
点grad是访问它的t度

97
00:03:18,359 --> 00:03:19,439
这里我们还没有计算

98
00:03:19,599 --> 00:03:22,120
所以我们还没有做反向计算

99
00:03:22,120 --> 00:03:24,599
所以grad是等于none的

100
00:03:25,719 --> 00:03:27,960
但是我们之后做了back

101
00:03:28,200 --> 00:03:29,200
what之后

102
00:03:29,200 --> 00:03:31,120
就可以grad就可以访问元素了

103
00:03:35,920 --> 00:03:36,400
好

104
00:03:38,280 --> 00:03:40,040
我们另外还有办法

105
00:03:40,040 --> 00:03:43,360
就是说我们可以把整个所有网络的

106
00:03:43,360 --> 00:03:44,960
parameter全部拿出来

107
00:03:45,280 --> 00:03:47,800
它可以通过nand parameters这个参数

108
00:03:48,159 --> 00:03:51,120
首先我们拿到第一层的nand parameters

109
00:03:52,200 --> 00:03:53,879
就你看到它其实是说

110
00:03:54,240 --> 00:03:55,640
第一层它的nand parameters

111
00:03:55,640 --> 00:03:57,240
跟之前唯一的区别是说

112
00:03:57,280 --> 00:03:58,520
它首先拿到告诉你

113
00:03:58,520 --> 00:04:02,360
这是一个字符串的名字

114
00:04:02,360 --> 00:04:02,960
叫weight

115
00:04:02,960 --> 00:04:03,920
bias

116
00:04:04,200 --> 00:04:05,560
同样的情况是说

117
00:04:05,599 --> 00:04:07,920
我可以拿到net的nand parameters

118
00:04:07,960 --> 00:04:09,680
就是把整个网络的

119
00:04:09,719 --> 00:04:11,159
parameters全部拿出来

120
00:04:11,520 --> 00:04:12,120
可以看到

121
00:04:12,120 --> 00:04:14,240
因为我们有两个全连接层

122
00:04:14,719 --> 00:04:17,319
所以我们第一个就是

123
00:04:17,360 --> 00:04:18,639
第一层叫做0

124
00:04:19,040 --> 00:04:21,280
所以这个是0点它的什么

125
00:04:21,280 --> 00:04:22,920
0就是它的layer的名字

126
00:04:23,320 --> 00:04:25,600
0.weight 0.bias

127
00:04:25,880 --> 00:04:26,760
接下来是2

128
00:04:26,760 --> 00:04:29,440
因为第一就是relu

129
00:04:29,440 --> 00:04:30,520
relu是没有参数的

130
00:04:30,520 --> 00:04:31,480
所以是拿不出来的

131
00:04:31,600 --> 00:04:34,400
所以2就是它最后一个全连接层的名字

132
00:04:34,440 --> 00:04:36,200
0.weight 0.bias

133
00:04:36,560 --> 00:04:37,360
就是说

134
00:04:37,520 --> 00:04:39,600
nand parameters可以拿出

135
00:04:39,840 --> 00:04:41,080
字符串名字

136
00:04:41,120 --> 00:04:45,160
到一个parameters的一个东西

137
00:04:45,200 --> 00:04:46,840
然后我们这打印的是shape了

138
00:04:46,840 --> 00:04:48,760
所以你看到它的shape的形状

139
00:04:50,160 --> 00:04:50,840
同样的话

140
00:04:50,840 --> 00:04:52,840
我们可以通过这个名字

141
00:04:52,840 --> 00:04:54,400
我们有名字之后

142
00:04:54,440 --> 00:04:57,400
我们可以通过名字来获取我们要的参数

143
00:04:57,600 --> 00:04:58,640
比如说我们就把

144
00:04:59,240 --> 00:04:59,840
还是一样的

145
00:04:59,840 --> 00:05:00,920
state dict

146
00:05:01,120 --> 00:05:02,120
拿出来

147
00:05:02,160 --> 00:05:03,400
通过给你一个

148
00:05:03,560 --> 00:05:04,480
字符串的名字

149
00:05:04,480 --> 00:05:06,760
就是最后一个的偏移

150
00:05:06,800 --> 00:05:07,600
可以拿到data

151
00:05:07,600 --> 00:05:10,240
就是访问我们最后一层的偏移

152
00:05:14,920 --> 00:05:15,800
然后我们看一下

153
00:05:15,840 --> 00:05:17,520
假设我们整个网络

154
00:05:17,520 --> 00:05:19,320
有嵌套的时候会怎么样

155
00:05:19,839 --> 00:05:21,079
我们这里定一个

156
00:05:21,079 --> 00:05:22,560
跟之前有点像的一个东西

157
00:05:23,240 --> 00:05:24,599
首先我们定一个block

158
00:05:24,800 --> 00:05:25,439
这个block

159
00:05:25,599 --> 00:05:27,319
它就是一个sequential的一个东西

160
00:05:27,480 --> 00:05:28,920
它有两个线性层

161
00:05:28,920 --> 00:05:30,199
就跟我们之前是一样的

162
00:05:30,519 --> 00:05:31,719
我的block2是干嘛

163
00:05:31,959 --> 00:05:34,839
block2也是一个sequential东西

164
00:05:34,879 --> 00:05:38,159
但是我们插入4个block1

165
00:05:38,560 --> 00:05:39,839
就每次我们掉

166
00:05:40,199 --> 00:05:41,279
是这一个函数

167
00:05:41,279 --> 00:05:42,399
就add module

168
00:05:42,519 --> 00:05:44,639
add module跟之前就是说

169
00:05:45,360 --> 00:05:47,600
把这个东西放在sequential里面的

170
00:05:47,600 --> 00:05:49,079
唯一的区别是说

171
00:05:49,079 --> 00:05:51,759
我这样子可以传一个字符串的

172
00:05:51,919 --> 00:05:52,959
名字给你

173
00:05:52,959 --> 00:05:53,319
这样子

174
00:05:53,319 --> 00:05:55,319
你就不要告诉我是01234了

175
00:05:55,359 --> 00:05:56,199
这样子我就可以说

176
00:05:56,399 --> 00:05:57,399
这是block0

177
00:05:57,399 --> 00:05:57,919
block1

178
00:05:57,919 --> 00:05:58,399
block2

179
00:05:58,399 --> 00:05:59,839
就是给你一个字符串名字

180
00:05:59,959 --> 00:06:01,199
功能是一样的

181
00:06:02,560 --> 00:06:06,479
所以block2就是会嵌套4个block1

182
00:06:07,120 --> 00:06:08,560
最后的是一个

183
00:06:08,599 --> 00:06:10,759
我们再在外面套一层sequential

184
00:06:10,799 --> 00:06:12,000
就是给一个block2

185
00:06:12,039 --> 00:06:12,959
给一个linear

186
00:06:13,560 --> 00:06:14,439
然后我们来看一下

187
00:06:14,439 --> 00:06:16,680
我们是在内部

188
00:06:16,680 --> 00:06:19,160
它是怎么表示这样子的参数的

189
00:06:21,879 --> 00:06:24,680
我们假设把我们就把这个东西print出来

190
00:06:25,040 --> 00:06:26,120
print这个net

191
00:06:26,120 --> 00:06:27,680
就会把几乎上

192
00:06:27,879 --> 00:06:28,960
用字符串的形式

193
00:06:28,960 --> 00:06:30,280
把你这个东西打印出来

194
00:06:30,600 --> 00:06:32,840
首先它外层是一个sequential

195
00:06:32,840 --> 00:06:33,319
对吧

196
00:06:34,040 --> 00:06:35,519
然后sequential第一个

197
00:06:35,519 --> 00:06:36,639
第0个元素

198
00:06:36,639 --> 00:06:38,240
它也是一个sequential的东西

199
00:06:38,840 --> 00:06:40,160
是我们的block2

200
00:06:40,399 --> 00:06:42,199
block2也是一个sequential的

201
00:06:42,199 --> 00:06:42,680
对吧

202
00:06:42,759 --> 00:06:45,040
它里面就含了一个block1

203
00:06:45,079 --> 00:06:46,199
就第一个block1

204
00:06:46,199 --> 00:06:46,800
block0

205
00:06:46,800 --> 00:06:49,039
这个是我们传进去的

206
00:06:49,240 --> 00:06:50,599
这是我们传进去的字符串

207
00:06:50,639 --> 00:06:51,759
可以看到block0

208
00:06:51,759 --> 00:06:52,959
就是一个sequential的

209
00:06:52,959 --> 00:06:54,000
也是一个sequential

210
00:06:54,000 --> 00:06:54,319
对吧

211
00:06:54,360 --> 00:06:56,039
它是三个sequential的嵌套

212
00:06:57,000 --> 00:06:57,920
然后可以看到

213
00:06:57,959 --> 00:06:59,439
block0里面第0个

214
00:06:59,439 --> 00:07:00,439
就是linear层

215
00:07:00,439 --> 00:07:01,000
relue

216
00:07:01,000 --> 00:07:01,680
linear

217
00:07:01,839 --> 00:07:03,039
最后是一个relue

218
00:07:03,360 --> 00:07:04,279
然后同样的话

219
00:07:04,279 --> 00:07:05,399
我们block2

220
00:07:05,399 --> 00:07:07,519
就是这一个嵌套层

221
00:07:07,639 --> 00:07:09,319
然后可以看到是有这个东西

222
00:07:09,319 --> 00:07:10,039
有这个东西

223
00:07:10,159 --> 00:07:10,639
对吧

224
00:07:10,839 --> 00:07:12,439
所以基本上是说

225
00:07:12,480 --> 00:07:13,839
你可以通过print

226
00:07:13,880 --> 00:07:15,880
大概能大致的了解

227
00:07:15,880 --> 00:07:17,600
我们整个网络长什么样子

228
00:07:18,200 --> 00:07:19,200
当然是说

229
00:07:19,200 --> 00:07:21,040
这里是一个比较简单的网络了

230
00:07:21,200 --> 00:07:22,960
假设你要做的比较复杂的

231
00:07:22,960 --> 00:07:23,720
网络的话

232
00:07:23,760 --> 00:07:25,720
你print可能就没那么方便

233
00:07:25,760 --> 00:07:27,880
所以你只能按

234
00:07:29,120 --> 00:07:30,560
按照一块一块来做

235
00:07:31,040 --> 00:07:31,640
另外的话

236
00:07:31,640 --> 00:07:33,120
你可以看到的好处是说

237
00:07:33,160 --> 00:07:35,480
如果你能把复杂的网络

238
00:07:35,480 --> 00:07:37,000
组合成这样子的块模

239
00:07:37,000 --> 00:07:37,880
块化的话

240
00:07:37,920 --> 00:07:39,400
这样子你在打印上

241
00:07:39,680 --> 00:07:42,000
在访问上也会有好处

242
00:07:44,840 --> 00:07:46,480
另外一个是说

243
00:07:47,360 --> 00:07:50,040
我们怎么样初始我们的参数

244
00:07:50,080 --> 00:07:51,160
我们之前讲的是

245
00:07:51,160 --> 00:07:53,680
怎么样访问我们的权重

246
00:07:53,920 --> 00:07:55,000
访问我们的片语

247
00:07:55,040 --> 00:07:58,320
接下来说我们怎么样去修改

248
00:07:58,320 --> 00:07:59,760
默认的初始函数

249
00:07:59,760 --> 00:08:01,320
来获得我们的新的

250
00:08:01,560 --> 00:08:03,640
其实我们之前已经用过这些东西了

251
00:08:03,640 --> 00:08:05,400
我们再给大家回顾一下

252
00:08:06,960 --> 00:08:08,360
首先我们定了一个函数

253
00:08:08,360 --> 00:08:09,680
第一个函数是说

254
00:08:09,720 --> 00:08:11,400
我们把所有的

255
00:08:12,120 --> 00:08:13,400
印列成一个

256
00:08:13,920 --> 00:08:15,400
normal distribution

257
00:08:15,440 --> 00:08:17,000
就是我们的正常分布

258
00:08:17,520 --> 00:08:18,720
所以我们定一个函数

259
00:08:19,000 --> 00:08:19,880
定一个M

260
00:08:19,880 --> 00:08:21,000
M就是一个module

261
00:08:21,000 --> 00:08:22,840
所以每次它会传入一个module

262
00:08:23,960 --> 00:08:25,080
然后我们去看

263
00:08:25,120 --> 00:08:26,240
所以如果这个module

264
00:08:26,240 --> 00:08:27,880
是一个线性类的话

265
00:08:28,240 --> 00:08:30,000
如果type的module是线性

266
00:08:30,000 --> 00:08:31,360
就是全连接层的话

267
00:08:31,400 --> 00:08:32,360
那我们就干这个事情

268
00:08:32,360 --> 00:08:33,000
如果不是的话

269
00:08:33,000 --> 00:08:33,800
我们就不管了

270
00:08:34,400 --> 00:08:36,040
如果是全连接层的话

271
00:08:36,080 --> 00:08:38,080
那我们就对它的weights

272
00:08:38,080 --> 00:08:41,000
做均值为0

273
00:08:41,040 --> 00:08:43,120
方常为0.01的一个初始化

274
00:08:43,400 --> 00:08:46,720
然后normal下滑线的意思

275
00:08:46,720 --> 00:08:47,840
就是下滑线接在后面

276
00:08:47,840 --> 00:08:49,920
就是一个他自己的一个写法

277
00:08:49,920 --> 00:08:52,480
就是说是表示是一个替换函数

278
00:08:52,680 --> 00:08:54,400
就是他不是会返回一个值

279
00:08:54,400 --> 00:08:55,480
他就会把这个东西

280
00:08:55,480 --> 00:08:56,920
可以直接给替换掉

281
00:08:58,160 --> 00:08:58,960
那bias的话

282
00:08:58,960 --> 00:09:00,360
我们就直接-0了

283
00:09:00,639 --> 00:09:01,759
就是说所有这些函数

284
00:09:01,759 --> 00:09:03,920
都在init module里面

285
00:09:03,960 --> 00:09:05,160
就init module里面

286
00:09:05,199 --> 00:09:06,839
包含了大量的

287
00:09:07,519 --> 00:09:09,360
可以用来做初始化的一些函数

288
00:09:09,519 --> 00:09:11,759
我们再调用到normal和0

289
00:09:12,799 --> 00:09:14,120
然后我们点net

290
00:09:14,120 --> 00:09:15,799
点apply这个函数

291
00:09:16,319 --> 00:09:17,319
就apply这个函数

292
00:09:17,319 --> 00:09:18,120
是什么意思呢

293
00:09:18,159 --> 00:09:18,879
就是说

294
00:09:18,879 --> 00:09:21,399
对于所有net里面的那些layer

295
00:09:21,719 --> 00:09:24,559
然后我就是一个一个一个for loop

296
00:09:25,120 --> 00:09:27,079
然后把它

297
00:09:27,279 --> 00:09:29,639
就是对net里面所有的module

298
00:09:29,720 --> 00:09:30,839
去调用这个函数

299
00:09:30,839 --> 00:09:32,000
然后把这个module

300
00:09:32,039 --> 00:09:33,120
作为参数

301
00:09:33,120 --> 00:09:34,039
传入进去

302
00:09:34,519 --> 00:09:35,719
就是便利一遍

303
00:09:36,279 --> 00:09:37,599
假设你是嵌套的话

304
00:09:37,599 --> 00:09:38,879
那就会嵌套便利

305
00:09:38,879 --> 00:09:39,319
对吧

306
00:09:40,679 --> 00:09:41,120
OK

307
00:09:41,120 --> 00:09:42,360
这是apply的

308
00:09:42,639 --> 00:09:43,079
干的事情

309
00:09:43,079 --> 00:09:43,559
当然apply

310
00:09:43,559 --> 00:09:44,919
你可以apply任何别的东西

311
00:09:44,919 --> 00:09:45,159
对吧

312
00:09:45,159 --> 00:09:46,519
你可以做干点别的事情

313
00:09:46,519 --> 00:09:47,120
就是说

314
00:09:47,120 --> 00:09:48,360
他给你一个方式

315
00:09:48,360 --> 00:09:50,120
让你便利整个神级网络

316
00:09:50,120 --> 00:09:51,279
让他做一些修改

317
00:09:51,439 --> 00:09:53,360
这也是我们CS里面

318
00:09:53,360 --> 00:09:54,519
经常用的一个

319
00:09:54,559 --> 00:09:55,839
函数API

320
00:09:56,639 --> 00:09:58,000
当然你可以看到是说

321
00:09:58,039 --> 00:09:59,679
便利过之后

322
00:09:59,919 --> 00:10:01,439
你看到我们的参数

323
00:10:01,560 --> 00:10:03,880
就应该是被初始成一个

324
00:10:03,920 --> 00:10:05,480
当然你看也看不出来

325
00:10:05,480 --> 00:10:05,720
对吧

326
00:10:05,720 --> 00:10:07,120
你就假设它就是一个

327
00:10:07,480 --> 00:10:08,680
正常分布了

328
00:10:08,920 --> 00:10:10,680
它的偏移当然是一个0

329
00:10:12,320 --> 00:10:14,000
那你可以做任何的别的事情

330
00:10:14,000 --> 00:10:14,720
比如说

331
00:10:15,120 --> 00:10:16,760
这里我们把它的

332
00:10:16,800 --> 00:10:18,440
初始成一个constant

333
00:10:18,680 --> 00:10:20,000
就跟之前都一样

334
00:10:20,200 --> 00:10:21,920
就是唯一的区别是说

335
00:10:21,960 --> 00:10:23,000
我们的weight

336
00:10:23,160 --> 00:10:25,560
被它init成一个constant

337
00:10:25,560 --> 00:10:26,800
唯一的一个区别

338
00:10:27,400 --> 00:10:28,400
就是唯一好像是

339
00:10:28,400 --> 00:10:29,400
不这里不一样

340
00:10:30,000 --> 00:10:32,480
那么这个地方可以看到是

341
00:10:33,000 --> 00:10:34,039
跟前面不一样的地方

342
00:10:34,039 --> 00:10:34,720
就是说

343
00:10:34,720 --> 00:10:35,439
我们的weight

344
00:10:35,439 --> 00:10:36,519
全部变成1了

345
00:10:36,840 --> 00:10:39,079
虽然你不应该这么干

346
00:10:39,079 --> 00:10:40,399
就是说给大家

347
00:10:40,879 --> 00:10:41,559
展示一下

348
00:10:41,559 --> 00:10:42,799
你是可以这么做的

349
00:10:42,799 --> 00:10:43,439
就是说

350
00:10:44,279 --> 00:10:45,319
从API的角度来讲

351
00:10:45,319 --> 00:10:45,879
你可以做

352
00:10:45,879 --> 00:10:47,720
但是从算法角度来讲

353
00:10:47,720 --> 00:10:48,720
你不应该这么做

354
00:10:49,079 --> 00:10:50,519
还是我们从来没有

355
00:10:50,519 --> 00:10:52,319
我们告诉大家不能这么做

356
00:10:52,319 --> 00:10:53,559
但我们从来没说过为什么

357
00:10:53,559 --> 00:10:54,480
大家可以想一想

358
00:10:54,480 --> 00:10:55,240
作为练习题

359
00:10:55,240 --> 00:10:56,639
就是为什么你不能把

360
00:10:56,799 --> 00:10:59,360
weight全部初始化成常数

361
00:10:59,399 --> 00:11:04,079
就是说

362
00:11:04,079 --> 00:11:05,319
另外一个是说

363
00:11:05,319 --> 00:11:07,279
apply这个函数

364
00:11:07,279 --> 00:11:08,559
它是一个module

365
00:11:08,559 --> 00:11:10,120
它自己定义的一个函数

366
00:11:10,120 --> 00:11:12,279
你可以对不同的层

367
00:11:12,279 --> 00:11:13,480
apply不同的事情

368
00:11:13,639 --> 00:11:14,480
比如说

369
00:11:14,840 --> 00:11:15,759
这里说

370
00:11:15,759 --> 00:11:17,759
有xv这个函数

371
00:11:17,759 --> 00:11:18,720
我们之前

372
00:11:18,759 --> 00:11:20,559
我们上一次有介绍

373
00:11:20,559 --> 00:11:21,759
xv怎么初始化

374
00:11:22,120 --> 00:11:23,480
它这里使用的xv

375
00:11:23,480 --> 00:11:24,679
uniform

376
00:11:24,679 --> 00:11:25,480
就是用

377
00:11:26,319 --> 00:11:27,799
应该是uniform distribution

378
00:11:27,800 --> 00:11:29,560
来做xv的初始化

379
00:11:29,560 --> 00:11:31,480
另外一个还是一个xv normal

380
00:11:31,480 --> 00:11:32,680
就我们两个都讲过

381
00:11:32,680 --> 00:11:34,040
之前大家如果

382
00:11:34,720 --> 00:11:35,280
不记得了

383
00:11:35,280 --> 00:11:36,120
就可以回去看一下

384
00:11:36,120 --> 00:11:37,320
我们的录像

385
00:11:38,160 --> 00:11:39,320
就是说这个函数

386
00:11:39,320 --> 00:11:40,560
就是说对于weights

387
00:11:40,560 --> 00:11:42,320
做我们的xv初始化

388
00:11:42,520 --> 00:11:44,400
另外一个就是一个更简单的

389
00:11:44,400 --> 00:11:45,480
就是说我们把

390
00:11:46,240 --> 00:11:48,000
优化成常数42

391
00:11:48,000 --> 00:11:49,560
42大家知道吧

392
00:11:49,560 --> 00:11:50,840
这是宇宙的答案

393
00:11:51,280 --> 00:11:52,680
是银河西班牙指南的

394
00:11:52,680 --> 00:11:53,440
里面的一个梗

395
00:11:53,440 --> 00:11:54,520
这是宇宙的答案

396
00:11:54,520 --> 00:11:55,400
所以42

397
00:11:56,399 --> 00:11:58,120
扯远一点

398
00:11:58,120 --> 00:11:58,679
我们

399
00:11:58,840 --> 00:12:00,519
我当时13年

400
00:12:00,519 --> 00:12:02,159
在Google实习的时候

401
00:12:02,399 --> 00:12:03,759
Google刚成立Google brand

402
00:12:03,759 --> 00:12:04,360
那个团队

403
00:12:04,360 --> 00:12:06,039
是做Tensorflow团队

404
00:12:06,079 --> 00:12:07,559
那时候在42栋楼

405
00:12:07,559 --> 00:12:08,399
所以为什么这个楼

406
00:12:08,399 --> 00:12:09,879
就是我们要在宇宙的答案

407
00:12:09,879 --> 00:12:11,639
这栋楼来寻找宇宙的答案

408
00:12:11,639 --> 00:12:13,279
挺好玩的

409
00:12:14,159 --> 00:12:16,360
然后这里的意思是说

410
00:12:16,360 --> 00:12:18,120
假设我们有两个初始函数

411
00:12:18,120 --> 00:12:19,079
我们可以说

412
00:12:19,079 --> 00:12:21,840
我们第一个线性全连接层

413
00:12:22,079 --> 00:12:23,720
用xv这个初始化

414
00:12:24,279 --> 00:12:25,680
第二最后一个

415
00:12:25,720 --> 00:12:27,720
用的是unit42初始化

416
00:12:27,840 --> 00:12:28,840
然后你去访问的话

417
00:12:28,840 --> 00:12:29,639
当然是说

418
00:12:30,360 --> 00:12:31,320
第一个层

419
00:12:31,360 --> 00:12:32,759
它的就是一个

420
00:12:33,560 --> 00:12:34,800
xv的一个初始

421
00:12:34,800 --> 00:12:36,320
就是这个均匀分布

422
00:12:36,399 --> 00:12:38,200
如果是最后一层的话

423
00:12:38,200 --> 00:12:40,000
你的weight就全是42了

424
00:12:40,120 --> 00:12:40,800
就是说

425
00:12:41,120 --> 00:12:43,000
因为就是说你的network

426
00:12:43,000 --> 00:12:44,120
你不管是里面的

427
00:12:44,120 --> 00:12:44,680
还是外面的

428
00:12:44,680 --> 00:12:46,120
它都是一个模具

429
00:12:46,120 --> 00:12:48,200
所以你可以对任何一个层

430
00:12:48,200 --> 00:12:49,800
都要用apply这个函数

431
00:12:50,920 --> 00:12:52,160
OK这个就是说

432
00:12:52,159 --> 00:12:53,480
对不同的层

433
00:12:53,480 --> 00:12:55,319
使用不同的初始化函数

434
00:12:58,439 --> 00:12:59,719
那你还可以做

435
00:12:59,759 --> 00:13:02,799
更加奇怪的一些操作了

436
00:13:02,959 --> 00:13:04,240
就是说你不用

437
00:13:04,360 --> 00:13:06,159
n的unit都行

438
00:13:06,159 --> 00:13:06,959
就是说你

439
00:13:07,159 --> 00:13:07,959
反正你是写了

440
00:13:08,159 --> 00:13:08,839
unit的函数

441
00:13:09,240 --> 00:13:10,879
就是你具体里面怎么搞

442
00:13:10,879 --> 00:13:12,879
当然是你自己说了算

443
00:13:13,000 --> 00:13:14,120
所以这个地方

444
00:13:14,120 --> 00:13:15,159
我们自定义了一个

445
00:13:15,159 --> 00:13:16,399
自定义一个函数

446
00:13:16,439 --> 00:13:18,120
就是说我们先print一下

447
00:13:18,600 --> 00:13:20,480
我们说我们把这个东西给

448
00:13:20,600 --> 00:13:22,399
我说我们要开始初始化了

449
00:13:22,440 --> 00:13:24,600
它的名字是谁

450
00:13:24,960 --> 00:13:26,600
它的形状是什么

451
00:13:26,639 --> 00:13:28,720
然后对整个module里面的东西

452
00:13:29,519 --> 00:13:30,480
然后我们再

453
00:13:31,480 --> 00:13:32,639
均匀初始化

454
00:13:33,000 --> 00:13:34,840
然后我们又把它

455
00:13:35,440 --> 00:13:37,080
跟它的

456
00:13:37,680 --> 00:13:38,560
就是说

457
00:13:41,000 --> 00:13:42,960
它乘以它是不是

458
00:13:42,960 --> 00:13:45,600
它的绝对值大于等于5

459
00:13:46,080 --> 00:13:47,360
就如果不是的话

460
00:13:47,360 --> 00:13:48,039
那就怎么办

461
00:13:48,039 --> 00:13:49,240
不是的话就变零了

462
00:13:49,240 --> 00:13:49,800
是不是

463
00:13:49,800 --> 00:13:51,360
就是说这里的意思是说

464
00:13:51,400 --> 00:13:54,000
我保留绝对值

465
00:13:54,040 --> 00:13:56,240
大于5的那些

466
00:13:57,160 --> 00:13:57,920
权重

467
00:13:58,200 --> 00:13:59,640
不是的话我就设成零

468
00:13:59,640 --> 00:14:01,160
就在这就干这个事情

469
00:14:02,160 --> 00:14:04,760
所以你然后你当然你可以运行它的话

470
00:14:04,760 --> 00:14:05,760
就是apply它的话

471
00:14:05,760 --> 00:14:06,280
你会看到

472
00:14:06,280 --> 00:14:07,520
首先我print的一些东西

473
00:14:07,520 --> 00:14:10,120
这是给这基本上是一些debug信息了

474
00:14:11,320 --> 00:14:15,000
然后我再看说我们的tensor

475
00:14:15,160 --> 00:14:16,880
那就是说里面很多零在里面了

476
00:14:16,880 --> 00:14:19,040
因为如果是小于绝对值

477
00:14:19,039 --> 00:14:20,480
小于5的话

478
00:14:20,679 --> 00:14:21,799
全部变成零了

479
00:14:21,839 --> 00:14:22,879
这也是一个

480
00:14:23,039 --> 00:14:25,159
我也不知道具体肯定没什么用了

481
00:14:25,159 --> 00:14:26,199
我猜可能没什么用

482
00:14:26,199 --> 00:14:28,399
但是给大家展示一下是可以干的

483
00:14:30,679 --> 00:14:32,319
然后还有更简单

484
00:14:32,319 --> 00:14:33,639
更直接暴力的方法

485
00:14:33,639 --> 00:14:36,639
就是说你就直接去把net的

486
00:14:36,639 --> 00:14:38,000
.wait.data

487
00:14:38,000 --> 00:14:39,639
直接拿出来做替换了

488
00:14:41,120 --> 00:14:41,439
对吧

489
00:14:41,439 --> 00:14:43,919
就是说它的所有的值

490
00:14:43,959 --> 00:14:44,639
加1

491
00:14:44,959 --> 00:14:48,319
它的第一个元素等于42

492
00:14:48,600 --> 00:14:50,120
然后可以看到是说

493
00:14:50,879 --> 00:14:52,520
那把第一行看出来了

494
00:14:52,520 --> 00:14:55,080
就是说以前0就变成1了

495
00:14:55,120 --> 00:14:56,760
然后第一个元素变成42了

496
00:14:56,760 --> 00:14:58,760
就是说直接做替换也是可以的

497
00:15:00,440 --> 00:15:00,960
OK

498
00:15:02,560 --> 00:15:02,840
好

499
00:15:02,840 --> 00:15:04,360
最后来讲一个

500
00:15:05,840 --> 00:15:07,040
一个小应用

501
00:15:07,040 --> 00:15:08,680
就是说经常的时候

502
00:15:08,680 --> 00:15:10,440
我们在后面可以看到是说

503
00:15:10,440 --> 00:15:13,040
我们想在一些层之间

504
00:15:13,040 --> 00:15:14,760
share这个parameter

505
00:15:15,759 --> 00:15:17,759
通常来是说我要做

506
00:15:17,759 --> 00:15:19,039
有两个

507
00:15:19,039 --> 00:15:20,439
比如说有两个

508
00:15:20,480 --> 00:15:22,319
两个数据流进来

509
00:15:22,360 --> 00:15:23,600
我其中有一些层

510
00:15:23,600 --> 00:15:26,600
我是说我想共享这些权重

511
00:15:26,960 --> 00:15:28,439
共享的权重意思就是

512
00:15:28,439 --> 00:15:29,399
它就是一样的

513
00:15:30,159 --> 00:15:31,679
那怎么做一样呢

514
00:15:31,720 --> 00:15:34,399
这个地方可以叫做参数绑定

515
00:15:35,000 --> 00:15:36,919
就我要说我要把share的

516
00:15:36,919 --> 00:15:38,639
这一个层先构造出来

517
00:15:40,159 --> 00:15:41,559
那么构造这个事情的时候

518
00:15:41,560 --> 00:15:43,360
它就会把参数给你

519
00:15:43,640 --> 00:15:45,040
申请出来

520
00:15:45,800 --> 00:15:46,800
那么接下来

521
00:15:46,800 --> 00:15:48,720
我在定义我的权连接的时候

522
00:15:48,760 --> 00:15:50,000
我干的事情就是说

523
00:15:50,200 --> 00:15:52,080
第一个权连接层

524
00:15:52,200 --> 00:15:54,320
然后我是share的权连接层

525
00:15:54,880 --> 00:15:55,760
然后我再share

526
00:15:55,760 --> 00:15:57,160
就是说你可认为是说

527
00:15:57,160 --> 00:15:59,520
它的第二个隐藏层

528
00:16:00,400 --> 00:16:02,120
和第三个隐藏层

529
00:16:02,120 --> 00:16:04,160
它是一个share权重的

530
00:16:04,640 --> 00:16:06,520
就第一个和最后一个是自己的

531
00:16:08,560 --> 00:16:10,120
就是说理论上来说

532
00:16:10,120 --> 00:16:13,159
你不管怎么样更新这个network

533
00:16:13,279 --> 00:16:16,080
它的第二个和第三个层

534
00:16:16,120 --> 00:16:17,560
它理论上都是一样的

535
00:16:18,399 --> 00:16:19,159
我们可以看一下

536
00:16:19,320 --> 00:16:20,000
我们

537
00:16:22,399 --> 00:16:23,399
这里就是说

538
00:16:23,440 --> 00:16:26,639
你把它的第二层和第四层

539
00:16:26,679 --> 00:16:27,360
就是说

540
00:16:27,960 --> 00:16:29,919
记得第三就是review

541
00:16:29,919 --> 00:16:31,000
所以这是第四

542
00:16:31,799 --> 00:16:33,120
所以它应该是等于一样的

543
00:16:33,120 --> 00:16:34,919
print应该是等于全部是true的

544
00:16:35,440 --> 00:16:36,519
另外一个是说

545
00:16:36,519 --> 00:16:40,600
假设我把第一个weights

546
00:16:40,679 --> 00:16:43,439
它的第0号元素改成100的话

547
00:16:43,600 --> 00:16:45,399
那么我同样会把

548
00:16:46,159 --> 00:16:48,199
share的层也的weights也改掉了

549
00:16:49,279 --> 00:16:49,559
对吧

550
00:16:49,559 --> 00:16:52,199
因为它其实它指向的是同一个

551
00:16:52,879 --> 00:16:56,039
同一个primary这个类的实例

552
00:16:56,039 --> 00:16:58,120
所以你改了一个会改另外一个

553
00:16:58,120 --> 00:16:59,039
这就是一个

554
00:16:59,079 --> 00:17:01,480
如何在不同的网络之间

555
00:17:01,480 --> 00:17:03,000
共享权重的一个方法

556
00:17:03,840 --> 00:17:04,160
好

557
00:17:04,160 --> 00:17:09,160
这就是怎么样去访问一个网络里面的

558
00:17:09,160 --> 00:17:09,920
参数

559
00:17:10,040 --> 00:17:13,400
以及怎么样去做一些初始化

560
00:17:13,440 --> 00:17:16,279
和你甚至是说可以构造说

561
00:17:16,279 --> 00:17:19,279
每个层之间可以共享参数

