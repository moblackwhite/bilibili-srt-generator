1
00:00:00,000 --> 00:00:00,640
运行一下

2
00:00:00,660 --> 00:00:04,360
首先我们要import PyTorch

3
00:00:04,360 --> 00:00:06,080
就是我们叫做PyTorch

4
00:00:06,080 --> 00:00:08,400
但实际上导入的是Torch

5
00:00:08,400 --> 00:00:09,279
就是Python

6
00:00:09,279 --> 00:00:11,120
就是说大家可能不要去

7
00:00:11,120 --> 00:00:13,480
在安装的时候也要去安装Torch

8
00:00:13,480 --> 00:00:14,800
不要去安装PyTorch

9
00:00:14,800 --> 00:00:16,800
在import的时候也要importTorch

10
00:00:17,400 --> 00:00:18,600
然后我们来运行

11
00:00:19,480 --> 00:00:22,640
如果是大家如果是第一次用Jupyter的话

12
00:00:22,640 --> 00:00:25,320
你运行的话会在这个地方有个运行

13
00:00:25,679 --> 00:00:27,440
大家可以按一下这个地方做运行

14
00:00:27,839 --> 00:00:29,480
我们这里我是用快捷键

15
00:00:29,480 --> 00:00:31,760
直接是control加回车

16
00:00:31,760 --> 00:00:33,600
我们就直接走了

17
00:00:34,800 --> 00:00:35,280
Ok

18
00:00:37,200 --> 00:00:42,280
说张亮表示的是一个数值组成的数组

19
00:00:42,560 --> 00:00:44,040
这个数组可以有很多维度

20
00:00:44,200 --> 00:00:44,880
我们举个例子

21
00:00:44,880 --> 00:00:48,120
是说在Torch里面生成a range

22
00:00:48,120 --> 00:00:49,439
就是从0到12

23
00:00:49,439 --> 00:00:51,760
我们把所有的0到12之间

24
00:00:51,760 --> 00:00:54,880
从0开始到12前的11结束的

25
00:00:54,880 --> 00:00:56,680
所有的东西拿出来

26
00:00:56,799 --> 00:01:01,159
就是一个从01234一直到11的一个东西

27
00:01:01,159 --> 00:01:02,159
它是一个向量

28
00:01:02,159 --> 00:01:04,640
就是我们把x复制给x

29
00:01:04,640 --> 00:01:06,079
然后把xprint出来

30
00:01:06,280 --> 00:01:07,200
我们可以运行一下

31
00:01:07,319 --> 00:01:08,599
我们可以重新运行一下

32
00:01:11,760 --> 00:01:16,879
我们可以通过它的shape来访问张亮的形状

33
00:01:17,319 --> 00:01:18,599
你x.shape

34
00:01:18,960 --> 00:01:21,240
你看到是一个它是一个向量

35
00:01:21,400 --> 00:01:22,519
它就是一个维度

36
00:01:22,519 --> 00:01:24,960
就是说这个维度的长为12

37
00:01:25,360 --> 00:01:29,480
它是一个元素为1的一个数组

38
00:01:30,320 --> 00:01:34,360
然后它的number of elements

39
00:01:34,360 --> 00:01:36,160
就是说你里面元素的总数

40
00:01:36,160 --> 00:01:37,360
它永远是一个标量

41
00:01:37,360 --> 00:01:38,240
就是12

42
00:01:40,200 --> 00:01:40,800
Ok

43
00:01:42,160 --> 00:01:45,960
然后如果我们想改变一个数组

44
00:01:45,960 --> 00:01:47,600
或者一个张亮的形状

45
00:01:47,600 --> 00:01:50,720
但不改变元素的数量和元素值的话

46
00:01:50,720 --> 00:01:52,520
我们可以用reshape这个函数

47
00:01:52,760 --> 00:01:54,600
就把它重新改成

48
00:01:54,600 --> 00:01:56,320
刚刚我们是以12个元素

49
00:01:56,320 --> 00:01:56,640
对吧

50
00:01:56,640 --> 00:01:58,080
长为12的向量

51
00:01:58,200 --> 00:02:00,920
然后我们可以把它reshape成3和4

52
00:02:00,960 --> 00:02:02,920
就是有三行和四列

53
00:02:03,360 --> 00:02:06,640
看到是说它是元素是从01234

54
00:02:06,640 --> 00:02:09,080
就是说它在每一行是连续的

55
00:02:09,120 --> 00:02:11,760
然后把它掐成三行

56
00:02:11,879 --> 00:02:14,680
这样子我们就是说在0123

57
00:02:14,680 --> 00:02:16,960
然后这样子一个3乘4的一个矩阵

58
00:02:20,600 --> 00:02:21,960
当然我们可以是说

59
00:02:21,960 --> 00:02:25,480
我们可以创建一些全0的一些函数

60
00:02:25,480 --> 00:02:28,320
就是给形状是234

61
00:02:28,760 --> 00:02:29,920
元素为全0

62
00:02:29,960 --> 00:02:31,920
然后当然是我们可以元素为全1

63
00:02:31,920 --> 00:02:32,360
对吧

64
00:02:32,360 --> 00:02:33,360
我们放小一点

65
00:02:33,360 --> 00:02:34,760
可以看到元素为全1

66
00:02:34,760 --> 00:02:36,319
就是形状是234

67
00:02:40,360 --> 00:02:42,719
如果我们想说告诉你说

68
00:02:42,719 --> 00:02:44,240
我要特定的一些值

69
00:02:44,240 --> 00:02:47,280
我也可以通过一个python的列表来复制

70
00:02:47,439 --> 00:02:50,400
我们这里再创建一个二维的一个数组

71
00:02:50,640 --> 00:02:53,760
这个告诉你是第一行的元素是2143

72
00:02:54,120 --> 00:02:55,960
第二行的元素是1234

73
00:02:56,319 --> 00:02:59,240
然后第三行的元素是4321

74
00:02:59,719 --> 00:03:01,960
然后这是一个列表

75
00:03:01,960 --> 00:03:03,360
然后列表嵌套列表

76
00:03:03,360 --> 00:03:05,560
就是一个list of list

77
00:03:05,719 --> 00:03:07,800
这样子我会创建一个二维的东西出来

78
00:03:08,200 --> 00:03:09,360
这是一个二维的数字

79
00:03:09,360 --> 00:03:10,800
当然我可以创造一个三维

80
00:03:10,800 --> 00:03:11,080
对吧

81
00:03:11,080 --> 00:03:12,360
我再打一个框

82
00:03:12,400 --> 00:03:14,480
放括号就会变成一个三维的数字

83
00:03:15,040 --> 00:03:16,280
你看到这是一个

84
00:03:16,920 --> 00:03:18,200
你可以有两个括在这里

85
00:03:18,200 --> 00:03:18,480
对吧

86
00:03:18,480 --> 00:03:20,319
如果我打印它的shape的话

87
00:03:20,400 --> 00:03:22,599
看到是说也是一个三维的

88
00:03:22,599 --> 00:03:23,680
是134

89
00:03:25,199 --> 00:03:25,759
OK

90
00:03:28,239 --> 00:03:30,319
当然是说我能创建数组的

91
00:03:30,319 --> 00:03:33,959
我可以做一些比较常见的标准

92
00:03:34,000 --> 00:03:35,079
算数运算

93
00:03:35,159 --> 00:03:37,400
加减乘除和指数

94
00:03:37,840 --> 00:03:40,400
所以所有的这些运算都是按元素进行了

95
00:03:40,919 --> 00:03:44,439
所以我们先比如说我们创建一个1

96
00:03:44,479 --> 00:03:45,879
我们特别给了一个1.0

97
00:03:45,879 --> 00:03:46,879
就是说这样子

98
00:03:46,879 --> 00:03:48,479
我们创建的是一个浮点运算

99
00:03:48,720 --> 00:03:50,080
一个浮点的

100
00:03:50,080 --> 00:03:50,760
不是浮点运算

101
00:03:50,760 --> 00:03:53,320
一个浮点的元素的数组

102
00:03:53,880 --> 00:03:54,840
就是如果你不

103
00:03:54,840 --> 00:03:56,600
你把0.1去掉的话

104
00:03:56,600 --> 00:03:57,760
它变成整数了

105
00:03:57,800 --> 00:03:58,800
所以我们要浮点

106
00:03:59,520 --> 00:04:02,760
这是创建一个1248的

107
00:04:03,120 --> 00:04:05,200
然后这里会创建成一个整数

108
00:04:05,200 --> 00:04:05,760
其实

109
00:04:06,040 --> 00:04:08,000
然后我做x加y

110
00:04:08,000 --> 00:04:10,000
它就会按元素全部加起来

111
00:04:10,000 --> 00:04:11,960
你可以认为是3460

112
00:04:12,000 --> 00:04:12,920
然后做减法

113
00:04:12,920 --> 00:04:14,240
按元素做减法

114
00:04:14,320 --> 00:04:16,560
按元素做乘法

115
00:04:16,600 --> 00:04:18,280
按元素做除法

116
00:04:18,280 --> 00:04:19,800
然后按元素求幂

117
00:04:19,800 --> 00:04:22,880
就是对每一个x元素求二次方

118
00:04:23,480 --> 00:04:26,240
看到是1464

119
00:04:28,320 --> 00:04:30,200
但是说我还可以做更多计算

120
00:04:30,360 --> 00:04:31,680
就是说我可以做指数

121
00:04:31,800 --> 00:04:32,200
对吧

122
00:04:32,240 --> 00:04:33,640
就是说按元素来

123
00:04:33,880 --> 00:04:35,760
每个元素做一次指数的运算

124
00:04:39,240 --> 00:04:41,280
然后这个是标准运算

125
00:04:41,480 --> 00:04:43,480
然后我们要把可以做一些

126
00:04:43,520 --> 00:04:44,760
张量之间的

127
00:04:44,760 --> 00:04:47,520
或多元素组之间的一些操作

128
00:04:48,159 --> 00:04:49,599
比如说我们用一个

129
00:04:49,799 --> 00:04:50,879
我们还是一样的

130
00:04:50,879 --> 00:04:52,000
生成一个

131
00:04:52,039 --> 00:04:52,879
跟之前一样

132
00:04:52,879 --> 00:04:54,199
就是说生成一个

133
00:04:54,199 --> 00:04:55,560
从0到11的元素

134
00:04:55,560 --> 00:04:57,039
的常为12的向量

135
00:04:57,079 --> 00:04:58,599
把它reshape到34

136
00:04:58,639 --> 00:05:00,000
这里我们特别指定说

137
00:05:00,000 --> 00:05:01,279
你用float32

138
00:05:01,279 --> 00:05:04,279
就不要给我生成一个integer了

139
00:05:04,719 --> 00:05:06,799
然后y也是一个

140
00:05:07,479 --> 00:05:08,519
跟刚刚是一样的

141
00:05:08,519 --> 00:05:09,680
是一个34的一个

142
00:05:09,680 --> 00:05:12,719
跟他们两个的形状是一样的

143
00:05:13,199 --> 00:05:15,000
然后我们用concat

144
00:05:15,279 --> 00:05:16,279
我来放大一点

145
00:05:16,720 --> 00:05:18,800
防止你们用手机看不清楚的话

146
00:05:18,920 --> 00:05:21,000
就是说我把这两个元素

147
00:05:21,000 --> 00:05:22,160
合并在一起

148
00:05:22,480 --> 00:05:24,320
然后在第0位合并

149
00:05:24,920 --> 00:05:27,080
第0位就是在行

150
00:05:27,080 --> 00:05:29,080
就是你可以认为是在堆起来

151
00:05:29,960 --> 00:05:31,280
你看到是说

152
00:05:31,320 --> 00:05:32,080
这个就是说

153
00:05:32,080 --> 00:05:33,720
这是我们的第一个

154
00:05:33,760 --> 00:05:34,880
生成的x

155
00:05:35,160 --> 00:05:36,760
这是我们生成的y

156
00:05:37,280 --> 00:05:39,720
然后我们是在按行上面

157
00:05:39,720 --> 00:05:40,560
合并起来

158
00:05:40,920 --> 00:05:41,600
然后我们可以说

159
00:05:41,600 --> 00:05:42,800
dimension等于1

160
00:05:42,800 --> 00:05:43,800
就是按列

161
00:05:44,280 --> 00:05:44,960
就是说你可以看到

162
00:05:44,960 --> 00:05:46,439
是在每一行

163
00:05:46,720 --> 00:05:48,040
这是第一个元素的

164
00:05:48,040 --> 00:05:50,280
第一个x的第一行

165
00:05:50,319 --> 00:05:52,120
这是y的第一行

166
00:05:52,160 --> 00:05:53,879
然后依此类型

167
00:05:54,199 --> 00:05:55,160
把它拼起来

168
00:05:55,639 --> 00:05:56,639
如果你有三位的话

169
00:05:56,639 --> 00:05:58,040
你可以dimension等于2

170
00:05:58,439 --> 00:05:58,960
对吧

171
00:05:58,960 --> 00:06:00,120
大家可以去试一下

172
00:06:00,120 --> 00:06:02,199
所以Jupyter的好处是说

173
00:06:03,280 --> 00:06:04,319
我们给一些样例

174
00:06:04,319 --> 00:06:05,000
给些样例

175
00:06:05,000 --> 00:06:05,639
并不是说

176
00:06:05,639 --> 00:06:07,560
我们肯定不可能教你所有的东西

177
00:06:07,639 --> 00:06:09,080
是说我教你一些

178
00:06:09,319 --> 00:06:11,560
正常的一些常见的使用

179
00:06:11,560 --> 00:06:12,840
但是你如果有想法

180
00:06:12,840 --> 00:06:13,840
你可以去改

181
00:06:13,840 --> 00:06:14,840
就是说你可以把它改成

182
00:06:14,840 --> 00:06:15,680
任何别的形状

183
00:06:15,680 --> 00:06:16,760
你就运行就行了

184
00:06:16,800 --> 00:06:18,080
所以这个也是说

185
00:06:18,080 --> 00:06:20,160
一定说大家需要动手试一试

186
00:06:22,920 --> 00:06:25,040
然后我们可以通过说逻辑运算服

187
00:06:25,040 --> 00:06:26,520
来构建一个二维的张量

188
00:06:26,520 --> 00:06:28,160
就是说我判一下

189
00:06:28,200 --> 00:06:30,240
y是不是等于x

190
00:06:30,440 --> 00:06:31,480
它就是按原

191
00:06:31,480 --> 00:06:33,560
所谓的按元素值进行判

192
00:06:33,640 --> 00:06:34,360
就是说

193
00:06:35,280 --> 00:06:36,440
就这一个元素

194
00:06:36,440 --> 00:06:38,240
这两个元素是相等的

195
00:06:38,240 --> 00:06:40,480
别的元素等于是都不相等

196
00:06:43,000 --> 00:06:44,520
然后如果对一个x

197
00:06:44,520 --> 00:06:45,200
它是一个

198
00:06:45,200 --> 00:06:46,800
现在是一个三乘四的矩阵

199
00:06:46,800 --> 00:06:47,920
我会求和

200
00:06:48,280 --> 00:06:49,200
等于sum

201
00:06:49,280 --> 00:06:52,600
sum的话就变成一个元素的tensor

202
00:06:52,760 --> 00:06:55,080
就是一个元素的标量

203
00:06:55,120 --> 00:06:56,440
它的求和是66

204
00:06:56,880 --> 00:06:58,000
这是求和

205
00:07:00,840 --> 00:07:03,120
然后这一个比较有意思的是说

206
00:07:03,280 --> 00:07:04,280
从lumpi过来的

207
00:07:04,280 --> 00:07:06,240
就是说一个叫广播机制

208
00:07:06,280 --> 00:07:07,360
这也是

209
00:07:07,840 --> 00:07:10,040
出错最容易出错的一个地方

210
00:07:10,080 --> 00:07:12,000
就是说大家可能要稍微注意一下

211
00:07:12,000 --> 00:07:13,800
就是说如果你代码没写好

212
00:07:13,839 --> 00:07:15,759
看上去一切都在运行

213
00:07:15,759 --> 00:07:17,920
实际上可能不是你想象那样子

214
00:07:17,920 --> 00:07:20,839
这里是有一个广播机制在里面

215
00:07:21,120 --> 00:07:21,920
比如说

216
00:07:22,360 --> 00:07:25,120
我创建一个a

217
00:07:25,639 --> 00:07:28,639
它是一个二维的竖足

218
00:07:28,879 --> 00:07:29,959
但是它是一个向量

219
00:07:29,959 --> 00:07:32,079
其实它是有三行

220
00:07:32,240 --> 00:07:33,240
它有一列

221
00:07:34,480 --> 00:07:35,920
然后我创建一个b

222
00:07:36,759 --> 00:07:39,120
它有一行两列

223
00:07:39,120 --> 00:07:40,199
你可以打印下去

224
00:07:40,199 --> 00:07:40,759
找这样子

225
00:07:40,759 --> 00:07:41,000
对吧

226
00:07:41,000 --> 00:07:42,000
这是a

227
00:07:42,240 --> 00:07:43,079
这是b

228
00:07:43,759 --> 00:07:44,000
好

229
00:07:44,000 --> 00:07:45,639
现在我在做a加b

230
00:07:46,759 --> 00:07:48,040
按照我们刚刚的定义

231
00:07:48,040 --> 00:07:50,160
我们是按a的每个元素

232
00:07:50,160 --> 00:07:51,759
和b的每个元素想加

233
00:07:51,839 --> 00:07:52,920
但它形状不一样

234
00:07:53,560 --> 00:07:54,839
不一样怎么加呢

235
00:07:55,040 --> 00:07:56,680
就是说在这个情况下

236
00:07:56,680 --> 00:07:58,759
它有一个特殊的机制来帮你加

237
00:07:58,839 --> 00:07:59,680
就是说

238
00:07:59,759 --> 00:08:02,079
如果当我看到两个张量

239
00:08:02,079 --> 00:08:03,839
有两个多元竖足

240
00:08:03,839 --> 00:08:05,800
就我们其实张量和多元竖足

241
00:08:05,800 --> 00:08:06,480
是混着用的

242
00:08:06,519 --> 00:08:07,639
数学上它不一样

243
00:08:07,639 --> 00:08:09,560
但是我们这就偷个懒

244
00:08:09,560 --> 00:08:10,000
混着用

245
00:08:10,000 --> 00:08:12,279
因为张量说起来比较简单

246
00:08:12,920 --> 00:08:13,240
好

247
00:08:13,240 --> 00:08:15,279
这两个张量形状不一样

248
00:08:15,279 --> 00:08:16,720
但是我可以有办法

249
00:08:16,720 --> 00:08:18,120
把它变成形状一样

250
00:08:18,120 --> 00:08:18,519
为什么

251
00:08:18,639 --> 00:08:20,480
是因为你这里

252
00:08:20,720 --> 00:08:22,240
首先我们的维数是一样的

253
00:08:22,360 --> 00:08:24,240
都是一个维度等于2

254
00:08:24,240 --> 00:08:25,079
都是一个竖足

255
00:08:25,079 --> 00:08:26,040
如果你维度不一样

256
00:08:26,040 --> 00:08:26,800
就没戏了

257
00:08:27,720 --> 00:08:28,560
因为维度一样

258
00:08:28,560 --> 00:08:30,120
然后第一个维度

259
00:08:30,360 --> 00:08:31,160
我是3

260
00:08:31,160 --> 00:08:32,159
但你是1

261
00:08:32,440 --> 00:08:32,679
好

262
00:08:32,679 --> 00:08:33,159
第二个维度

263
00:08:33,159 --> 00:08:34,039
虽然我们不一样

264
00:08:34,080 --> 00:08:35,399
但是我是2

265
00:08:35,399 --> 00:08:36,080
你是1

266
00:08:36,080 --> 00:08:37,559
所以的一个办法是说

267
00:08:37,559 --> 00:08:38,440
我不应该

268
00:08:38,639 --> 00:08:39,720
一个办法是说

269
00:08:39,720 --> 00:08:41,840
我可以把我1的这一维度

270
00:08:41,840 --> 00:08:42,560
复制一下

271
00:08:42,560 --> 00:08:43,639
复制成两个

272
00:08:43,960 --> 00:08:45,080
然后把我

273
00:08:45,120 --> 00:08:46,200
这个跟你不一样的地方

274
00:08:46,200 --> 00:08:46,840
因为我是1

275
00:08:47,000 --> 00:08:48,840
我就可以把我复制成三下

276
00:08:48,879 --> 00:08:50,759
这样子就会把A复制成一个

277
00:08:50,759 --> 00:08:52,080
三乘二的矩阵

278
00:08:52,120 --> 00:08:54,960
把B复制成一个三乘二的矩阵

279
00:08:54,960 --> 00:08:56,320
然后再打降价

280
00:08:56,360 --> 00:08:57,639
这样子可以看到是说

281
00:08:57,639 --> 00:08:58,480
我们加出来

282
00:08:58,480 --> 00:09:00,040
就是一个三乘二的矩阵了

283
00:09:00,360 --> 00:09:01,840
这就是一个广播机制

284
00:09:03,040 --> 00:09:04,399
所以是说很多时候

285
00:09:04,399 --> 00:09:05,879
你如果可能没有想到

286
00:09:05,879 --> 00:09:07,200
说我要做广播

287
00:09:07,200 --> 00:09:09,399
就是说我就想把两个项链一加

288
00:09:09,439 --> 00:09:11,439
但是你没想到一个项链没弄好

289
00:09:11,439 --> 00:09:12,279
就是加了一个

290
00:09:12,279 --> 00:09:13,360
不小心加了一个维度

291
00:09:13,360 --> 00:09:14,240
或加了一个维度

292
00:09:14,240 --> 00:09:15,159
它就变成一个矩阵

293
00:09:15,159 --> 00:09:16,639
相加就变成一个矩阵出来了

294
00:09:16,639 --> 00:09:18,039
就不是你想象的那样子

295
00:09:18,039 --> 00:09:19,439
所以这一块就是

296
00:09:19,439 --> 00:09:20,559
虽然它很方便

297
00:09:20,559 --> 00:09:21,840
但是大家一定要注意说

298
00:09:21,840 --> 00:09:23,199
有这个机制的存在

299
00:09:23,600 --> 00:09:25,199
导致如果有问题的话

300
00:09:25,199 --> 00:09:27,199
大家可能会去想这个事情

301
00:09:27,199 --> 00:09:29,399
是不是因为广播机制造成的

302
00:09:31,319 --> 00:09:33,919
然后我们来做一下元素的访问

303
00:09:33,919 --> 00:09:35,639
我们之前有说过说

304
00:09:35,679 --> 00:09:38,199
元素可以做哪些访问

305
00:09:38,720 --> 00:09:39,120
最简单

306
00:09:39,680 --> 00:09:40,960
X-1

307
00:09:40,960 --> 00:09:43,120
就是说把最后一列访问出来

308
00:09:44,120 --> 00:09:44,800
最后一列

309
00:09:44,800 --> 00:09:45,640
最后一行

310
00:09:45,640 --> 00:09:46,000
sorry

311
00:09:46,000 --> 00:09:46,800
最后一行

312
00:09:47,080 --> 00:09:48,000
X1-3

313
00:09:48,000 --> 00:09:54,720
就是说把第一行和第二行给拿出来

314
00:09:54,720 --> 00:09:56,000
就是X1-3

315
00:09:58,840 --> 00:10:00,280
然后我们当然可以是说

316
00:10:00,280 --> 00:10:01,720
我要写值

317
00:10:01,720 --> 00:10:02,680
我怎么写呢

318
00:10:02,680 --> 00:10:04,720
我把第一行

319
00:10:05,160 --> 00:10:06,879
就是它其实行还是从0开始

320
00:10:07,399 --> 00:10:08,759
所以第一行其实是说

321
00:10:08,759 --> 00:10:09,759
这个是第一行

322
00:10:10,240 --> 00:10:11,720
然后第二列

323
00:10:11,759 --> 00:10:12,919
列是从0开始

324
00:10:12,960 --> 00:10:14,039
所以你是写的是

325
00:10:14,039 --> 00:10:14,639
这个

326
00:10:16,080 --> 00:10:18,080
你把这个元素的值写成9

327
00:10:18,080 --> 00:10:19,120
然后把X打印出来

328
00:10:19,120 --> 00:10:21,439
你会发现别的值都没有变

329
00:10:21,439 --> 00:10:22,840
就9就变化了

330
00:10:26,399 --> 00:10:28,759
当然我可以做很多地方的复制

331
00:10:28,759 --> 00:10:30,360
就是说我把0-2

332
00:10:30,360 --> 00:10:32,399
就是把0行和1行

333
00:10:32,399 --> 00:10:34,159
就是这两行拿出来

334
00:10:34,559 --> 00:10:37,039
然后把所有的列通过冒号选中

335
00:10:37,399 --> 00:10:38,439
复制等于12

336
00:10:38,439 --> 00:10:38,839
这样子

337
00:10:38,839 --> 00:10:41,360
我就把这一块全部复制成12

338
00:10:41,360 --> 00:10:42,719
别的地方我不动

339
00:10:43,360 --> 00:10:45,799
这是按区域复制

340
00:10:48,000 --> 00:10:49,519
然后另外一个是说

341
00:10:50,279 --> 00:10:52,079
Python里面可能会不会

342
00:10:52,079 --> 00:10:52,959
因为写CI家

343
00:10:52,959 --> 00:10:54,879
你会去想内存的事情

344
00:10:54,879 --> 00:10:55,879
但Python它不会

345
00:10:55,879 --> 00:10:58,720
所以但是在一些高级应用的时候

346
00:10:58,720 --> 00:11:00,519
你可能会考虑是说

347
00:11:00,519 --> 00:11:03,519
你如果你有个特别大的矩阵

348
00:11:03,519 --> 00:11:06,240
你最好不要去把它不断的复制

349
00:11:06,240 --> 00:11:08,840
你可导致内存的问题

350
00:11:08,840 --> 00:11:10,319
所以我们稍微讲一下

351
00:11:10,319 --> 00:11:12,840
说怎么样来避免一些内存的问题

352
00:11:13,199 --> 00:11:15,079
就Python里面有个东西叫做ID

353
00:11:15,079 --> 00:11:18,480
ID是说告诉你可以认为是CI家的

354
00:11:18,480 --> 00:11:19,600
指针一样的东西

355
00:11:19,600 --> 00:11:20,439
ID告诉你

356
00:11:20,439 --> 00:11:26,199
这个object在Python里面的唯一的标识号

357
00:11:27,240 --> 00:11:29,720
然后说我的Y的ID我存起来

358
00:11:30,039 --> 00:11:33,000
然后我把Y加上X

359
00:11:33,000 --> 00:11:34,279
再复制为Y

360
00:11:34,799 --> 00:11:37,120
那么当然是说我把这个结果一加

361
00:11:37,120 --> 00:11:39,279
然后再创建一个新的变量

362
00:11:39,279 --> 00:11:40,720
然后把它名字叫做Y

363
00:11:40,960 --> 00:11:43,840
这个认为是说Y是不会等于之前的函数

364
00:11:43,840 --> 00:11:46,960
就是说之前的内存已经被吸垢掉了

365
00:11:47,720 --> 00:11:48,639
这就是一个新的

366
00:11:48,639 --> 00:11:50,360
你可以说新的Y的ID

367
00:11:50,360 --> 00:11:51,440
它不等于以前

368
00:11:51,440 --> 00:11:52,639
它是等于false的

369
00:11:53,480 --> 00:11:55,960
如果你想做原地操作也有办法

370
00:11:56,000 --> 00:11:56,919
你怎么做呢

371
00:11:57,360 --> 00:11:59,480
就是说我用我创造一个Z

372
00:11:59,480 --> 00:12:00,840
Z就是zero like

373
00:12:00,879 --> 00:12:04,480
就是说跟Y的shape和数据的类型是一样

374
00:12:04,480 --> 00:12:06,519
但是所有的元素是0

375
00:12:07,080 --> 00:12:10,200
我可以打印一下Z的ID是等于多少

376
00:12:10,320 --> 00:12:14,160
然后我说我Z里面所有的元素

377
00:12:14,519 --> 00:12:16,960
它等于X加上Y

378
00:12:17,600 --> 00:12:22,080
就是说我其实是对Z的元素进行一次改写

379
00:12:22,840 --> 00:12:26,040
可以看到是说之前的Z和之后的Z

380
00:12:26,040 --> 00:12:27,320
它的ID是一样的

381
00:12:27,320 --> 00:12:29,360
就是说Z的内存并没有发生变化

382
00:12:29,399 --> 00:12:31,759
就我没有为Z再创建新的内存

383
00:12:32,320 --> 00:12:34,159
这个是一个原地操作

384
00:12:36,240 --> 00:12:38,600
然后如果说我们的后续运算中

385
00:12:38,600 --> 00:12:40,200
没有重复使用X的话

386
00:12:40,200 --> 00:12:42,320
我们当然可以直接改写

387
00:12:42,320 --> 00:12:44,440
就是说我可以直接X加等于Y

388
00:12:44,639 --> 00:12:47,200
直接把Y的值加进X里面是一样的

389
00:12:47,200 --> 00:12:48,879
就是说X是没有发生变化的

390
00:12:48,879 --> 00:12:51,840
跟之前的定义其实是差不多的

391
00:12:52,879 --> 00:12:55,800
就是说大家就是说在使用的时候

392
00:12:55,800 --> 00:12:57,120
可能稍微注意一下

393
00:12:57,120 --> 00:12:59,080
特别是比较大的内存的话

394
00:12:59,080 --> 00:12:59,920
你稍微注意一下

395
00:12:59,920 --> 00:13:01,520
不要过多复制就行了

396
00:13:02,120 --> 00:13:03,360
不需要了解太多

397
00:13:03,360 --> 00:13:05,720
OK

398
00:13:05,720 --> 00:13:09,120
最后大概就是说Python里面最常见的

399
00:13:09,120 --> 00:13:10,400
其实既不是PyTorch

400
00:13:10,400 --> 00:13:11,160
也不是TensorFlow

401
00:13:11,160 --> 00:13:12,080
其实是Numpy

402
00:13:12,800 --> 00:13:13,879
但也不是Mthnet

403
00:13:14,080 --> 00:13:17,560
就是说Numpy是Python里面最基础的

404
00:13:17,560 --> 00:13:19,800
多元数组的运算框架

405
00:13:19,800 --> 00:13:22,879
就是说可能大家如果学Python数据编程的话

406
00:13:22,879 --> 00:13:24,400
可能是从Numpy学起的

407
00:13:24,600 --> 00:13:27,080
所以当然是所谓的不管是所有的框架

408
00:13:27,080 --> 00:13:28,240
它都能够很方便的

409
00:13:28,240 --> 00:13:29,720
从Numpy进行转换

410
00:13:30,120 --> 00:13:31,720
比如说X等于Numpy

411
00:13:31,720 --> 00:13:34,480
它会得到一个Numpy的多元数组

412
00:13:34,919 --> 00:13:36,600
当然你可以Torch Tensor

413
00:13:36,600 --> 00:13:38,480
从一个Numpy A拿回来

414
00:13:38,639 --> 00:13:40,320
可以构建一个PyTorch的一个Tensor

415
00:13:40,320 --> 00:13:42,840
你可以看到是说A的type

416
00:13:43,159 --> 00:13:44,039
就是它的类型

417
00:13:44,039 --> 00:13:46,279
它是一个Numpy的NDarray

418
00:13:46,720 --> 00:13:48,799
然后它的B是从Numpy构建的

419
00:13:48,799 --> 00:13:50,639
所以它是一个Torch的一个Tensor

420
00:13:50,840 --> 00:13:52,480
所以这个是Numpy的数据类型

421
00:13:52,480 --> 00:13:53,919
这个是Torch的数据类型

422
00:13:55,159 --> 00:13:57,519
当然如果你是大小唯一的长量的话

423
00:13:57,559 --> 00:13:59,480
我可以变成一个Python的标量

424
00:14:00,039 --> 00:14:03,639
我创建一个大小唯一的Torch的Tensor

425
00:14:04,079 --> 00:14:06,720
A当然它就是一个Torch的Tensor了

426
00:14:06,720 --> 00:14:08,960
OK 把A.item拿出来

427
00:14:08,960 --> 00:14:14,000
它就是一个Numpy的一个伏点数

428
00:14:14,439 --> 00:14:16,279
当我可以说float A

429
00:14:16,519 --> 00:14:18,240
这也是变成一个Python的伏点数

430
00:14:18,519 --> 00:14:20,399
int A它就变成一个integer

431
00:14:20,399 --> 00:14:21,600
就是也是Python的

432
00:14:21,960 --> 00:14:23,279
这就是转变

433
00:14:23,679 --> 00:14:24,240
OK

434
00:14:25,200 --> 00:14:25,519
OK

435
00:14:25,519 --> 00:14:27,960
这个是最后一张slide

436
00:14:27,960 --> 00:14:30,360
我们是讲到最基础的

437
00:14:30,560 --> 00:14:32,919
怎么样用PyTorch的张量

438
00:14:32,919 --> 00:14:34,879
来做一些基础的张量的运算

