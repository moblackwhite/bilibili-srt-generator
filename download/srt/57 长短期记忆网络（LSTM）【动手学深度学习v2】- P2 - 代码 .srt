1
00:00:00,000 --> 00:00:05,639
LSTM就是叫做长短期记忆网络

2
00:00:06,560 --> 00:00:09,480
是在90年代发明的网络

3
00:00:09,480 --> 00:00:11,200
反正挺复杂的

4
00:00:11,200 --> 00:00:16,519
就是说这个网络大家其实就一直就没有搞清楚

5
00:00:16,519 --> 00:00:17,800
为什么你要这么设计

6
00:00:18,519 --> 00:00:24,359
然后这个是LSTM发明的作者

7
00:00:24,359 --> 00:00:26,920
叫Eugen对吧

8
00:00:27,120 --> 00:00:28,600
欧洲人

9
00:00:28,760 --> 00:00:32,320
一直跟Hinton他们那边有矛盾

10
00:00:32,520 --> 00:00:36,160
就是Hinton Benjo他们就是说现在主流的

11
00:00:36,160 --> 00:00:38,320
可以认为主流的是深度学习

12
00:00:38,320 --> 00:00:40,520
主流的极大巨头

13
00:00:40,520 --> 00:00:43,640
他们之间是一直有矛盾

14
00:00:43,640 --> 00:00:48,120
然后在公众场合也是吵了挺久的

15
00:00:48,120 --> 00:00:50,840
这个也是我们的学术界的一点小八卦了

16
00:00:51,680 --> 00:00:52,200
OK

17
00:00:52,320 --> 00:00:54,719
所以但是反过来讲

18
00:00:54,719 --> 00:00:57,680
LSTM虽然长得挺奇怪的

19
00:00:57,679 --> 00:00:59,640
但是实际上在使用中

20
00:00:59,799 --> 00:01:01,960
大家还是经常使用的一个网络

21
00:01:01,960 --> 00:01:04,359
即使是在90年代发明的

22
00:01:04,799 --> 00:01:05,439
OK

23
00:01:06,439 --> 00:01:10,560
就是说LSTM我们之所以把GiU放了之后

24
00:01:10,719 --> 00:01:13,400
是因为LSTM又多了那么一点点东西

25
00:01:13,760 --> 00:01:15,480
它有那么几个东西

26
00:01:15,560 --> 00:01:17,239
一叫做忘记门

27
00:01:17,239 --> 00:01:21,799
跟我们之前的是有点像

28
00:01:21,799 --> 00:01:23,200
就是把值向零介绍

29
00:01:23,200 --> 00:01:24,359
一个叫输入门

30
00:01:24,359 --> 00:01:27,519
就决定要不要忽略掉输入的数据

31
00:01:27,800 --> 00:01:28,920
输出门

32
00:01:28,920 --> 00:01:31,040
决定要不要用隐藏状态

33
00:01:31,040 --> 00:01:33,840
所以这个东西它要实现的效果

34
00:01:33,960 --> 00:01:35,280
跟GiU是一样的

35
00:01:35,960 --> 00:01:38,600
但是它用的东西相对来说

36
00:01:38,600 --> 00:01:40,200
比GiU更加复杂一点

37
00:01:40,200 --> 00:01:41,680
就是说效果上来讲

38
00:01:41,840 --> 00:01:43,080
你都是要说

39
00:01:43,240 --> 00:01:46,960
我是不是要忘掉过去的状态

40
00:01:46,960 --> 00:01:48,560
尽量去看现在的状态

41
00:01:48,840 --> 00:01:50,440
现在的输入数据

42
00:01:51,280 --> 00:01:52,960
要不要还是说我要不要

43
00:01:52,960 --> 00:01:54,320
就是不看现在输入数据

44
00:01:54,320 --> 00:01:56,200
尽量用前一个时刻的状态

45
00:01:56,359 --> 00:01:58,320
就基本上就是这两个选择去选

46
00:01:58,320 --> 00:01:58,719
对吧

47
00:01:59,600 --> 00:02:01,920
所以在实现同样的效果的时候

48
00:02:01,920 --> 00:02:05,079
LSTM用的东西稍微多那么一点点

49
00:02:05,079 --> 00:02:06,920
然后我们来看一下它具体怎么用的

50
00:02:09,039 --> 00:02:12,400
首先它有三个门

51
00:02:14,840 --> 00:02:18,480
门的计算跟之前那些Z和R是一样的

52
00:02:18,480 --> 00:02:19,920
但是它命名不一样

53
00:02:19,920 --> 00:02:22,400
一个叫做forgot gate

54
00:02:22,680 --> 00:02:23,719
那个叫做F

55
00:02:24,039 --> 00:02:25,719
然后一个叫做input gate

56
00:02:25,719 --> 00:02:26,800
叫做I

57
00:02:26,800 --> 00:02:28,439
一个叫做output gate

58
00:02:28,439 --> 00:02:29,120
叫做O

59
00:02:29,120 --> 00:02:30,080
就是说你大家记住

60
00:02:30,240 --> 00:02:33,000
反正就是比之前多了一个

61
00:02:33,360 --> 00:02:34,680
就之前是R和Z

62
00:02:34,680 --> 00:02:36,439
现在变成IFO

63
00:02:37,400 --> 00:02:38,319
这我们就不仔细讲了

64
00:02:38,520 --> 00:02:39,680
就是基本上就是

65
00:02:40,120 --> 00:02:41,319
你就是这么算过来

66
00:02:41,639 --> 00:02:42,479
算起来都是一样

67
00:02:42,479 --> 00:02:43,199
就每个gate

68
00:02:43,199 --> 00:02:44,680
你有两个W一个B

69
00:02:44,960 --> 00:02:46,599
然后都是这么算过来的

70
00:02:47,280 --> 00:02:47,520
好

71
00:02:47,520 --> 00:02:49,240
我们主要看一下它怎么算的

72
00:02:50,000 --> 00:02:51,719
首先这个东西多了一个东西

73
00:02:51,719 --> 00:02:54,840
叫做候选记忆单元

74
00:02:56,319 --> 00:02:56,879
OK

75
00:02:57,159 --> 00:02:58,400
它多了一个C

76
00:02:59,199 --> 00:03:00,639
C是怎么算的呢

77
00:03:01,000 --> 00:03:02,079
C这个东西

78
00:03:02,360 --> 00:03:03,199
其实说白了

79
00:03:03,199 --> 00:03:06,719
就是我们之前算RN的

80
00:03:06,719 --> 00:03:08,280
那个HT是怎么来的

81
00:03:08,280 --> 00:03:11,240
就是把你的输入

82
00:03:12,840 --> 00:03:15,759
跟它W相称

83
00:03:15,759 --> 00:03:17,560
前一个状态的H相称

84
00:03:17,560 --> 00:03:18,400
加上B

85
00:03:18,599 --> 00:03:19,759
做一个timeH

86
00:03:20,639 --> 00:03:21,039
说白了

87
00:03:21,039 --> 00:03:24,759
就是我们之前算RN里面算H

88
00:03:24,959 --> 00:03:27,679
所以看到这里又记忆单元

89
00:03:27,799 --> 00:03:29,319
它又有两个W

90
00:03:30,079 --> 00:03:30,359
对吧

91
00:03:30,359 --> 00:03:31,719
所以我们现在有4套了

92
00:03:32,599 --> 00:03:34,120
之前我们是两套

93
00:03:34,120 --> 00:03:34,399
对吧

94
00:03:34,399 --> 00:03:35,560
现在我们有4套了

95
00:03:37,560 --> 00:03:38,759
之前我们也不是两套

96
00:03:38,759 --> 00:03:39,799
之前我们是两套

97
00:03:39,799 --> 00:03:42,039
再加你H是怎么更新的

98
00:03:42,039 --> 00:03:43,359
就HT怎么更新的

99
00:03:43,359 --> 00:03:46,519
现在我们变成了CT了

100
00:03:46,919 --> 00:03:47,919
我们之后看

101
00:03:47,919 --> 00:03:49,519
为什么它叫C不叫H

102
00:03:50,479 --> 00:03:51,199
所以你知道

103
00:03:51,639 --> 00:03:55,560
C就是跟我们之前的RN里的

104
00:03:55,560 --> 00:03:58,120
HT的更新算法是一样的

105
00:03:58,519 --> 00:04:00,159
它没有用到任何gat

106
00:04:02,079 --> 00:04:02,599
好

107
00:04:02,599 --> 00:04:05,919
然后我们看一下记忆单元

108
00:04:05,919 --> 00:04:07,879
就是说我们刚刚是记忆单元候选

109
00:04:08,159 --> 00:04:10,439
现在是真正的算记忆单元

110
00:04:11,079 --> 00:04:12,239
记忆单元这个东西

111
00:04:13,159 --> 00:04:16,120
它会上一个时刻的记忆单元

112
00:04:16,120 --> 00:04:18,759
会作为状态放进来

113
00:04:18,800 --> 00:04:22,000
所以LSTN跟RN不一样的地方

114
00:04:22,000 --> 00:04:23,719
跟GIU不一样的地方

115
00:04:23,719 --> 00:04:24,839
它的状态

116
00:04:25,079 --> 00:04:26,959
它状态里面有两个

117
00:04:26,959 --> 00:04:28,519
一个叫C一个叫H

118
00:04:28,800 --> 00:04:30,639
所以为什么我们之前实现的状态

119
00:04:30,639 --> 00:04:31,560
都用一个tuple

120
00:04:31,560 --> 00:04:32,759
就是为了它

121
00:04:32,800 --> 00:04:34,319
因为它多了一个东西出来

122
00:04:34,319 --> 00:04:35,279
它有个C

123
00:04:36,680 --> 00:04:37,319
OK

124
00:04:37,360 --> 00:04:39,839
所以记忆单元

125
00:04:40,079 --> 00:04:42,519
它的更新是说

126
00:04:42,759 --> 00:04:44,399
forgot就是说

127
00:04:46,199 --> 00:04:47,639
就是说我要

128
00:04:48,439 --> 00:04:50,279
如果是变成0的话

129
00:04:50,279 --> 00:04:51,639
这块变成0的话

130
00:04:52,199 --> 00:04:53,839
那么我尽量的去

131
00:04:53,839 --> 00:04:56,279
不要去记住C了

132
00:04:57,759 --> 00:04:59,279
I就是说

133
00:04:59,599 --> 00:05:01,439
我如果是1的话

134
00:05:01,439 --> 00:05:03,120
我尽量的去用它

135
00:05:03,120 --> 00:05:04,479
如果I等于0的话

136
00:05:04,639 --> 00:05:06,560
我就是把现在的记忆单元

137
00:05:06,560 --> 00:05:07,399
那个东西丢掉

138
00:05:08,159 --> 00:05:10,000
有点点像我们之前算了

139
00:05:10,000 --> 00:05:11,319
GIU里面算HT

140
00:05:11,680 --> 00:05:13,399
但是GIU里面是一个

141
00:05:13,399 --> 00:05:14,719
C和1-C

142
00:05:15,199 --> 00:05:17,360
就是说你做这个东西

143
00:05:17,360 --> 00:05:19,040
但另外一个东西一定没有

144
00:05:19,400 --> 00:05:21,680
但这个地方其实用的是

145
00:05:22,319 --> 00:05:25,319
用的是两个是独立的东西

146
00:05:25,600 --> 00:05:27,160
就独立上你可以说

147
00:05:27,160 --> 00:05:30,160
我可以又要前面的状态

148
00:05:31,319 --> 00:05:32,240
又要它

149
00:05:32,680 --> 00:05:33,360
OK

150
00:05:33,639 --> 00:05:35,120
但也可以说我全部不要

151
00:05:35,120 --> 00:05:35,800
也有可能

152
00:05:35,800 --> 00:05:36,280
对吧

153
00:05:36,280 --> 00:05:37,160
反正这两个东西

154
00:05:37,160 --> 00:05:38,160
你是相互独立的

155
00:05:38,160 --> 00:05:38,800
你没有说

156
00:05:38,800 --> 00:05:41,040
有了一个就一定没有另外一个

157
00:05:42,199 --> 00:05:42,759
OK

158
00:05:44,319 --> 00:05:45,720
然后我们再看下一个

159
00:05:46,720 --> 00:05:48,000
就隐藏状态

160
00:05:49,360 --> 00:05:50,560
就隐藏状态

161
00:05:50,680 --> 00:05:52,520
这个东西比较好玩的是说

162
00:05:53,240 --> 00:05:55,680
它又对你的后旋记忆单元

163
00:05:55,680 --> 00:05:57,480
再做一个timeH

164
00:05:59,720 --> 00:06:00,560
为什么那么干

165
00:06:00,560 --> 00:06:00,960
是因为

166
00:06:02,120 --> 00:06:03,880
timeH是把东西变到了

167
00:06:04,800 --> 00:06:05,880
正义负义之间

168
00:06:05,880 --> 00:06:06,400
对吧

169
00:06:07,120 --> 00:06:08,960
但之前你这个东西

170
00:06:09,840 --> 00:06:10,880
虽然我的

171
00:06:11,600 --> 00:06:13,120
你可以认为我的C是

172
00:06:13,120 --> 00:06:14,439
差不多是一个

173
00:06:14,800 --> 00:06:16,680
在正义负义之间的东西

174
00:06:17,600 --> 00:06:18,360
Ct要打

175
00:06:18,519 --> 00:06:20,000
因为这个东西也是在正义负义

176
00:06:20,000 --> 00:06:21,000
但是这两个东西

177
00:06:22,000 --> 00:06:23,920
它可以变成正二和负二之间

178
00:06:24,360 --> 00:06:24,759
对吧

179
00:06:24,759 --> 00:06:27,360
因为它F和I都是0到1

180
00:06:27,519 --> 00:06:29,439
C和Ct要打

181
00:06:29,519 --> 00:06:31,000
都是负义到正义

182
00:06:31,000 --> 00:06:32,399
然后这个东西两个一加

183
00:06:32,399 --> 00:06:33,600
就可以变成正二到负二的

184
00:06:33,600 --> 00:06:33,879
对吧

185
00:06:33,879 --> 00:06:35,680
就CT这个地方是

186
00:06:36,439 --> 00:06:38,079
就是说可能会变得比较大一点

187
00:06:39,120 --> 00:06:39,560
OK

188
00:06:39,560 --> 00:06:41,600
所以我这里讲错了

189
00:06:41,639 --> 00:06:42,519
就Cti

190
00:06:42,719 --> 00:06:43,879
就是说你可以是

191
00:06:44,000 --> 00:06:45,359
其实是可以比较大的

192
00:06:46,199 --> 00:06:46,919
所以这个东西

193
00:06:46,919 --> 00:06:49,159
虽然这个东西是正义到负义

194
00:06:49,159 --> 00:06:50,079
但是加了它之后

195
00:06:50,079 --> 00:06:51,479
它无法保证

196
00:06:51,560 --> 00:06:52,680
所以无法保证的话

197
00:06:53,079 --> 00:06:54,279
那么我需要

198
00:06:54,279 --> 00:06:56,039
我想我的隐藏状态

199
00:06:56,039 --> 00:06:58,039
假如是要在正义到负义之间的话

200
00:06:58,439 --> 00:07:01,159
那么我要再对它做一次timeH

201
00:07:01,959 --> 00:07:03,799
这样子能够把Ct直接的

202
00:07:03,799 --> 00:07:05,359
直放到正义到负义之间

203
00:07:06,359 --> 00:07:06,919
OK

204
00:07:06,959 --> 00:07:08,399
这就是这个timeH的来历

205
00:07:08,959 --> 00:07:10,039
再干一件什么事情

206
00:07:10,879 --> 00:07:12,399
再干一个点程

207
00:07:13,120 --> 00:07:14,560
OT是说

208
00:07:14,560 --> 00:07:15,839
控制是说

209
00:07:16,919 --> 00:07:18,879
我要不要输出

210
00:07:18,919 --> 00:07:19,799
它等于1的时候

211
00:07:19,799 --> 00:07:21,079
就是说输出了

212
00:07:21,120 --> 00:07:22,639
如果它等于0的话

213
00:07:23,279 --> 00:07:24,199
就是说

214
00:07:24,240 --> 00:07:25,079
就不要输出了

215
00:07:25,079 --> 00:07:26,599
不要输出的意思就是

216
00:07:27,159 --> 00:07:29,279
当前的XT和过去的

217
00:07:29,279 --> 00:07:30,560
所有信息我都不要

218
00:07:30,839 --> 00:07:31,879
极端情况变成0

219
00:07:31,879 --> 00:07:32,439
对吧

220
00:07:32,479 --> 00:07:33,560
极端情况变成0的话

221
00:07:33,560 --> 00:07:34,599
Ht变成0

222
00:07:34,639 --> 00:07:36,959
Ht变成0就表示我重置了

223
00:07:38,959 --> 00:07:39,599
OK

224
00:07:39,680 --> 00:07:41,439
所以基本上跟之前是有一点的不一样

225
00:07:41,639 --> 00:07:44,040
之前我们的重置是放在最前面的

226
00:07:44,199 --> 00:07:44,879
就是说

227
00:07:46,839 --> 00:07:48,759
在现在我们是放在最后面

228
00:07:49,519 --> 00:07:50,040
OK

229
00:07:50,719 --> 00:07:52,040
总结一下

230
00:07:52,040 --> 00:07:54,480
这就是LSTM

231
00:07:56,160 --> 00:07:58,240
就是说它跟之前GIU

232
00:07:58,519 --> 00:08:01,079
它想实现的效果其实差不多

233
00:08:01,680 --> 00:08:04,759
但是它东西复杂一点点

234
00:08:04,920 --> 00:08:06,879
首先它多了一个C

235
00:08:08,079 --> 00:08:09,319
多了一个C这个地方

236
00:08:09,439 --> 00:08:13,240
C你可认为就是一个没有被normalized

237
00:08:13,279 --> 00:08:17,040
就是说这个数值区间可能会比较大的一个东西

238
00:08:17,040 --> 00:08:19,839
就是放在一个辅助的记忆单元

239
00:08:20,800 --> 00:08:23,360
然后它的更新是说

240
00:08:23,360 --> 00:08:24,079
每一次它的更新

241
00:08:24,079 --> 00:08:25,759
它要么可以是说

242
00:08:26,159 --> 00:08:28,639
可以忘掉前面的C

243
00:08:29,120 --> 00:08:32,679
只跟当前的XT相关

244
00:08:34,480 --> 00:08:36,319
这一块就是只跟当前的XT相关

245
00:08:36,360 --> 00:08:37,840
和过去的状态相关

246
00:08:38,280 --> 00:08:39,759
当然它也可以说

247
00:08:39,759 --> 00:08:41,879
我可以忘掉当前的XT

248
00:08:41,879 --> 00:08:43,480
只用前面的状态

249
00:08:43,480 --> 00:08:44,960
或者我都可以忘掉

250
00:08:45,320 --> 00:08:45,720
对吧

251
00:08:45,720 --> 00:08:47,639
所以它是比较灵活的这个地方

252
00:08:48,600 --> 00:08:51,200
然后你的H又可以说

253
00:08:51,320 --> 00:08:54,759
我可以是用了它过来

254
00:08:54,759 --> 00:08:56,080
就把它记忆单元过来

255
00:08:56,240 --> 00:08:57,600
也可以是说我什么都不要

256
00:08:57,600 --> 00:08:59,560
就下一个时刻给你重置了

257
00:08:59,680 --> 00:09:00,280
OK

258
00:09:00,480 --> 00:09:07,000
所以基本上大概是这么样子的意思

259
00:09:07,440 --> 00:09:08,399
所以反过来讲

260
00:09:08,399 --> 00:09:10,159
所以我们为什么要先讲GRU

261
00:09:10,279 --> 00:09:12,360
是因为GRU解释起来方便一点

262
00:09:12,360 --> 00:09:15,279
LSDN相对说绕那么一点点

263
00:09:15,639 --> 00:09:17,000
但是实际上就是说

264
00:09:17,000 --> 00:09:18,759
你可以知道大概上来说

265
00:09:19,360 --> 00:09:21,120
它想实现的效果都是这样子

266
00:09:21,200 --> 00:09:24,799
就是说你要么就是多去看一下现在的XT

267
00:09:24,799 --> 00:09:28,360
要么就是多去忽略的XT

268
00:09:28,360 --> 00:09:30,279
多去看一下前面的东西

269
00:09:31,039 --> 00:09:33,480
当然还有情况就是我什么都不要

270
00:09:33,480 --> 00:09:34,480
我就重新了

271
00:09:34,480 --> 00:09:35,120
重新来

272
00:09:35,120 --> 00:09:37,600
OK就实现了这个功能

