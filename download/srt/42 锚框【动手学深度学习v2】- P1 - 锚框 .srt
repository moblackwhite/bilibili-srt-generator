1
00:00:00,000 --> 00:00:03,080
C++还是Python主要用于什么

2
00:00:03,080 --> 00:00:05,360
我觉得假设你性能没问题

3
00:00:05,360 --> 00:00:06,360
用Python挺好的

4
00:00:06,360 --> 00:00:07,280
开发更简单

5
00:00:07,280 --> 00:00:09,439
用C++很多时候是牵引性比较好一点

6
00:00:09,439 --> 00:00:10,640
确实一些复杂的

7
00:00:10,640 --> 00:00:12,759
你像刚刚那种模框的算法

8
00:00:12,919 --> 00:00:15,640
假设你用Python写的话还真不好

9
00:00:15,640 --> 00:00:17,359
性能还真一般

10
00:00:17,359 --> 00:00:19,960
而且不那么适合在芯片上面运行

11
00:00:21,800 --> 00:00:24,039
算法能不能通过视频2D来预测

12
00:00:24,039 --> 00:00:25,640
视频中物体的全环系3D

13
00:00:26,000 --> 00:00:27,359
有啊有有这样子

14
00:00:27,759 --> 00:00:28,359
就是说

15
00:00:29,519 --> 00:00:30,559
video那一块

16
00:00:30,679 --> 00:00:31,960
怎么样有时序信息

17
00:00:31,960 --> 00:00:34,240
我们之后会讲这种时序神经网络

18
00:00:34,240 --> 00:00:36,280
来里面是有东西

19
00:00:36,280 --> 00:00:38,200
然后transformer这一块是能做的

20
00:00:38,240 --> 00:00:41,600
我们会在视觉之后来讲时序那一块

21
00:00:42,679 --> 00:00:44,600
怎么算模框框住了一个物体

22
00:00:45,039 --> 00:00:46,320
预值怎么确定

23
00:00:47,600 --> 00:00:49,280
预值是手定的

24
00:00:51,760 --> 00:00:53,560
0.5一般来说

25
00:00:54,560 --> 00:00:57,440
一个模框只能对应一个真实框

26
00:00:57,440 --> 00:00:57,880
是的

27
00:00:57,880 --> 00:00:59,760
一个模框只能一个真实框

28
00:00:59,800 --> 00:01:01,320
就是说你也想一个模框

29
00:01:01,359 --> 00:01:04,520
他除非你说

30
00:01:04,520 --> 00:01:05,680
你如果说一个模框

31
00:01:05,680 --> 00:01:07,439
跟两个真实框都很近的话

32
00:01:07,439 --> 00:01:10,320
一定是这两个真实框的overlap很大

33
00:01:10,359 --> 00:01:11,920
一般来说的情况不大

34
00:01:12,760 --> 00:01:13,879
一般是一个图片里面

35
00:01:13,879 --> 00:01:15,040
你很少有两个真实框

36
00:01:15,040 --> 00:01:16,719
两个物体真的重叠在一起

37
00:01:17,719 --> 00:01:18,760
这概率不大

38
00:01:19,640 --> 00:01:21,200
为什么生成多个训练样本

39
00:01:21,240 --> 00:01:24,320
从直接从一张图片上

40
00:01:24,320 --> 00:01:25,799
不同位置crop多次出来

41
00:01:25,799 --> 00:01:26,200
不行吗

42
00:01:26,200 --> 00:01:27,120
可以的

43
00:01:27,120 --> 00:01:29,480
就是说我们之后会讲RCN系列

44
00:01:29,640 --> 00:01:30,640
是他是这么做的

45
00:01:30,680 --> 00:01:32,320
就是说有些是不给予模框的

46
00:01:32,320 --> 00:01:32,760
没关系

47
00:01:33,439 --> 00:01:37,200
所以说模框只是一种的方法

48
00:01:38,079 --> 00:01:40,159
用模框后再识别边缘效果

49
00:01:40,159 --> 00:01:41,680
比直接识别边缘效果好吗

50
00:01:41,680 --> 00:01:43,280
理论上是不是涉及到

51
00:01:45,800 --> 00:01:48,800
理论是首先我们这里没理论

52
00:01:49,079 --> 00:01:50,439
其次他好不好

53
00:01:50,480 --> 00:01:51,079
就是说

54
00:01:52,000 --> 00:01:52,879
目前来说

55
00:01:52,879 --> 00:01:54,879
模框相对来说算法更多

56
00:01:54,920 --> 00:01:56,079
一些效果还不错

57
00:01:56,120 --> 00:01:57,359
但是不用

58
00:01:57,679 --> 00:01:58,719
比如说下面这个问题

59
00:01:58,719 --> 00:02:00,000
不用anchor的话

60
00:02:00,000 --> 00:02:01,439
怎么样判断

61
00:02:02,920 --> 00:02:03,879
不用anchor的话

62
00:02:03,920 --> 00:02:04,359
就是基本上

63
00:02:04,359 --> 00:02:05,439
你就说每个像素中心

64
00:02:05,679 --> 00:02:07,599
就是说每个像素尾中心

65
00:02:07,599 --> 00:02:08,919
去比较center net

66
00:02:08,919 --> 00:02:10,079
就是说有

67
00:02:10,079 --> 00:02:11,639
你可以去我们不会讲

68
00:02:11,840 --> 00:02:12,879
大家可以去看一下

69
00:02:15,400 --> 00:02:17,439
最大的预测值

70
00:02:17,439 --> 00:02:19,479
指的是分类的自信度

71
00:02:19,479 --> 00:02:20,159
还是

72
00:02:21,039 --> 00:02:22,959
模框预测没有自信度

73
00:02:23,000 --> 00:02:24,719
只有分类有自信度

74
00:02:25,599 --> 00:02:27,039
我们之后会给自己讲

75
00:02:27,039 --> 00:02:28,439
就是说给大家会讲说

76
00:02:28,439 --> 00:02:29,879
具体说你这个算法

77
00:02:29,879 --> 00:02:31,479
就是说取决于你这个模型

78
00:02:31,479 --> 00:02:32,879
它的预测是怎么预测的

79
00:02:32,919 --> 00:02:33,759
一般来说

80
00:02:33,759 --> 00:02:35,439
每个类是一个分类问题

81
00:02:35,439 --> 00:02:36,280
是用softmax

82
00:02:36,280 --> 00:02:37,439
它是有自信度

83
00:02:37,439 --> 00:02:39,919
但是模框是一个regression

84
00:02:39,919 --> 00:02:41,639
是一个回归问题

85
00:02:41,639 --> 00:02:43,359
回归是没有自信度的

86
00:02:45,719 --> 00:02:46,959
如果识别狗完之后

87
00:02:46,959 --> 00:02:48,479
还要对狗类部进行一次分类

88
00:02:48,479 --> 00:02:49,919
比如说大狗小狗

89
00:02:51,639 --> 00:02:54,439
这样是不是肯定低于整体狗的预测

90
00:02:54,840 --> 00:02:56,199
如果是要进一步预测

91
00:02:56,199 --> 00:02:57,639
狗头和狗尾巴

92
00:02:57,679 --> 00:02:59,120
你这个问题问的挺好玩的

93
00:02:59,439 --> 00:03:01,879
就是说你要做更精细的分类的话

94
00:03:01,879 --> 00:03:02,479
真

95
00:03:03,039 --> 00:03:04,679
精确度可能会低

96
00:03:04,679 --> 00:03:05,919
这是因为为什么

97
00:03:06,399 --> 00:03:09,479
是因为你对你做精细的分类的话

98
00:03:09,479 --> 00:03:12,039
你每一个类拿到的样本数会变低

99
00:03:12,479 --> 00:03:13,399
你要想高的话

100
00:03:13,399 --> 00:03:14,879
你得采集更多的样本

101
00:03:15,319 --> 00:03:18,399
如果你要做狗头狗头狗尾巴

102
00:03:18,480 --> 00:03:19,920
如果你有个标注机

103
00:03:19,920 --> 00:03:21,680
就把狗头给标出来也行

104
00:03:21,760 --> 00:03:23,080
但狗头我觉得比较简单

105
00:03:23,080 --> 00:03:23,800
就人脸识别

106
00:03:23,800 --> 00:03:25,480
那套算法估计狗头是能用的

107
00:03:25,480 --> 00:03:26,920
尾巴会麻烦一点

108
00:03:26,920 --> 00:03:27,680
尾巴的话

109
00:03:27,680 --> 00:03:30,920
你得去把尾巴给框出来

110
00:03:33,400 --> 00:03:35,360
NMS和副标类

111
00:03:35,520 --> 00:03:36,000
差不多

112
00:03:36,000 --> 00:03:37,040
我不知道这个问题

113
00:03:37,040 --> 00:03:38,720
我其实不算理解什么意思

114
00:03:38,840 --> 00:03:39,920
我就pass了

115
00:03:40,880 --> 00:03:42,240
标记模框之后

116
00:03:42,240 --> 00:03:43,280
偏移是怎么算的

117
00:03:43,480 --> 00:03:45,440
怎么根据模框变化到边缘框

118
00:03:46,280 --> 00:03:46,560
对

119
00:03:46,560 --> 00:03:48,200
就是说我们有个算法

120
00:03:48,200 --> 00:03:50,000
没有给大家去讲怎么算的

121
00:03:50,440 --> 00:03:51,240
最简单是说

122
00:03:51,240 --> 00:03:53,960
你偏移就是你的真实框

123
00:03:53,960 --> 00:03:56,360
4个数字减去模框的4个数字

124
00:03:56,360 --> 00:03:57,480
是得到对吧

125
00:03:57,480 --> 00:03:58,720
得到的偏移对吧

126
00:03:59,360 --> 00:04:01,080
但我们实际上不是这么算的

127
00:04:01,080 --> 00:04:02,880
实际上我们有两个算法没有讲

128
00:04:03,120 --> 00:04:05,000
就是说怎么过去怎么回来

129
00:04:05,560 --> 00:04:06,800
大家可以去看一下书里面

130
00:04:06,800 --> 00:04:07,920
有一节讲了

131
00:04:07,920 --> 00:04:08,800
因为那一节

132
00:04:08,800 --> 00:04:10,240
我是觉得时间上来不及

133
00:04:10,240 --> 00:04:11,160
我们就没讲了

134
00:04:12,640 --> 00:04:14,440
我就没有讲具体怎么算的

135
00:04:14,440 --> 00:04:16,640
我们函数是在记事本里面有

136
00:04:19,079 --> 00:04:20,800
每一次做MS的时候

137
00:04:20,800 --> 00:04:23,680
是只针对相同类别做循环过滤

138
00:04:23,680 --> 00:04:25,719
还是对不同类别做过滤叙述

139
00:04:25,719 --> 00:04:26,839
你这个问题挺好的

140
00:04:28,279 --> 00:04:30,279
MS我们有两种做法

141
00:04:30,279 --> 00:04:31,920
一种是我们今天讲的

142
00:04:31,959 --> 00:04:33,439
就是说把所有的类

143
00:04:34,199 --> 00:04:35,919
把背景丢掉

144
00:04:35,919 --> 00:04:38,680
剩下的所有的类的预测值放在一起

145
00:04:38,719 --> 00:04:40,079
每一次拎一个最大的

146
00:04:40,079 --> 00:04:41,560
把相似度去掉

147
00:04:41,560 --> 00:04:42,879
然后这么做

148
00:04:42,919 --> 00:04:45,399
这是对所有的类放在一起

149
00:04:45,680 --> 00:04:46,519
另外一个做法

150
00:04:46,519 --> 00:04:47,279
常用的做法

151
00:04:47,280 --> 00:04:49,120
是说对每一个类

152
00:04:49,800 --> 00:04:52,160
他的所有的预测为

153
00:04:52,160 --> 00:04:52,800
就是说预测

154
00:04:52,800 --> 00:04:54,200
只是这一个类的

155
00:04:54,200 --> 00:04:55,520
这些毛框拿出来

156
00:04:55,520 --> 00:04:56,600
按照预测值排序

157
00:04:56,600 --> 00:04:57,720
然后这样子做

158
00:04:57,720 --> 00:04:59,840
在每类里面做MS

159
00:04:59,880 --> 00:05:00,760
这是另外一种做法

160
00:05:00,760 --> 00:05:01,920
也是非常常用的

161
00:05:01,920 --> 00:05:03,680
两种一般大家都会支持

162
00:05:06,520 --> 00:05:07,480
一阶算法

163
00:05:07,480 --> 00:05:08,160
一阶段算法

164
00:05:08,160 --> 00:05:09,920
是不是对毛框和分类同时

165
00:05:10,760 --> 00:05:11,560
二阶段算法

166
00:05:11,560 --> 00:05:12,920
是不是分开预测

167
00:05:14,440 --> 00:05:15,960
就one stage two stage

168
00:05:16,159 --> 00:05:17,839
我们会后来会讲

169
00:05:18,159 --> 00:05:20,199
你的理解差不多是对的

170
00:05:22,159 --> 00:05:24,439
为什么每个像素5个毛框

171
00:05:24,439 --> 00:05:25,759
为什么是单像素级别的

172
00:05:25,759 --> 00:05:26,239
一个毛框

173
00:05:26,239 --> 00:05:27,599
是不是包含很多像素

174
00:05:28,039 --> 00:05:29,479
就是说不是单像素

175
00:05:29,479 --> 00:05:32,120
是毛框的中心值

176
00:05:32,159 --> 00:05:34,679
以每个像素为中心化几个毛框

177
00:05:35,560 --> 00:05:36,000
OK

178
00:05:36,000 --> 00:05:37,519
所以毛框是有很多个像素

179
00:05:37,519 --> 00:05:39,359
但是毛框的中心只有一个像素

180
00:05:39,359 --> 00:05:39,879
对吧

181
00:05:40,120 --> 00:05:41,599
其次为什么是5个毛框

182
00:05:41,599 --> 00:05:42,000
5个毛框

183
00:05:42,000 --> 00:05:44,000
是我们的超参数选出来的

184
00:05:44,399 --> 00:05:45,319
一般用5个

185
00:05:45,319 --> 00:05:46,519
用7个

186
00:05:46,519 --> 00:05:47,360
用9个比较多

187
00:05:47,360 --> 00:05:51,560
就是看你要多少个

188
00:05:51,560 --> 00:05:53,000
长相不一样的毛框

189
00:05:55,040 --> 00:05:56,879
Assign anchor to box

190
00:05:56,879 --> 00:05:58,399
里面真实边缘框是哪一来

191
00:05:58,399 --> 00:05:59,279
真实边缘框

192
00:05:59,279 --> 00:06:00,920
就是你的数据读出来的

193
00:06:00,920 --> 00:06:01,399
记得吗

194
00:06:01,399 --> 00:06:03,040
我们在之前那个notebook里面

195
00:06:03,040 --> 00:06:03,759
有讲过

196
00:06:03,800 --> 00:06:05,439
从CSV文件里面

197
00:06:05,439 --> 00:06:06,879
把数据给读出来

198
00:06:06,920 --> 00:06:08,759
那里面有真实边缘框

199
00:06:09,000 --> 00:06:10,639
那是手标出来的

200
00:06:11,399 --> 00:06:12,079
OK

201
00:06:12,680 --> 00:06:14,800
所以是说

202
00:06:14,839 --> 00:06:16,120
训练的时候

203
00:06:16,120 --> 00:06:18,000
你有真实边缘框

204
00:06:18,199 --> 00:06:19,000
训练的时候

205
00:06:19,000 --> 00:06:20,879
你说我去读数据

206
00:06:20,879 --> 00:06:22,519
数据里面是已经人标好

207
00:06:22,519 --> 00:06:23,519
标了真实边缘框

208
00:06:23,519 --> 00:06:24,519
你读出来

209
00:06:24,560 --> 00:06:26,919
然后毛框又是我的算法

210
00:06:26,919 --> 00:06:27,800
生成出来的

211
00:06:27,800 --> 00:06:29,199
用来预测真实边缘框

212
00:06:29,199 --> 00:06:30,719
因为我也不知道真实边缘框是什么

213
00:06:30,759 --> 00:06:32,159
我就对每个图片

214
00:06:32,159 --> 00:06:35,000
反正就是说去生成一堆毛框

215
00:06:35,439 --> 00:06:36,199
就是说

216
00:06:36,799 --> 00:06:37,959
生成毛框的时候

217
00:06:37,959 --> 00:06:39,439
你不能看真实边缘框

218
00:06:39,439 --> 00:06:41,159
是因为你做预测的时候

219
00:06:41,160 --> 00:06:42,200
你没有真实边缘框

220
00:06:42,200 --> 00:06:43,520
你生成毛框

221
00:06:43,520 --> 00:06:44,520
直接做预测

222
00:06:45,040 --> 00:06:47,520
然后用MS去除相似的

223
00:06:48,000 --> 00:06:49,600
然后在训练的时候

224
00:06:49,600 --> 00:06:52,120
我需要对每个毛框算标好

225
00:06:52,120 --> 00:06:52,720
给标好

226
00:06:52,720 --> 00:06:53,280
那么就是说

227
00:06:53,280 --> 00:06:55,960
要去看真实边缘框去给标好

228
00:06:56,160 --> 00:06:56,720
OK

229
00:06:58,040 --> 00:06:58,920
所以就是说

230
00:06:58,960 --> 00:07:00,240
训练的时候

231
00:07:00,680 --> 00:07:02,520
我们是有真实边缘框

232
00:07:02,640 --> 00:07:05,160
所以我就可以给毛框标好

233
00:07:05,160 --> 00:07:06,120
在预测的时候

234
00:07:06,120 --> 00:07:07,040
没有真实边缘框

235
00:07:07,040 --> 00:07:07,800
我只有毛框

236
00:07:07,800 --> 00:07:08,680
直接做预测

237
00:07:11,720 --> 00:07:12,920
这个东西是我们

238
00:07:13,120 --> 00:07:14,240
这个是怎么计算的

239
00:07:14,360 --> 00:07:15,880
这个东西你也挺厉害的

240
00:07:15,880 --> 00:07:16,960
把这个根号打出来了

241
00:07:18,320 --> 00:07:19,160
就是说

242
00:07:20,080 --> 00:07:21,200
毛框的

243
00:07:21,439 --> 00:07:23,000
就基本上你可以就是说

244
00:07:23,640 --> 00:07:25,160
这样子算的好

245
00:07:25,160 --> 00:07:26,080
这样子算的话

246
00:07:26,080 --> 00:07:27,200
就是说

247
00:07:27,800 --> 00:07:28,560
我

248
00:07:29,080 --> 00:07:30,280
我们之所以这么算

249
00:07:30,280 --> 00:07:31,160
就是说这么

250
00:07:31,160 --> 00:07:33,000
首先它这两个高度

251
00:07:33,000 --> 00:07:34,879
是可以保证它们的ratio

252
00:07:34,879 --> 00:07:37,160
就是说它除以它

253
00:07:37,160 --> 00:07:37,879
是等于

254
00:07:38,879 --> 00:07:44,600
r是有保证的ratio的

255
00:07:46,360 --> 00:07:48,439
第二个是说

256
00:07:50,240 --> 00:07:51,560
当然是说你的h

257
00:07:51,560 --> 00:07:52,279
h来到这里

258
00:07:52,279 --> 00:07:54,079
h假设是一个方块的话

259
00:07:55,120 --> 00:07:57,719
第二个是说你的

260
00:07:58,639 --> 00:08:01,759
面积它是等于s的

261
00:08:01,759 --> 00:08:06,159
OK

262
00:08:06,159 --> 00:08:09,079
我觉得我们这里可能写错了

263
00:08:09,079 --> 00:08:10,759
应该我觉得s是应该

264
00:08:10,759 --> 00:08:11,839
还要放到根号里面

265
00:08:11,839 --> 00:08:13,759
我可能我这里敲错了

266
00:08:13,759 --> 00:08:14,279
OK

267
00:08:17,079 --> 00:08:19,240
蓝色紫色淡蓝色都是你的

268
00:08:19,240 --> 00:08:20,079
就都一样好

269
00:08:20,079 --> 00:08:21,360
怎么样比较呢

270
00:08:24,079 --> 00:08:25,800
我不是特别知道

271
00:08:25,800 --> 00:08:27,560
你是说样例是吧

272
00:08:27,560 --> 00:08:27,920
就是说

273
00:08:32,759 --> 00:08:34,080
我们就没时间了

274
00:08:34,080 --> 00:08:35,319
我就先pass

275
00:08:35,319 --> 00:08:35,559
这个

276
00:08:36,879 --> 00:08:38,240
就是说我觉得

277
00:08:38,840 --> 00:08:41,120
这个是我们构造的人工数据

278
00:08:41,360 --> 00:08:42,679
这个跟真实的有区别

279
00:08:42,679 --> 00:08:44,039
是给大家随便画两个图

280
00:08:44,039 --> 00:08:45,360
给大家展示一下效果

281
00:08:46,480 --> 00:08:48,559
为什么给每个像素做毛框

282
00:08:49,319 --> 00:08:50,720
为什么给每个像做毛框

283
00:08:50,720 --> 00:08:53,840
这样子我能有足够多的覆盖率

284
00:08:54,559 --> 00:08:56,319
所以但是好坏处是说

285
00:08:56,319 --> 00:08:58,000
会生成非常多的毛框

286
00:08:58,519 --> 00:09:00,840
毛框的损失高速

287
00:09:01,080 --> 00:09:02,519
损失函数吗

288
00:09:02,840 --> 00:09:05,040
损失函数就是一个回归问题

289
00:09:05,160 --> 00:09:06,480
就是他预测 offset

290
00:09:06,879 --> 00:09:08,360
PnE就是一个回归问题

291
00:09:08,360 --> 00:09:09,639
我们之后会讲

292
00:09:10,040 --> 00:09:12,680
Loss我们会跟大家后面讲

293
00:09:12,680 --> 00:09:14,200
就讲到具体算法的时候

294
00:09:14,200 --> 00:09:16,000
我们是讲损失怎么定义的

295
00:09:16,000 --> 00:09:17,040
我们还没有讲算法

296
00:09:17,200 --> 00:09:20,240
我们只讲怎么处理一些技术点

297
00:09:21,399 --> 00:09:23,280
两个真实框离得很近

298
00:09:23,280 --> 00:09:24,600
或者重叠的时候怎么办

299
00:09:25,080 --> 00:09:27,680
一个行站在一辆车前面

300
00:09:27,960 --> 00:09:32,480
两个离得很近的人是没事的

301
00:09:32,480 --> 00:09:33,440
他离得很近

302
00:09:33,440 --> 00:09:34,600
他是不重叠的

303
00:09:34,600 --> 00:09:36,920
一个行人站在车前面也没问题

304
00:09:36,920 --> 00:09:38,160
是因为车比较大

305
00:09:38,160 --> 00:09:39,240
行人比较小

306
00:09:41,600 --> 00:09:42,320
就是说

307
00:09:43,520 --> 00:09:45,920
行人在车前面是没问题

308
00:09:45,920 --> 00:09:47,360
就是说你车包含了行人

309
00:09:47,360 --> 00:09:48,240
他里面是没问题

310
00:09:48,240 --> 00:09:49,800
因为这两个有问题

311
00:09:49,800 --> 00:09:50,920
就是说我两个框

312
00:09:50,920 --> 00:09:52,560
基本上重叠的是有问题的

313
00:09:52,560 --> 00:09:53,880
所以你这个情况

314
00:09:53,920 --> 00:09:55,240
这两个情况都没问题

315
00:09:55,280 --> 00:09:56,400
除非就是说一个人

316
00:09:56,399 --> 00:09:57,759
一前一后站在这个地方

317
00:09:58,199 --> 00:09:59,600
我前面还站了一个人

318
00:09:59,600 --> 00:10:00,159
跟我

319
00:10:00,639 --> 00:10:01,759
那是个鬼故事

320
00:10:01,759 --> 00:10:03,519
我前面还有一个人

321
00:10:03,559 --> 00:10:05,000
可以把我基本上挡住

322
00:10:05,000 --> 00:10:06,240
如果把我挡住就没问题

323
00:10:06,240 --> 00:10:07,039
就不用框我了

324
00:10:07,039 --> 00:10:07,439
对吧

325
00:10:09,759 --> 00:10:12,319
能够根据特征点筛选像素

326
00:10:12,319 --> 00:10:13,199
再贴加毛框吗

327
00:10:13,199 --> 00:10:13,600
可以的

328
00:10:13,600 --> 00:10:14,559
这个就是说

329
00:10:15,399 --> 00:10:16,519
有些比如说ULO

330
00:10:16,679 --> 00:10:18,360
ULO是会根据你的

331
00:10:18,879 --> 00:10:19,879
做一些clustering

332
00:10:20,079 --> 00:10:21,000
这种东西来

333
00:10:21,000 --> 00:10:22,919
就是说根据先验知识来选毛框

334
00:10:23,039 --> 00:10:25,480
不是说去真的每个像素过一遍

335
00:10:25,480 --> 00:10:27,480
我们之所以这么讲

336
00:10:27,680 --> 00:10:30,279
首先我们今天讲的东西

337
00:10:30,399 --> 00:10:32,200
只是一个一种

338
00:10:32,240 --> 00:10:34,800
我觉得也还常用的

339
00:10:34,920 --> 00:10:35,320
第二

340
00:10:36,360 --> 00:10:39,039
能够用python给你实现出来的一种

341
00:10:39,200 --> 00:10:39,639
东西

342
00:10:40,159 --> 00:10:40,800
但是反过来讲

343
00:10:40,800 --> 00:10:42,039
有很多种别的方法

344
00:10:42,039 --> 00:10:43,440
就是说这个绝对不是最优的

345
00:10:43,440 --> 00:10:43,840
有

346
00:10:44,120 --> 00:10:46,000
目前市面我们目标检测

347
00:10:46,000 --> 00:10:46,879
不会讲到最优

348
00:10:46,879 --> 00:10:47,399
最优的话

349
00:10:47,399 --> 00:10:49,159
里面太有工程点在里面了

350
00:10:49,200 --> 00:10:50,879
我们没时间讲完

351
00:10:50,920 --> 00:10:52,480
所以我们讲的是一个

352
00:10:52,519 --> 00:10:53,759
也还常用的

353
00:10:53,919 --> 00:10:55,960
方法给大家过一遍

354
00:10:55,960 --> 00:10:56,840
也还简单的方法

355
00:10:56,840 --> 00:10:57,679
给大家过一遍

356
00:10:57,679 --> 00:10:59,639
整个是长什么样子

357
00:10:59,679 --> 00:11:01,399
但实际上大家用的

358
00:11:01,720 --> 00:11:02,439
真实用的

359
00:11:02,439 --> 00:11:03,240
可能跟我们讲的

360
00:11:03,240 --> 00:11:04,080
会有一定区别

361
00:11:04,240 --> 00:11:05,000
真实用的

362
00:11:05,039 --> 00:11:06,799
而且我们之后会讲SSD

363
00:11:06,799 --> 00:11:08,319
具体讲SSD的实现

364
00:11:08,360 --> 00:11:10,319
实际上SSD现在用的很少了

365
00:11:10,799 --> 00:11:12,720
要么用RCM系列

366
00:11:12,720 --> 00:11:14,240
要么用ULO系列

367
00:11:14,279 --> 00:11:15,799
但我们之所以讲它

368
00:11:15,840 --> 00:11:17,919
主要是因为它够简单

369
00:11:18,039 --> 00:11:20,519
而且实现起来相对说比较简单

370
00:11:20,519 --> 00:11:22,879
可以让大家去从python银行

371
00:11:22,919 --> 00:11:24,399
往延文去理解它

372
00:11:24,399 --> 00:11:25,120
OK

