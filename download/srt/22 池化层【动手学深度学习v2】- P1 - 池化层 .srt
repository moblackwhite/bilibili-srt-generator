1
00:00:00,000 --> 00:00:02,280
就你怎么定义前面后面

2
00:00:02,280 --> 00:00:03,200
就是说

3
00:00:03,560 --> 00:00:05,280
就是说你假设你一个卷积层

4
00:00:05,280 --> 00:00:06,160
一个齿化层

5
00:00:06,160 --> 00:00:06,919
一个卷积层

6
00:00:06,919 --> 00:00:08,160
一个齿化层

7
00:00:08,160 --> 00:00:10,400
那么你说第一个齿化层是放在后面

8
00:00:10,400 --> 00:00:11,240
还是放前面

9
00:00:11,240 --> 00:00:12,400
前面也是一个卷积

10
00:00:12,400 --> 00:00:13,160
后面也是卷积

11
00:00:13,160 --> 00:00:13,640
对吧

12
00:00:14,040 --> 00:00:15,400
通常语义上来说

13
00:00:15,400 --> 00:00:18,559
我们是把它放在后面

14
00:00:18,719 --> 00:00:20,760
就是说你是想说

15
00:00:20,760 --> 00:00:24,519
我让我的卷积层的输出

16
00:00:24,519 --> 00:00:26,320
不那么对位置敏感

17
00:00:26,320 --> 00:00:28,280
就是对输出上作用

18
00:00:28,280 --> 00:00:30,160
对它的输出作用是此话

19
00:00:30,160 --> 00:00:34,520
使得它能够把那些输出的值

20
00:00:34,520 --> 00:00:36,079
在像素的附近里面

21
00:00:36,079 --> 00:00:37,799
都给你弄出来

22
00:00:38,439 --> 00:00:39,719
所以通常语义上来说

23
00:00:39,719 --> 00:00:40,880
我们是放在后面

24
00:00:43,560 --> 00:00:44,400
问题二

25
00:00:44,439 --> 00:00:48,840
齿化的窗口有重叠和没有重叠的影响如何

26
00:00:49,200 --> 00:00:52,400
其实我觉得没什么影响

27
00:00:52,439 --> 00:00:58,079
通常来说

28
00:00:58,079 --> 00:01:02,200
大家说我们不做重叠

29
00:01:02,200 --> 00:01:03,560
是因为我觉得

30
00:01:04,519 --> 00:01:06,959
大家可能就是这么做的

31
00:01:06,959 --> 00:01:08,879
但实际上来说

32
00:01:08,879 --> 00:01:10,879
如果你真的去做验证

33
00:01:10,879 --> 00:01:12,560
说到底有没有区别

34
00:01:12,640 --> 00:01:15,439
我觉得可能没有太多区别

35
00:01:15,480 --> 00:01:17,960
我之前看过一些文章

36
00:01:17,960 --> 00:01:20,799
没有大家说就太多区别

37
00:01:20,879 --> 00:01:23,920
但是我不能保证这个时效性

38
00:01:24,079 --> 00:01:28,079
因为我们现在齿化层用的越来越少

39
00:01:28,439 --> 00:01:30,560
当然我们得讲这个东西

40
00:01:30,560 --> 00:01:33,319
但我们现在的可以之后可以看到说

41
00:01:33,359 --> 00:01:38,039
大家其实越来越不用齿化层

42
00:01:39,719 --> 00:01:44,959
所以它的出现的变得比较的没那么明显

43
00:01:45,079 --> 00:01:46,159
它可能就比如说

44
00:01:46,159 --> 00:01:47,280
你有100个卷积层

45
00:01:47,280 --> 00:01:49,280
里面可能就几个齿化层

46
00:01:49,359 --> 00:01:51,560
所以可能大家没有真的去验证说

47
00:01:51,560 --> 00:01:56,120
到底齿化层有没有特别重叠不重叠

48
00:01:56,120 --> 00:01:57,560
小小区别有没有影响

49
00:01:57,560 --> 00:01:59,840
所以我觉得如果你特别感兴趣

50
00:01:59,840 --> 00:02:00,760
可以去试一下

51
00:02:00,799 --> 00:02:03,159
但我个人觉得可能问题不大

52
00:02:05,040 --> 00:02:05,319
好

53
00:02:05,319 --> 00:02:06,319
问题三

54
00:02:11,479 --> 00:02:11,680
好

55
00:02:11,680 --> 00:02:13,479
问题三是一个不是那么相关的问题

56
00:02:13,599 --> 00:02:14,520
但是也是一个问题

57
00:02:14,560 --> 00:02:15,560
我们也看一下

58
00:02:15,560 --> 00:02:17,599
就是说想得到一个矩阵

59
00:02:17,599 --> 00:02:20,280
先创建一个同样尺寸的零矩阵

60
00:02:20,319 --> 00:02:22,159
然后再一个一个往里面填

61
00:02:22,199 --> 00:02:24,840
这种方式是不是比较省内存

62
00:02:24,879 --> 00:02:26,439
运行速度是不是比较快

63
00:02:26,439 --> 00:02:28,319
如果不确定结果的行数或列数

64
00:02:28,319 --> 00:02:28,919
怎么解决

65
00:02:29,159 --> 00:02:31,039
矩阵凭借速度太慢了

66
00:02:33,159 --> 00:02:34,879
你创建一个零矩阵

67
00:02:34,879 --> 00:02:36,359
再一个一个往里面填

68
00:02:36,359 --> 00:02:37,799
不是一件很好的办法

69
00:02:37,799 --> 00:02:39,680
因为你如果是一个for loop

70
00:02:39,680 --> 00:02:40,400
往里面填的话

71
00:02:40,400 --> 00:02:41,519
你的性能就没了

72
00:02:41,680 --> 00:02:43,519
我们有讲过吗

73
00:02:43,519 --> 00:02:44,759
我们可能还没有讲

74
00:02:45,159 --> 00:02:45,879
我都不记得了

75
00:02:45,879 --> 00:02:47,280
反正我们要么之前讲过

76
00:02:47,280 --> 00:02:48,560
要么之后一定会讲的

77
00:02:48,680 --> 00:02:49,439
就是说

78
00:02:49,599 --> 00:02:54,759
Python去调用一次计算的开销非常大

79
00:02:55,920 --> 00:02:59,680
大到你可能会觉得怀疑人生

80
00:03:00,120 --> 00:03:02,719
所以你还要可能你去一个一个往里面

81
00:03:02,719 --> 00:03:04,199
填写个for loop往里面填的

82
00:03:04,199 --> 00:03:06,800
说你的基本上你就是因为Python的问题

83
00:03:06,960 --> 00:03:08,319
当然Python的创始人

84
00:03:08,319 --> 00:03:11,920
那个老哥不是最近去说去微软

85
00:03:11,920 --> 00:03:14,039
要在未来几年之内把Python

86
00:03:14,039 --> 00:03:15,759
那个速度提升个两三倍

87
00:03:16,199 --> 00:03:17,639
Python就是他那个C的

88
00:03:17,639 --> 00:03:20,759
那个叫做foreign language interface

89
00:03:20,759 --> 00:03:21,239
那个东西

90
00:03:21,239 --> 00:03:23,919
FFI他的效率不是很高

91
00:03:24,039 --> 00:03:26,879
通常他有一些特殊的优化做的还行

92
00:03:26,879 --> 00:03:28,239
但是实际上你写起来

93
00:03:28,239 --> 00:03:29,439
很有可能就是很慢的

94
00:03:29,679 --> 00:03:32,319
所以你千万不要去一个一个调

95
00:03:33,959 --> 00:03:36,039
所以我觉得这个地方

96
00:03:36,079 --> 00:03:37,439
你要创造一个矩阵的话

97
00:03:37,439 --> 00:03:39,319
你最好是就创造出来就是了

98
00:03:39,359 --> 00:03:40,959
而且创造矩阵的本身

99
00:03:40,959 --> 00:03:43,399
其实你就重复几次

100
00:03:43,399 --> 00:03:43,919
so what

101
00:03:43,919 --> 00:03:45,599
我觉得问题不大了

102
00:03:45,759 --> 00:03:48,719
反正就是说你尽量的少去调用

103
00:03:48,719 --> 00:03:50,439
Python的函数

104
00:03:50,479 --> 00:03:52,199
我觉得这个绝对是没错的

105
00:03:52,239 --> 00:03:54,759
第二点是说你不要担心内存

106
00:03:54,759 --> 00:03:55,719
因为矩阵内存

107
00:03:55,719 --> 00:03:58,359
你这个矩阵一旦没用之后

108
00:03:58,359 --> 00:03:59,599
他会自动释放

109
00:03:59,639 --> 00:04:00,919
他也不那么智能

110
00:04:01,039 --> 00:04:03,599
这样多多少少的会自动释放

111
00:04:03,719 --> 00:04:05,439
除非你特别的卡性能

112
00:04:05,439 --> 00:04:07,479
不然的话不一定要这么做

113
00:04:07,959 --> 00:04:11,280
一般来说我们就是一次性的往里面写

114
00:04:11,280 --> 00:04:11,919
这是OK的

115
00:04:11,919 --> 00:04:13,599
就是放空号冒号

116
00:04:14,599 --> 00:04:17,399
如果不确信结果的函数和列数

117
00:04:17,399 --> 00:04:18,240
一般怎么解决

118
00:04:18,399 --> 00:04:19,600
矩阵拼接太慢了

119
00:04:19,959 --> 00:04:21,240
这个事情就是

120
00:04:21,839 --> 00:04:22,959
这个是一个很难的事情

121
00:04:23,199 --> 00:04:25,800
就是说你不确定函数和列数的话

122
00:04:30,399 --> 00:04:31,639
你一个什么办法

123
00:04:31,800 --> 00:04:33,639
你先用你不要用矩阵

124
00:04:33,680 --> 00:04:35,879
你用一个Python的list

125
00:04:36,000 --> 00:04:37,480
一个list of list

126
00:04:37,839 --> 00:04:41,040
就是说你用Python的list

127
00:04:41,159 --> 00:04:42,560
不要用去tensor

128
00:04:42,600 --> 00:04:44,439
就是说你用你创造一个list of list

129
00:04:44,439 --> 00:04:45,480
里面有pen的pen

130
00:04:45,480 --> 00:04:47,079
Python倒是做了一些优化了

131
00:04:47,079 --> 00:04:49,319
因为他的Python自己的那些操作

132
00:04:49,319 --> 00:04:50,199
还做得挺好的

133
00:04:50,319 --> 00:04:51,480
他内存有优化

134
00:04:51,480 --> 00:04:53,360
所以你把里面填填填填填

135
00:04:53,399 --> 00:04:56,519
然后再把它用list of list转到

136
00:04:56,560 --> 00:04:57,319
转成tensor

137
00:04:57,360 --> 00:04:59,040
这通常是会比较好一点

138
00:04:59,800 --> 00:05:01,920
当你用矩阵那种拼

139
00:05:01,920 --> 00:05:03,399
基本上你性能就不要想了

140
00:05:03,399 --> 00:05:03,959
怎么样

141
00:05:04,519 --> 00:05:05,040
OK

142
00:05:06,439 --> 00:05:07,279
问题4

143
00:05:07,840 --> 00:05:09,920
为什么之前有个padding里面

144
00:05:09,920 --> 00:05:11,560
用的是一个元组

145
00:05:11,680 --> 00:05:13,759
Padding是有一个高和一个宽

146
00:05:14,120 --> 00:05:15,040
因为是2D的

147
00:05:16,040 --> 00:05:18,439
所以假设你指定一个数的话

148
00:05:18,439 --> 00:05:19,879
我们卷集有讲过

149
00:05:19,920 --> 00:05:21,079
假设指定一个数的话

150
00:05:21,079 --> 00:05:23,560
意味着是行和宽的拼接

151
00:05:23,600 --> 00:05:25,720
它的Padding都是等于那个值

152
00:05:25,840 --> 00:05:27,840
如果你是用的一个元组的话

153
00:05:27,840 --> 00:05:30,480
那么前面就是你的高的Padding

154
00:05:30,480 --> 00:05:32,079
就是对行的Padding

155
00:05:32,800 --> 00:05:34,439
后面一个就是对于宽

156
00:05:34,439 --> 00:05:35,759
就是对列的Padding

157
00:05:35,920 --> 00:05:37,720
所以是你可以拍成一个

158
00:05:37,720 --> 00:05:39,360
Padding成一个不对称的形状

159
00:05:42,000 --> 00:05:45,720
问题5

160
00:05:45,720 --> 00:05:48,439
持话层后计算量

161
00:05:48,439 --> 00:05:50,600
是不是也减少了

162
00:05:52,120 --> 00:05:53,000
持话层

163
00:05:53,000 --> 00:05:56,480
当你如果有用的是不符等于2的话

164
00:05:56,480 --> 00:05:57,519
当然是会减少了

165
00:05:57,519 --> 00:05:59,439
就是不符等于2就减少一倍了

166
00:05:59,680 --> 00:06:01,480
如果你是没用的话

167
00:06:01,480 --> 00:06:04,199
你可能你如果加了一点Padding的话

168
00:06:04,199 --> 00:06:06,439
那就是那你那你

169
00:06:06,480 --> 00:06:08,600
你的输入和输出就没变化

170
00:06:08,800 --> 00:06:10,240
而且它通道数是不会变的

171
00:06:10,680 --> 00:06:13,639
所以持话层是可以减少计算量

172
00:06:13,680 --> 00:06:15,160
但有可能不会减少

173
00:06:16,480 --> 00:06:17,160
问题6

174
00:06:17,160 --> 00:06:19,960
为什么现在持话层用的越来越少了

175
00:06:20,240 --> 00:06:21,439
这个是很好的问题

176
00:06:21,639 --> 00:06:24,120
这个问题我是给我的个人理解

177
00:06:25,000 --> 00:06:26,840
不能保证说一定是对的

178
00:06:27,639 --> 00:06:29,439
我的理解是因为

179
00:06:30,840 --> 00:06:34,519
持话层它其实就是它有两个作用

180
00:06:34,639 --> 00:06:36,720
一个是它确实把你的

181
00:06:36,840 --> 00:06:38,879
让你的卷积的位置没那么敏感

182
00:06:39,319 --> 00:06:42,120
第二个作用其实也是之前问题5回答的

183
00:06:42,120 --> 00:06:45,240
就是经常我们用一个stride等于2

184
00:06:45,519 --> 00:06:48,759
这样子能把输入把你的输出减少一点

185
00:06:49,199 --> 00:06:50,360
使得你计算变少

186
00:06:51,000 --> 00:06:55,360
但现在我们通常是用一个

187
00:06:55,399 --> 00:06:58,560
用一个卷积层加一个stride来减少

188
00:06:58,560 --> 00:07:01,159
就不你可以你stride可以放在卷积

189
00:07:01,159 --> 00:07:01,399
对吧

190
00:07:01,399 --> 00:07:03,240
你也可以放在持话

191
00:07:03,279 --> 00:07:04,439
如果放在卷积的话

192
00:07:04,439 --> 00:07:06,120
那我持话层这个功能就没了

193
00:07:07,120 --> 00:07:08,959
第二个是说

194
00:07:12,959 --> 00:07:15,160
因为我们之后会讲这个事情

195
00:07:15,160 --> 00:07:18,840
因为我们会做数据做大量的增强

196
00:07:18,840 --> 00:07:21,360
就我们数据本身图片

197
00:07:21,399 --> 00:07:24,399
我们会去把它移一点

198
00:07:24,439 --> 00:07:27,160
把它往crop一个出来

199
00:07:27,160 --> 00:07:28,319
把它放大放小

200
00:07:28,319 --> 00:07:29,879
移一点位置旋转

201
00:07:29,920 --> 00:07:33,040
就是说我们会对数据本身

202
00:07:33,040 --> 00:07:35,319
做很多这样子的扰动操作

203
00:07:35,439 --> 00:07:37,920
使得你的卷积神机网络

204
00:07:37,959 --> 00:07:40,439
可以看到你的数据本身

205
00:07:40,439 --> 00:07:41,839
就会发生很多变化的

206
00:07:42,079 --> 00:07:44,959
所以就是说我们在数据里面

207
00:07:45,159 --> 00:07:49,680
使得你的卷积才不会那么去过

208
00:07:49,680 --> 00:07:51,240
你到某个具体的位置

209
00:07:51,680 --> 00:07:55,079
所以这个东西就淡化了持话层的作用

210
00:07:55,759 --> 00:07:57,759
所以这我理解就是这两个原因

211
00:07:57,759 --> 00:07:58,839
导致我们持话层

212
00:07:58,839 --> 00:08:00,680
其实现在还用的不多

213
00:08:00,800 --> 00:08:01,680
但最后的最后

214
00:08:01,680 --> 00:08:03,360
我们会用一个最后的一个持话层

215
00:08:03,360 --> 00:08:04,039
我们之后会讲

216
00:08:04,200 --> 00:08:05,040
就是会把你的东西

217
00:08:05,040 --> 00:08:07,640
变成一个单数字

218
00:08:10,000 --> 00:08:11,080
问题七

219
00:08:11,080 --> 00:08:12,000
怎么理解持话层

220
00:08:12,000 --> 00:08:14,560
可以缓解卷积层对位置的敏感度

221
00:08:15,560 --> 00:08:16,200
我们讲过了

222
00:08:18,320 --> 00:08:19,720
假设你卷积层

223
00:08:20,360 --> 00:08:23,240
他可能在某个位置输出1

224
00:08:23,280 --> 00:08:25,080
如果你像素偏移一下

225
00:08:25,080 --> 00:08:26,480
这个1就会往那边移一下

226
00:08:26,480 --> 00:08:26,879
对吧

227
00:08:27,439 --> 00:08:28,879
有了持话层之后

228
00:08:28,920 --> 00:08:31,560
你因为你1的附近

229
00:08:31,560 --> 00:08:33,039
我会给你贴加另外一行

230
00:08:33,240 --> 00:08:34,199
所以你一下之后

231
00:08:34,199 --> 00:08:36,240
我同样位置还会有1

232
00:08:40,599 --> 00:08:46,719
持话层是不是类似于做正则

233
00:08:51,519 --> 00:08:54,759
我倒是觉得不那么像正则

234
00:08:54,759 --> 00:08:56,120
正则的

235
00:08:56,919 --> 00:09:03,560
看你怎么说

236
00:09:03,560 --> 00:09:08,320
正则他就是要控制模型的复杂度

237
00:09:08,519 --> 00:09:11,039
但是持话层

238
00:09:11,279 --> 00:09:13,480
他其实就是在你数据面

239
00:09:13,519 --> 00:09:16,840
你可以认为是给下一次输入的数据

240
00:09:16,840 --> 00:09:19,720
里面做了一下平移

241
00:09:19,799 --> 00:09:22,639
或者一下这样子的扰动这样的操作

242
00:09:22,680 --> 00:09:23,799
但我觉得

243
00:09:24,720 --> 00:09:26,760
类能不能叫正则

244
00:09:26,760 --> 00:09:27,720
我还真不能保证

245
00:09:27,720 --> 00:09:28,960
我还没想过这个问题

246
00:09:28,960 --> 00:09:31,280
但是他就是让你的

247
00:09:31,320 --> 00:09:35,000
等于是对你的中间数据做一次改动

248
00:09:35,760 --> 00:09:37,600
但是他等不待正则

249
00:09:37,600 --> 00:09:38,680
我还真没去想过

250
00:09:38,680 --> 00:09:39,440
这是个天花的问题

251
00:09:39,440 --> 00:09:42,720
我可能就我等大家去查一下

252
00:09:42,720 --> 00:09:45,320
有没有人说持话层是一个政策

253
00:09:46,440 --> 00:09:47,040
OK

