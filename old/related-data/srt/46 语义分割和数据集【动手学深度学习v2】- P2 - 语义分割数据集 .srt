1
00:00:00,000 --> 00:00:03,080
在语义分割里面

2
00:00:03,080 --> 00:00:07,919
一个很重要的数据叫做PASCA VOC2012

3
00:00:07,919 --> 00:00:10,120
就是PASCA是一个组织

4
00:00:10,120 --> 00:00:11,679
VOC是一个竞赛

5
00:00:11,679 --> 00:00:15,080
2012是他们在12年做的一个竞赛

6
00:00:15,080 --> 00:00:17,120
之所以为什么选12年

7
00:00:17,120 --> 00:00:19,199
是因为后面的那些年的竞赛

8
00:00:19,199 --> 00:00:21,960
基本上可以认为主要是在12年的基础上

9
00:00:21,960 --> 00:00:23,120
做了一些修改

10
00:00:23,120 --> 00:00:28,719
所以我们这里直接用的是VOC2012这个数据集

11
00:00:29,039 --> 00:00:30,640
这个数据集下载下来

12
00:00:30,640 --> 00:00:34,399
应该还有大概几百兆的样子

13
00:00:34,399 --> 00:00:36,640
所以你像我刚刚下了一下

14
00:00:36,640 --> 00:00:39,239
大概我这里下了一分钟的样子

15
00:00:39,239 --> 00:00:41,039
如果大家去下的话

16
00:00:41,039 --> 00:00:42,840
可能会下的会比较久一点点

17
00:00:42,840 --> 00:00:44,159
可能要几分钟的样子

18
00:00:44,159 --> 00:00:46,599
我记的是几个G的样子

19
00:00:47,599 --> 00:00:47,960
OK

20
00:00:47,960 --> 00:00:50,359
这段代码的主要意思是

21
00:00:50,359 --> 00:00:53,960
我们从一个地方把原始的数据下下来

22
00:00:54,079 --> 00:00:55,079
然后下下之后

23
00:00:55,079 --> 00:00:56,000
我们把它解压

24
00:00:56,000 --> 00:00:57,879
解压放在文件夹里面

25
00:00:59,039 --> 00:01:01,399
好

26
00:01:01,399 --> 00:01:02,759
接下来事情干嘛

27
00:01:02,920 --> 00:01:05,959
接下来我们就是把所有的图片读到内存里了

28
00:01:06,359 --> 00:01:07,920
这个也是一个很暴力的操作

29
00:01:08,680 --> 00:01:09,599
因为一般来说

30
00:01:09,599 --> 00:01:10,920
你我们讲过很多次

31
00:01:10,920 --> 00:01:11,519
一般来说

32
00:01:11,519 --> 00:01:12,519
你特别大的数据机

33
00:01:12,519 --> 00:01:13,799
你是不会干这个事情的

34
00:01:13,959 --> 00:01:15,159
但这里还好

35
00:01:15,159 --> 00:01:17,159
就是说我们这个就几千张图片

36
00:01:17,400 --> 00:01:19,000
读进来其实也问题不大

37
00:01:19,039 --> 00:01:20,680
所以为了方便期间

38
00:01:20,680 --> 00:01:21,920
我们就直接读进来了

39
00:01:22,759 --> 00:01:24,280
首先我们看一下

40
00:01:24,280 --> 00:01:25,799
首先我们看一下

41
00:01:25,799 --> 00:01:27,359
就是说它这个数据集

42
00:01:27,359 --> 00:01:28,400
它有自己的格式

43
00:01:28,400 --> 00:01:29,440
叫VOC格式

44
00:01:29,440 --> 00:01:31,359
VOC格式是一个

45
00:01:31,560 --> 00:01:35,280
我觉得是一个用的非常广泛的一种格式

46
00:01:36,600 --> 00:01:38,360
就是VOC

47
00:01:38,360 --> 00:01:39,880
QQ是几大

48
00:01:40,200 --> 00:01:42,520
现在是比较有名的数据集

49
00:01:42,520 --> 00:01:43,280
有名的数据集

50
00:01:43,280 --> 00:01:44,400
都有自己的格式

51
00:01:44,400 --> 00:01:47,520
所以VOC是有一个自己的格式

52
00:01:47,520 --> 00:01:50,160
所以而且大家觉得格式也不错

53
00:01:50,360 --> 00:01:52,760
很多新的数据机也使用它的格式

54
00:01:53,080 --> 00:01:54,000
首先我们看一下

55
00:01:54,000 --> 00:01:56,000
它的图片分割的格式

56
00:01:56,000 --> 00:01:56,719
长什么样子

57
00:01:57,319 --> 00:01:59,319
首先它里面在

58
00:02:00,159 --> 00:02:02,039
你在它的root文件夹下面

59
00:02:02,039 --> 00:02:03,079
然后有个image

60
00:02:03,079 --> 00:02:03,760
set

61
00:02:03,760 --> 00:02:05,200
然后进入segmentation

62
00:02:05,200 --> 00:02:06,640
就是说它里面其实有很多任务

63
00:02:07,120 --> 00:02:08,120
因为你要想

64
00:02:08,120 --> 00:02:11,280
如果我有图片分割的标号的话

65
00:02:11,280 --> 00:02:13,319
那么很容易可以变成一个物体检测

66
00:02:13,319 --> 00:02:13,759
对吧

67
00:02:14,360 --> 00:02:17,240
我就把你相似外面的bonded box

68
00:02:17,240 --> 00:02:18,079
给你算出来

69
00:02:19,000 --> 00:02:20,439
同样道理的话

70
00:02:20,800 --> 00:02:21,599
你有

71
00:02:22,280 --> 00:02:23,680
你有目标检测的话

72
00:02:23,840 --> 00:02:25,560
我很容易把它变成一个

73
00:02:26,080 --> 00:02:27,199
图片分类的问题

74
00:02:27,879 --> 00:02:28,680
当然图片分类

75
00:02:28,680 --> 00:02:30,680
你可能要对图片做一些剪裁

76
00:02:30,680 --> 00:02:31,159
不然的话

77
00:02:31,159 --> 00:02:32,719
你里面有多个物体的话

78
00:02:32,719 --> 00:02:35,439
那么你可能分类就比较有奇异

79
00:02:36,360 --> 00:02:36,920
OK

80
00:02:37,039 --> 00:02:39,640
所以它的里面叫做

81
00:02:39,680 --> 00:02:41,759
它有一个train.txt

82
00:02:42,000 --> 00:02:43,439
这个文件就是说告诉你说

83
00:02:43,439 --> 00:02:46,039
哪些图片是用来做训练的

84
00:02:46,360 --> 00:02:47,319
var.txt

85
00:02:47,319 --> 00:02:48,800
就是说哪些图片

86
00:02:49,000 --> 00:02:49,680
就是文件名

87
00:02:49,879 --> 00:02:54,400
是用来做你的验证机了

88
00:02:54,879 --> 00:02:56,760
所以我们如果是train.txt的话

89
00:02:56,840 --> 00:02:58,840
我们去加载你的训练数据机

90
00:02:58,879 --> 00:03:00,520
如果是等于false的话

91
00:03:00,640 --> 00:03:02,520
去加载你的验证数据机

92
00:03:03,520 --> 00:03:06,400
然后当然是说这里面是一个RGB的

93
00:03:06,400 --> 00:03:07,400
一个格式

94
00:03:07,800 --> 00:03:09,120
因为这是彩色图片了

95
00:03:09,640 --> 00:03:10,480
我们读进来

96
00:03:11,159 --> 00:03:11,920
读进来之后

97
00:03:11,920 --> 00:03:12,719
我们干什么事情

98
00:03:12,719 --> 00:03:14,599
就是把每个图片给你读进来了

99
00:03:14,960 --> 00:03:16,879
可以看到是

100
00:03:18,480 --> 00:03:19,439
就可以看到是说

101
00:03:19,439 --> 00:03:21,800
我们这里对每一个文件名

102
00:03:22,319 --> 00:03:23,120
每个文件名

103
00:03:23,120 --> 00:03:23,960
我们会去

104
00:03:23,960 --> 00:03:26,080
它是没有后缀的

105
00:03:26,080 --> 00:03:28,000
它就是一个什么12234

106
00:03:28,000 --> 00:03:28,800
这样子

107
00:03:29,039 --> 00:03:32,000
然后我们去把首先把图片读进来

108
00:03:32,319 --> 00:03:33,439
它图片在什么地方

109
00:03:33,960 --> 00:03:36,039
图片在它的root下面

110
00:03:36,200 --> 00:03:38,920
就根文件下面有个jpgimages

111
00:03:39,120 --> 00:03:40,520
这是你的原始图片

112
00:03:41,280 --> 00:03:42,960
然后你对它点jpg

113
00:03:42,960 --> 00:03:43,719
你就把它读进来

114
00:03:43,719 --> 00:03:47,599
这就是你的用来训练的features

115
00:03:48,159 --> 00:03:48,439
好

116
00:03:48,439 --> 00:03:49,960
接下来看一下labels

117
00:03:50,480 --> 00:03:51,879
就这里会比较有意思的

118
00:03:51,879 --> 00:03:53,359
跟之前不一样的是说

119
00:03:53,680 --> 00:03:54,840
一分隔的label

120
00:03:55,359 --> 00:03:58,159
你需要对每一个像素有label

121
00:03:58,159 --> 00:03:58,599
对吧

122
00:04:00,000 --> 00:04:01,240
所以它的像素label

123
00:04:01,240 --> 00:04:02,280
你怎么存呢

124
00:04:02,759 --> 00:04:03,519
最简单情况

125
00:04:03,519 --> 00:04:05,240
我就可以存这张图片

126
00:04:06,319 --> 00:04:07,199
当然图片的话

127
00:04:07,199 --> 00:04:08,800
你最好不要存jpg

128
00:04:08,800 --> 00:04:10,680
jpg会做一些压缩

129
00:04:10,840 --> 00:04:12,400
它会在边缘有一些模糊

130
00:04:12,639 --> 00:04:15,280
就是说你就存成一个没有压缩的

131
00:04:15,280 --> 00:04:16,800
一个png的文件

132
00:04:17,519 --> 00:04:19,159
这就是说它的label

133
00:04:19,159 --> 00:04:21,600
就是在segmentation class

134
00:04:21,600 --> 00:04:22,640
文件夹下

135
00:04:22,840 --> 00:04:23,840
对应的文件名

136
00:04:23,840 --> 00:04:25,640
它存了一个png文件

137
00:04:26,680 --> 00:04:28,080
你把png文件读进来

138
00:04:28,080 --> 00:04:28,920
就它的label

139
00:04:29,240 --> 00:04:30,879
所以这样子的话

140
00:04:31,280 --> 00:04:33,360
就对于一分隔

141
00:04:33,600 --> 00:04:34,879
它的训练集

142
00:04:34,879 --> 00:04:36,560
它的一个训练样本里面

143
00:04:37,320 --> 00:04:42,800
它的训练数据是一个图片

144
00:04:43,000 --> 00:04:46,800
它的标号是跟它一样大小的一张图片

145
00:04:46,879 --> 00:04:50,720
而且它是每个pixel的值

146
00:04:50,720 --> 00:04:52,720
它对应的是你一个标号

147
00:04:52,760 --> 00:04:54,800
就是说如果这两个pixel一样的话

148
00:04:54,800 --> 00:04:55,960
那么它的标号是一样的

149
00:04:55,960 --> 00:04:56,520
如果不一样

150
00:04:56,520 --> 00:04:57,440
它就是不一样

151
00:04:58,320 --> 00:04:59,440
所以我们这样子

152
00:04:59,440 --> 00:04:59,760
就是说

153
00:04:59,760 --> 00:05:01,640
比如说我们把训练数据给读进来

154
00:05:01,880 --> 00:05:03,440
就拿到了我的训练图片

155
00:05:03,440 --> 00:05:05,120
和训练的标签

156
00:05:07,480 --> 00:05:09,040
我们来画一下长什么样子

157
00:05:09,200 --> 00:05:11,360
我们把这个东西稍微放大一点

158
00:05:11,360 --> 00:05:12,640
让大家看得清楚一点

159
00:05:14,320 --> 00:05:15,600
就我们干的什么事情

160
00:05:15,600 --> 00:05:16,600
我们就把它读进来

161
00:05:16,800 --> 00:05:18,000
读进来之后

162
00:05:18,279 --> 00:05:21,120
我们就把你的features

163
00:05:21,399 --> 00:05:24,120
就把前面5个的图片

164
00:05:24,160 --> 00:05:27,120
和你对应的标号给你画出来

165
00:05:27,759 --> 00:05:30,680
第一行就是画的是你的图片

166
00:05:31,040 --> 00:05:33,680
然后第二行画的是你的标号

167
00:05:34,560 --> 00:05:35,759
然后当然你要permute

168
00:05:35,759 --> 00:05:36,720
你可以大家不用管了

169
00:05:36,839 --> 00:05:37,839
permute就是说

170
00:05:37,839 --> 00:05:40,639
因为它读进来是把channel放到最后

171
00:05:40,879 --> 00:05:42,279
就是说但是你画的时候

172
00:05:42,399 --> 00:05:44,240
你又得把channel回

173
00:05:46,360 --> 00:05:47,680
就把channel回放到前面

174
00:05:47,720 --> 00:05:48,319
你画的时候

175
00:05:48,400 --> 00:05:49,840
你就把channel放到后面

176
00:05:51,240 --> 00:05:52,600
然后我们调整给我们的

177
00:05:52,600 --> 00:05:53,480
short image的看数

178
00:05:53,480 --> 00:05:54,519
可以看到是说

179
00:05:56,160 --> 00:05:57,160
大家应该能看清楚

180
00:05:57,600 --> 00:05:59,560
就是说第一张图片是一张飞机

181
00:06:00,560 --> 00:06:01,800
就我可以再放大一点

182
00:06:03,519 --> 00:06:04,120
OK

183
00:06:08,840 --> 00:06:09,800
不能放太大了

184
00:06:10,040 --> 00:06:10,560
OK

185
00:06:10,680 --> 00:06:12,519
第一张图片是一个飞机

186
00:06:12,920 --> 00:06:14,720
就飞机你看到飞机

187
00:06:14,720 --> 00:06:16,040
就这里有一架飞机

188
00:06:16,240 --> 00:06:18,879
飞机的所有的像素

189
00:06:19,080 --> 00:06:22,040
存在一个红色的像素里面

190
00:06:22,319 --> 00:06:23,960
就是你看红色存在

191
00:06:23,960 --> 00:06:24,840
是表示飞机

192
00:06:25,680 --> 00:06:27,200
然后有一个边框

193
00:06:27,400 --> 00:06:29,160
这个边框是一个白色的线

194
00:06:29,400 --> 00:06:31,840
这边框就是在人标的时候

195
00:06:32,080 --> 00:06:33,200
人标的时候就画

196
00:06:33,400 --> 00:06:35,080
就拿支笔去画边框

197
00:06:35,200 --> 00:06:37,600
画的笔就存成一个白色的

198
00:06:37,840 --> 00:06:39,120
当然说你可以不用管

199
00:06:39,320 --> 00:06:44,000
反正你可以认为就跟背景一样

200
00:06:44,000 --> 00:06:44,680
都没关系

201
00:06:45,280 --> 00:06:47,319
背景是黑色的

202
00:06:47,680 --> 00:06:48,879
一个全黑的像素

203
00:06:49,800 --> 00:06:50,959
看第二个图片

204
00:06:51,480 --> 00:06:53,000
第二个图片是一个电脑

205
00:06:53,280 --> 00:06:54,800
电脑一个很老的电脑

206
00:06:55,360 --> 00:06:56,000
电脑的话

207
00:06:56,000 --> 00:06:57,160
你能看到是说

208
00:06:57,600 --> 00:06:59,439
他用的是另外一个颜色的像素

209
00:06:59,600 --> 00:07:00,720
用的是蓝色

210
00:07:01,319 --> 00:07:01,840
同样的话

211
00:07:01,840 --> 00:07:02,680
后面就是背景了

212
00:07:02,680 --> 00:07:05,040
就是跟我不那么感兴趣的

213
00:07:05,040 --> 00:07:05,720
就是一个背景

214
00:07:06,000 --> 00:07:08,120
而且他其实这个地方也

215
00:07:08,280 --> 00:07:09,560
他其实不是不叫电脑

216
00:07:09,560 --> 00:07:10,800
他其实就是一个monitor

217
00:07:10,800 --> 00:07:12,160
他没有把keyboard

218
00:07:12,160 --> 00:07:14,079
就是把键盘边上的东西

219
00:07:14,439 --> 00:07:14,959
边上的东西

220
00:07:14,959 --> 00:07:15,479
我都不认识

221
00:07:15,479 --> 00:07:16,079
是什么东西

222
00:07:16,479 --> 00:07:18,359
是这个音响吗

223
00:07:18,359 --> 00:07:19,759
还是一个modem

224
00:07:20,079 --> 00:07:21,199
就没放进来

225
00:07:22,479 --> 00:07:23,680
然后再到这个地方

226
00:07:23,800 --> 00:07:24,919
这个地方是

227
00:07:25,000 --> 00:07:26,000
这个地方比较有意思

228
00:07:26,039 --> 00:07:27,199
他标了一只猫

229
00:07:27,439 --> 00:07:29,120
猫是紫色的

230
00:07:29,120 --> 00:07:30,199
猫在这个地方

231
00:07:30,319 --> 00:07:32,479
然后你后面猫在一个凳子上面

232
00:07:32,680 --> 00:07:33,879
凳子是红色的

233
00:07:34,199 --> 00:07:35,839
然后在下面是一只鸟

234
00:07:35,839 --> 00:07:37,799
然后在后面是一个显示器

235
00:07:38,120 --> 00:07:40,000
就是说同样道理的话

236
00:07:40,000 --> 00:07:41,519
他的键盘是没标的

237
00:07:41,519 --> 00:07:43,159
就是标了显示器和他的指甲

238
00:07:44,240 --> 00:07:46,240
你可看到是说这个地方

239
00:07:46,359 --> 00:07:47,479
每一个类

240
00:07:47,719 --> 00:07:50,919
它有一个对应的pixel的值

241
00:07:50,959 --> 00:07:52,560
就是一个RGB的值

242
00:07:53,079 --> 00:07:53,759
值不一样

243
00:07:53,759 --> 00:07:54,879
它的类别不一样

244
00:07:55,759 --> 00:07:57,039
背景都是黑的

245
00:07:57,079 --> 00:07:58,599
然后中间那个boundary

246
00:07:58,599 --> 00:07:59,680
那个画的线

247
00:07:59,839 --> 00:08:01,000
就是一个白色的

248
00:08:01,240 --> 00:08:02,680
所以基本上是说

249
00:08:02,680 --> 00:08:05,759
他的格式长成这个样子

250
00:08:05,919 --> 00:08:07,479
一般语言分割的话

251
00:08:08,120 --> 00:08:09,879
你反正一般也是这样子

252
00:08:10,159 --> 00:08:12,079
就是说最后

253
00:08:12,439 --> 00:08:16,000
颜色可能大家会挑的不一样一点

254
00:08:16,000 --> 00:08:16,839
但是最后的最后

255
00:08:16,839 --> 00:08:18,959
大家都是通过用不同的像素的颜色

256
00:08:18,959 --> 00:08:20,719
来表示不同的标号

257
00:08:23,120 --> 00:08:23,719
好

258
00:08:24,240 --> 00:08:25,800
然后我们就想知道说

259
00:08:26,199 --> 00:08:28,519
你当然是说我一个

260
00:08:28,839 --> 00:08:31,399
每一个标号的RGB的颜色

261
00:08:31,439 --> 00:08:33,000
对应的我的类是什么

262
00:08:33,480 --> 00:08:36,480
这个函数其实就是告诉你说

263
00:08:37,919 --> 00:08:39,360
我来稍微放大一点

264
00:08:40,159 --> 00:08:42,120
就是你的RGB的

265
00:08:42,879 --> 00:08:44,000
就是000的话

266
00:08:44,000 --> 00:08:45,800
就是黑的全黑的话

267
00:08:45,840 --> 00:08:47,360
那么对应的是background

268
00:08:48,120 --> 00:08:49,639
如果你是128

269
00:08:49,879 --> 00:08:50,879
就是红色的

270
00:08:51,039 --> 00:08:53,039
红色的是一半的是128

271
00:08:53,039 --> 00:08:55,240
然后00的话

272
00:08:55,240 --> 00:08:56,960
对应的是你的飞机

273
00:08:57,039 --> 00:09:00,440
然后后面还有大概我记得是10来个类的样子

274
00:09:01,759 --> 00:09:02,840
十几个类的样子

275
00:09:03,639 --> 00:09:04,159
OK

276
00:09:04,159 --> 00:09:08,200
所以说这个地方告诉你是每一个标号

277
00:09:08,280 --> 00:09:10,960
它对应的pixel的颜色是什么样子

278
00:09:11,280 --> 00:09:13,800
这个就是数据集里面会告诉你的

279
00:09:13,800 --> 00:09:15,000
数据集会有一个readme

280
00:09:15,000 --> 00:09:16,240
会告诉你这个信息

281
00:09:19,040 --> 00:09:19,240
好

282
00:09:19,240 --> 00:09:22,120
然后当然我们要做一些辅助函数

283
00:09:22,240 --> 00:09:23,800
怎么样把一个

284
00:09:24,160 --> 00:09:28,720
一个RGB的值换算成我们的一个标号

285
00:09:29,200 --> 00:09:29,879
同样的话

286
00:09:29,879 --> 00:09:30,600
给一个标号

287
00:09:30,600 --> 00:09:32,600
我也得换算回我的RGB值

288
00:09:34,000 --> 00:09:34,920
第一个干什么事情

289
00:09:35,080 --> 00:09:36,800
第一个就是说我们build一个map

290
00:09:36,960 --> 00:09:37,640
就这个事情

291
00:09:38,039 --> 00:09:39,120
弄起来不容易

292
00:09:39,319 --> 00:09:40,039
就是说

293
00:09:40,039 --> 00:09:41,960
因为你的RGB是一个tuple

294
00:09:41,960 --> 00:09:44,759
就是说你是查一个三个元素值

295
00:09:45,159 --> 00:09:46,840
就把一个三个元素值

296
00:09:47,159 --> 00:09:48,919
map成一个整数

297
00:09:49,159 --> 00:09:50,919
就是你的标号

298
00:09:50,919 --> 00:09:53,080
我可以从01值命名下去

299
00:09:53,080 --> 00:09:53,439
对吧

300
00:09:53,679 --> 00:09:55,080
就map成一个整号

301
00:09:55,080 --> 00:09:57,840
这个事情也不那么容易做

302
00:09:57,840 --> 00:10:01,519
是因为你如果用最简单的python实现的话

303
00:10:01,519 --> 00:10:03,080
你会发现性能很差

304
00:10:03,480 --> 00:10:05,759
因为你一个图片进来几千个

305
00:10:06,000 --> 00:10:07,000
不说几千个

306
00:10:07,159 --> 00:10:09,039
几万个像素是有的

307
00:10:09,480 --> 00:10:10,799
所以你图片都进来

308
00:10:10,799 --> 00:10:11,639
你都去算一遍的话

309
00:10:11,639 --> 00:10:13,840
其实是一件很慢的事情

310
00:10:14,679 --> 00:10:17,600
所以这里我们做了一个比较简单的是说

311
00:10:17,799 --> 00:10:18,840
RGB的话

312
00:10:19,000 --> 00:10:21,240
我们就是把你的RGB

313
00:10:21,240 --> 00:10:23,200
然后把它换算成一个整数

314
00:10:23,639 --> 00:10:25,360
就是你的2×256

315
00:10:25,639 --> 00:10:27,039
加上你的B

316
00:10:27,159 --> 00:10:28,480
然后再乘256

317
00:10:28,480 --> 00:10:30,080
再加上你的G

318
00:10:30,919 --> 00:10:33,960
那就是乘一个256×256×256

319
00:10:33,960 --> 00:10:35,360
大小的一个数字

320
00:10:35,759 --> 00:10:38,480
然后当然我们就开把像素给开出来

321
00:10:38,480 --> 00:10:40,399
就是我开一个大的数组

322
00:10:40,720 --> 00:10:42,440
这里我们就是一个tensor了

323
00:10:42,800 --> 00:10:43,960
然后告诉你说

324
00:10:44,200 --> 00:10:45,919
每个像素它对应的值

325
00:10:46,080 --> 00:10:49,399
我通过这个值把一个tuple换算成一个整形

326
00:10:49,680 --> 00:10:54,200
然后把tensor它的对应的index换成i

327
00:10:54,279 --> 00:10:55,639
就是说这样子的话

328
00:10:55,840 --> 00:10:59,920
我们就把第i个的RGB的值

329
00:11:00,039 --> 00:11:01,840
映射到i这个地方

330
00:11:02,480 --> 00:11:05,480
这个东西就是一个字典

331
00:11:05,840 --> 00:11:07,360
就是一个比较大的一个账量

332
00:11:07,600 --> 00:11:08,600
里面基本都是0

333
00:11:08,800 --> 00:11:10,240
就那么几个只是非0

334
00:11:11,600 --> 00:11:14,120
然后有了它之后

335
00:11:14,120 --> 00:11:15,360
我们就这样子的话

336
00:11:15,360 --> 00:11:16,399
我就不要用python

337
00:11:17,560 --> 00:11:19,320
尽量可以不用用python的for loop

338
00:11:19,320 --> 00:11:20,680
或者什么样去查找了

339
00:11:20,879 --> 00:11:22,240
我们就直接通过

340
00:11:22,480 --> 00:11:23,320
下次来的话

341
00:11:23,840 --> 00:11:25,040
来的话我说

342
00:11:25,160 --> 00:11:26,759
我告诉你一个color map

343
00:11:26,800 --> 00:11:29,480
就是我告诉你一个图片里面那些RGB值

344
00:11:29,560 --> 00:11:31,279
我要把它转成标号

345
00:11:31,279 --> 00:11:32,680
对应的数值的话

346
00:11:32,879 --> 00:11:35,240
那么就给你dictionary

347
00:11:35,720 --> 00:11:37,000
给你这个图片

348
00:11:37,279 --> 00:11:38,560
然后我们就是

349
00:11:40,000 --> 00:11:42,759
首先我们是换算成把channel换出来

350
00:11:43,080 --> 00:11:43,720
换出来之后

351
00:11:43,720 --> 00:11:45,000
我们把整个图片

352
00:11:45,600 --> 00:11:50,960
通过x256怎么换RGB换成一个下标

353
00:11:51,279 --> 00:11:52,680
就换成一个index

354
00:11:53,080 --> 00:11:53,879
index的话

355
00:11:53,879 --> 00:11:56,120
我们就直接丢给它

356
00:11:56,600 --> 00:11:57,159
这个

357
00:11:57,919 --> 00:11:59,480
拿到每一个像素

358
00:11:59,480 --> 00:12:02,240
它对应的标号的编号了

359
00:12:02,799 --> 00:12:03,120
OK

360
00:12:03,120 --> 00:12:05,399
这就是一个辅助函数

361
00:12:05,600 --> 00:12:06,320
就是说

362
00:12:06,320 --> 00:12:07,639
把你一个

363
00:12:08,799 --> 00:12:10,519
你的标号的图片拿进来

364
00:12:10,799 --> 00:12:13,600
我能换成我的等会训练的时候

365
00:12:14,039 --> 00:12:15,519
要用到的那些整形

366
00:12:15,519 --> 00:12:16,759
就是从01234

367
00:12:16,759 --> 00:12:18,720
而不是要告诉我一个RGB的值

368
00:12:21,560 --> 00:12:22,159
OK

369
00:12:22,919 --> 00:12:23,159
好

370
00:12:23,159 --> 00:12:24,560
我们接下来看一下

371
00:12:24,840 --> 00:12:26,240
接下来我们看一个例子

372
00:12:26,240 --> 00:12:27,000
就是说

373
00:12:27,000 --> 00:12:29,880
我们就把刚刚第一个的

374
00:12:30,400 --> 00:12:31,680
飞机的图片拿出来

375
00:12:32,640 --> 00:12:34,600
然后这就是飞机图片

376
00:12:35,120 --> 00:12:37,400
然后把dictionary弄出来

377
00:12:37,440 --> 00:12:41,040
然后通过函数去查找它的标号

378
00:12:41,200 --> 00:12:42,280
然后得到y

379
00:12:42,400 --> 00:12:43,880
让我们看一下y是什么样

380
00:12:44,360 --> 00:12:45,640
就是说y的话

381
00:12:45,640 --> 00:12:47,080
我们当然y比较大了

382
00:12:47,080 --> 00:12:48,240
就是一个比较大的数据集

383
00:12:48,760 --> 00:12:49,600
一个图片

384
00:12:49,600 --> 00:12:51,080
我们就把一个

385
00:12:51,120 --> 00:12:52,000
从

386
00:12:53,160 --> 00:12:54,840
100到15

387
00:12:54,840 --> 00:12:55,960
然后130到140

388
00:12:55,960 --> 00:12:57,639
这个小的一个区域画出来

389
00:12:57,639 --> 00:12:58,560
给大家看一下

390
00:12:59,759 --> 00:13:00,480
这时候

391
00:13:00,480 --> 00:13:02,840
当时你的标号读出来的

392
00:13:02,840 --> 00:13:03,960
y是一个图片

393
00:13:04,080 --> 00:13:05,240
是有三个channel的

394
00:13:05,240 --> 00:13:06,120
RGB的channel

395
00:13:06,440 --> 00:13:09,080
现在我就把它完全变成了

396
00:13:09,120 --> 00:13:10,280
每一个像素

397
00:13:10,280 --> 00:13:11,800
它对应的值

398
00:13:11,840 --> 00:13:13,280
0就是背景

399
00:13:13,759 --> 00:13:15,520
1就是飞机

400
00:13:15,800 --> 00:13:16,320
对吧

401
00:13:16,440 --> 00:13:17,600
所以看到是

402
00:13:18,000 --> 00:13:18,879
所以基本上这就是

403
00:13:18,879 --> 00:13:20,440
你可以看到是个机头

404
00:13:20,440 --> 00:13:21,040
对不对

405
00:13:21,080 --> 00:13:22,040
我也不知道是不是机头

406
00:13:22,160 --> 00:13:23,400
可能是飞机的翅膀

407
00:13:23,400 --> 00:13:24,040
或者什么样子

408
00:13:24,920 --> 00:13:26,759
你看到这对应的是1

409
00:13:28,879 --> 00:13:29,800
所以现在

410
00:13:30,280 --> 00:13:31,680
通过这个函数的话

411
00:13:31,920 --> 00:13:33,960
我们就可以把你读出来的

412
00:13:34,720 --> 00:13:35,879
标号的图片

413
00:13:35,920 --> 00:13:37,280
变成了每一个像素

414
00:13:37,280 --> 00:13:38,560
变成了01234

415
00:13:38,560 --> 00:13:40,680
这样子的一个连续的标号

416
00:13:40,840 --> 00:13:43,320
这样子能方便我们之后进行训练

417
00:13:43,320 --> 00:13:50,640
好

418
00:13:50,640 --> 00:13:51,920
另外一个是说

419
00:13:52,240 --> 00:13:53,840
我们之前通过竞赛

420
00:13:54,040 --> 00:13:56,240
我们课前讲到过

421
00:13:56,280 --> 00:13:59,040
图片增广是非常有用的技术

422
00:14:00,200 --> 00:14:00,720
对吧

423
00:14:01,000 --> 00:14:04,960
所以我们需要来看一下图片增广

424
00:14:04,960 --> 00:14:07,080
怎么应用在语义分割上面

425
00:14:08,120 --> 00:14:09,400
你翻转

426
00:14:09,920 --> 00:14:10,880
上下翻转

427
00:14:11,080 --> 00:14:12,240
变换颜色

428
00:14:13,200 --> 00:14:15,000
变换颜色是很容易的一件事情

429
00:14:15,560 --> 00:14:16,560
变换颜色的话

430
00:14:16,560 --> 00:14:18,960
你就说你对图片变换颜色了

431
00:14:19,320 --> 00:14:22,080
那么我们这个地方主要给大家讲的是

432
00:14:22,120 --> 00:14:24,600
怎么样做一个随机的crop

433
00:14:26,159 --> 00:14:26,639
OK

434
00:14:27,080 --> 00:14:31,840
我们在讲物体目标识别的时候

435
00:14:31,840 --> 00:14:34,240
并没有给大家讲怎么做crop

436
00:14:34,600 --> 00:14:35,960
就crop它的

437
00:14:36,000 --> 00:14:38,399
它对图片分类是很简单的事情

438
00:14:38,399 --> 00:14:40,680
你就是随便猜就是了

439
00:14:41,160 --> 00:14:42,560
但是对目标检测

440
00:14:42,680 --> 00:14:44,280
对于语义分割来讲

441
00:14:44,280 --> 00:14:45,920
你得多做一点事情

442
00:14:46,920 --> 00:14:49,760
因为你把图片裁了之后

443
00:14:50,440 --> 00:14:53,240
你的标号对物体的位置

444
00:14:53,360 --> 00:14:55,120
那些相次都要发生变化

445
00:14:55,800 --> 00:14:57,840
就是说你得去移它的bonding box

446
00:14:57,880 --> 00:14:59,800
你也得去移它的标号

447
00:15:01,080 --> 00:15:02,800
所以在这个地方我们干嘛呢

448
00:15:02,920 --> 00:15:04,080
这个地方是说

449
00:15:04,120 --> 00:15:07,480
假设我对一张图片裁剪了一块出来

450
00:15:08,080 --> 00:15:09,759
那么我也要去

451
00:15:09,920 --> 00:15:12,759
把我的标号做相应的裁剪

452
00:15:13,560 --> 00:15:14,200
就不然的话

453
00:15:14,200 --> 00:15:15,039
你就对不起来了

454
00:15:15,039 --> 00:15:15,320
对吧

455
00:15:15,320 --> 00:15:17,200
你的一个像素给对应起来

456
00:15:18,039 --> 00:15:18,399
OK

457
00:15:18,399 --> 00:15:19,879
这个函数局就干这个事情

458
00:15:20,759 --> 00:15:21,920
它的核心什么样子的

459
00:15:21,960 --> 00:15:23,039
核心就是说

460
00:15:23,320 --> 00:15:25,279
你在裁剪的时候

461
00:15:26,720 --> 00:15:29,879
就是说你的random crop这个事情

462
00:15:30,000 --> 00:15:30,680
random crop

463
00:15:30,720 --> 00:15:33,560
你可以把要裁的那一个

464
00:15:33,759 --> 00:15:35,720
bonding box给你弄出来

465
00:15:35,920 --> 00:15:38,160
就get a params这个函数

466
00:15:38,600 --> 00:15:41,360
允许你说这个图片是谁

467
00:15:41,399 --> 00:15:44,000
然后我要裁剪出一个随机

468
00:15:44,000 --> 00:15:45,200
裁剪出一个高和宽

469
00:15:45,200 --> 00:15:48,440
为某一个高和宽的一个区域的话

470
00:15:48,480 --> 00:15:49,519
那么这个函数

471
00:15:49,639 --> 00:15:52,240
它会返回出你bonding box

472
00:15:52,279 --> 00:15:54,120
就是一个一个框

473
00:15:55,040 --> 00:15:57,399
然后你拿到这个框之后

474
00:15:58,120 --> 00:15:59,519
然后你调用它的

475
00:16:01,399 --> 00:16:03,240
真正的crop那个函数

476
00:16:03,840 --> 00:16:04,920
把你feature

477
00:16:05,040 --> 00:16:06,560
把这个框丢回去

478
00:16:06,960 --> 00:16:09,360
心就是把框的4个坐标展开

479
00:16:09,600 --> 00:16:11,920
然后按照这个框去crop

480
00:16:13,080 --> 00:16:14,280
同样道理的话

481
00:16:14,280 --> 00:16:15,960
我需要对标号

482
00:16:17,520 --> 00:16:18,960
做同样的crop

483
00:16:20,080 --> 00:16:21,800
这样我能保证说

484
00:16:21,840 --> 00:16:23,040
我对一个图片

485
00:16:23,040 --> 00:16:24,400
裁出某一个框的话

486
00:16:24,400 --> 00:16:25,560
那么对标号的话

487
00:16:25,560 --> 00:16:27,000
同样裁出那个框

488
00:16:27,040 --> 00:16:28,360
像素和像素之间

489
00:16:28,360 --> 00:16:30,080
还是能够一一对应的

490
00:16:31,080 --> 00:16:32,240
所以然后就返回我的

491
00:16:32,240 --> 00:16:34,360
要的裁出来的feature和label

492
00:16:35,760 --> 00:16:36,520
然后我们可以看一下

493
00:16:36,520 --> 00:16:37,400
这个函数长什么样子

494
00:16:37,600 --> 00:16:38,360
就是说

495
00:16:41,960 --> 00:16:43,240
这个地方就是说

496
00:16:43,280 --> 00:16:45,040
我就对同样一张图片

497
00:16:45,120 --> 00:16:47,120
就是刚刚第一张的那张飞机图片

498
00:16:47,160 --> 00:16:48,920
然后做重复

499
00:16:48,920 --> 00:16:50,040
我们再重复做多少次

500
00:16:50,040 --> 00:16:51,040
重复做5次

501
00:16:51,560 --> 00:16:53,000
就每一次做一次

502
00:16:53,320 --> 00:16:55,080
随机的random crop

503
00:16:55,440 --> 00:16:57,160
然后做出来之后

504
00:16:57,160 --> 00:16:58,280
我们把它画出来

505
00:16:58,720 --> 00:16:59,960
我给大家放大一点

506
00:16:59,960 --> 00:17:00,920
给看一下效果

507
00:17:03,040 --> 00:17:04,240
就可以看到是说

508
00:17:04,240 --> 00:17:05,240
每一次我们裁

509
00:17:05,440 --> 00:17:06,279
比如说你这个地方

510
00:17:06,279 --> 00:17:07,720
你看我把飞机

511
00:17:08,039 --> 00:17:09,440
只裁了这一边出来

512
00:17:09,440 --> 00:17:11,000
就基本上把一个

513
00:17:11,200 --> 00:17:12,799
机身和一半的机翼

514
00:17:12,799 --> 00:17:13,680
给你留下来

515
00:17:13,720 --> 00:17:14,720
让我们可以看到

516
00:17:14,720 --> 00:17:17,079
我的标号是同样的话

517
00:17:17,120 --> 00:17:18,480
我是裁出了它

518
00:17:18,680 --> 00:17:19,640
这样子我的像素

519
00:17:19,640 --> 00:17:20,680
是能一一对应的

520
00:17:21,519 --> 00:17:23,440
所以在这个地方

521
00:17:23,440 --> 00:17:25,519
大家做裁剪的时候

522
00:17:25,519 --> 00:17:26,440
一定要很小心

523
00:17:26,440 --> 00:17:27,680
就是说你一定要保证

524
00:17:27,680 --> 00:17:29,000
你是能对起来的

525
00:17:29,039 --> 00:17:30,880
然后你在用

526
00:17:31,079 --> 00:17:32,599
data augmentation的时候

527
00:17:32,599 --> 00:17:34,559
你需要去看一下

528
00:17:34,959 --> 00:17:35,919
效果什么样子

529
00:17:35,959 --> 00:17:36,719
同样道理的话

530
00:17:36,719 --> 00:17:39,240
如果你做左右翻转

531
00:17:39,480 --> 00:17:40,399
上下翻转

532
00:17:41,000 --> 00:17:42,039
旋转的时候

533
00:17:42,039 --> 00:17:43,159
你都得去保证

534
00:17:43,159 --> 00:17:45,159
你同样的操作

535
00:17:45,599 --> 00:17:46,799
对你的图片

536
00:17:46,919 --> 00:17:48,439
还是对你的标号

537
00:17:48,439 --> 00:17:49,519
还是同样做了

538
00:17:49,759 --> 00:17:50,439
而且你要知道

539
00:17:50,439 --> 00:17:51,639
这里是随机操作

540
00:17:52,000 --> 00:17:52,719
所以你不能说

541
00:17:52,719 --> 00:17:54,679
我一次做一次随机是不行的

542
00:17:54,719 --> 00:17:56,319
一定要固定住

543
00:17:56,319 --> 00:17:58,439
你的随机的因子

544
00:17:58,759 --> 00:18:00,279
就是说你不能两张图

545
00:18:00,879 --> 00:18:01,599
图片和标号

546
00:18:01,599 --> 00:18:03,359
同时用同一个函数去调用

547
00:18:03,759 --> 00:18:04,959
调出来结果是不一样的

548
00:18:05,159 --> 00:18:06,879
这也是经常犯的一个错误

549
00:18:10,199 --> 00:18:10,759
OK

550
00:18:11,639 --> 00:18:12,839
然后这样子的话

551
00:18:12,839 --> 00:18:13,599
我们基本上

552
00:18:13,599 --> 00:18:14,879
可以定义我们的数据机了

553
00:18:15,319 --> 00:18:16,079
我们定义了

554
00:18:16,079 --> 00:18:17,240
怎么样把它读出来

555
00:18:17,439 --> 00:18:18,679
标号长什么样子

556
00:18:19,159 --> 00:18:19,839
接下来就是说

557
00:18:19,839 --> 00:18:20,959
我们怎么做

558
00:18:20,959 --> 00:18:24,240
我们的剪裁

559
00:18:24,679 --> 00:18:25,959
我们可以定义

560
00:18:25,959 --> 00:18:26,959
我们自己的

561
00:18:26,959 --> 00:18:29,079
VOC segmentation dataset

562
00:18:29,079 --> 00:18:31,599
可以看一下

563
00:18:31,599 --> 00:18:32,519
就是说这个东西

564
00:18:32,519 --> 00:18:35,039
还是相对来说不难

565
00:18:35,039 --> 00:18:37,039
跟我们之前长的是挺像的

566
00:18:37,399 --> 00:18:38,399
所以在init的时候

567
00:18:38,399 --> 00:18:39,359
你告诉我说

568
00:18:39,359 --> 00:18:41,359
你是训练机还是测试机

569
00:18:41,639 --> 00:18:43,599
然后你要随机crop

570
00:18:43,599 --> 00:18:44,679
你要crop多大

571
00:18:46,439 --> 00:18:47,439
而且我就是说

572
00:18:47,439 --> 00:18:48,720
为什么我要crop

573
00:18:48,919 --> 00:18:49,599
就是说

574
00:18:49,759 --> 00:18:52,559
因为你如果不crop的话

575
00:18:52,559 --> 00:18:54,960
你得去做resize

576
00:18:55,519 --> 00:18:59,799
因为你要把一些图片

577
00:18:59,799 --> 00:19:00,640
放成一个batch

578
00:19:00,840 --> 00:19:02,799
你要除非你说batch等于1

579
00:19:02,799 --> 00:19:03,720
你要训练的话

580
00:19:03,720 --> 00:19:05,720
假设你要做小批量的训练的话

581
00:19:05,720 --> 00:19:07,559
你需要把图片放成一样大

582
00:19:07,559 --> 00:19:09,640
我们之前做图片分类的时候

583
00:19:09,640 --> 00:19:12,000
当然我们就是resize了

584
00:19:12,000 --> 00:19:14,319
就你不剪裁是没关系

585
00:19:14,360 --> 00:19:15,720
我总是可以resize过去

586
00:19:17,559 --> 00:19:18,440
目标检测

587
00:19:18,440 --> 00:19:19,480
我们相对比较简单

588
00:19:19,480 --> 00:19:20,160
目标检测

589
00:19:20,160 --> 00:19:22,000
我们就是反正图片是自己构造的

590
00:19:22,000 --> 00:19:22,799
是没关系的

591
00:19:23,000 --> 00:19:24,440
所以VOC这个数据机

592
00:19:24,440 --> 00:19:26,960
它每张图片是长的不一样的

593
00:19:27,000 --> 00:19:28,440
大大小小是不一样的

594
00:19:28,600 --> 00:19:29,559
所以的话

595
00:19:29,600 --> 00:19:33,600
你不好像跟之前的做图片分类

596
00:19:33,600 --> 00:19:34,519
那样一样的

597
00:19:34,519 --> 00:19:37,440
把你重新resize成一个图片

598
00:19:38,519 --> 00:19:39,759
就resize有什么问题

599
00:19:40,120 --> 00:19:41,920
你拉伸的时候

600
00:19:41,920 --> 00:19:43,519
那你的label怎么拉伸

601
00:19:44,840 --> 00:19:47,039
你label得做很特殊的处理

602
00:19:47,080 --> 00:19:49,000
如果说我对一个图片做拉伸

603
00:19:49,000 --> 00:19:50,880
拉伸是通过差值来做的

604
00:19:51,000 --> 00:19:52,160
就是说我两个像素

605
00:19:52,160 --> 00:19:52,960
我把它拉开之后

606
00:19:52,960 --> 00:19:54,400
中间多了像素是差值

607
00:19:54,400 --> 00:19:55,120
差过去的

608
00:19:55,559 --> 00:19:56,840
但你标号怎么差值

609
00:19:57,079 --> 00:19:58,240
标号你不能差值

610
00:19:58,440 --> 00:20:00,079
标号是说我两个像素拉开

611
00:20:00,079 --> 00:20:01,799
中间像素我不能差值

612
00:20:01,799 --> 00:20:03,319
成一个随便的RGB值

613
00:20:03,360 --> 00:20:04,920
因为差出来的值

614
00:20:04,920 --> 00:20:07,759
很有可能是对应不到任何的标号

615
00:20:07,759 --> 00:20:08,160
里面

616
00:20:09,480 --> 00:20:09,960
对吧

617
00:20:10,000 --> 00:20:12,840
我一个红色的飞机到一个背景

618
00:20:12,840 --> 00:20:13,400
是一个黑色

619
00:20:13,400 --> 00:20:14,920
然后我一拉的话

620
00:20:14,920 --> 00:20:16,000
中间变一个淡红色

621
00:20:16,000 --> 00:20:17,319
淡红色对应的是什么标号

622
00:20:17,559 --> 00:20:20,400
到底是背景还是飞机

623
00:20:20,800 --> 00:20:24,759
所以图片分割其实就不那么好

624
00:20:24,759 --> 00:20:27,000
用resize这个操作

625
00:20:27,000 --> 00:20:29,200
所以也就是说我们为什么说

626
00:20:29,200 --> 00:20:31,000
一定要告诉你crop size

627
00:20:31,000 --> 00:20:32,480
crop size就是说

628
00:20:32,480 --> 00:20:34,320
你给你模型训练的时候

629
00:20:34,320 --> 00:20:37,640
小批量的高宽是什么样子

630
00:20:37,840 --> 00:20:39,759
所以这个是你必须要指定的

631
00:20:40,120 --> 00:20:42,160
最后说我的文件夹放在什么地方

632
00:20:43,759 --> 00:20:45,320
首先我们跟之前一样

633
00:20:45,519 --> 00:20:47,440
就是做一次RGB的

634
00:20:47,440 --> 00:20:51,039
对RGB三个channel的均值和方差

635
00:20:51,039 --> 00:20:52,160
我们都normalize一下

636
00:20:52,519 --> 00:20:54,960
这几个只是从imagenet上面拿过来的

637
00:20:55,000 --> 00:20:56,519
这是因为我们想要

638
00:20:56,519 --> 00:20:59,160
之后想要用imagenet的present model

639
00:20:59,600 --> 00:21:01,120
crop size存下来

640
00:21:01,279 --> 00:21:04,080
然后我们就把图片全部读进来

641
00:21:05,240 --> 00:21:06,400
图片反正不大

642
00:21:08,160 --> 00:21:11,200
那么接下来我们做一些前处理

643
00:21:12,160 --> 00:21:14,640
前处理第一个是说我的feature

644
00:21:15,279 --> 00:21:17,360
feature首先我们会filter一下

645
00:21:17,960 --> 00:21:19,200
就我们filter是什么意思

646
00:21:20,080 --> 00:21:21,320
你可以看到filter这个函数

647
00:21:23,320 --> 00:21:23,759
我们

648
00:21:26,080 --> 00:21:28,320
我们要换一个行

649
00:21:29,320 --> 00:21:30,640
就这样子好方便看

650
00:21:30,640 --> 00:21:32,840
我就干脆把相机

651
00:21:35,320 --> 00:21:36,480
我们还是换个行

652
00:21:41,840 --> 00:21:43,640
filter干的事情是说

653
00:21:43,640 --> 00:21:45,920
假设你图片特别小

654
00:21:45,920 --> 00:21:49,680
比我的crop size的高宽还要小的话

655
00:21:49,960 --> 00:21:50,920
我就不要了

656
00:21:52,400 --> 00:21:54,960
就是说假设我说我要训练的话

657
00:21:54,960 --> 00:21:57,960
是320x240高宽的话

658
00:21:58,800 --> 00:22:02,240
我这是我要给神级网络的大小

659
00:22:02,240 --> 00:22:05,440
但是你如果你这个图片比我的

660
00:22:06,759 --> 00:22:08,160
要裁剪的还小

661
00:22:08,279 --> 00:22:09,000
我怎么办

662
00:22:09,360 --> 00:22:10,320
我要padding对吧

663
00:22:10,320 --> 00:22:12,000
Padding我们没实现这个事情

664
00:22:12,200 --> 00:22:13,800
所以就干脆就不要了

665
00:22:13,800 --> 00:22:15,880
这小图片就不管了

666
00:22:16,120 --> 00:22:17,160
就是filter干的事情

667
00:22:18,320 --> 00:22:20,000
所以filter之后

668
00:22:20,039 --> 00:22:23,480
就是说把所有的小图片去掉之后

669
00:22:23,519 --> 00:22:25,120
然后再normalize一下

670
00:22:25,960 --> 00:22:27,200
然后就要normalize

671
00:22:27,200 --> 00:22:28,680
做RGB normalization

672
00:22:29,120 --> 00:22:32,240
就RGB normalization是因为你总是

673
00:22:32,840 --> 00:22:34,160
是确定性的事情

674
00:22:34,200 --> 00:22:36,560
所以我们可以在init里面就做掉了

675
00:22:36,600 --> 00:22:39,200
就不需要做成实时的

676
00:22:39,920 --> 00:22:40,519
标号的话

677
00:22:40,519 --> 00:22:41,039
同样的话

678
00:22:41,039 --> 00:22:42,160
你要做一个filter

679
00:22:42,160 --> 00:22:44,120
就是说如果你的图片没了

680
00:22:44,120 --> 00:22:45,320
你标号也不应该有

681
00:22:46,120 --> 00:22:49,360
最后是说我们要把RGB的map

682
00:22:49,360 --> 00:22:50,920
就是说color map to label

683
00:22:50,920 --> 00:22:52,800
那个东西给加载了

684
00:22:52,840 --> 00:22:55,400
因为构造这个事情是有一定开销的

685
00:22:55,400 --> 00:22:57,080
所以我们在init里面构造了

686
00:22:58,440 --> 00:23:00,039
然后normalize image

687
00:23:00,039 --> 00:23:06,920
就是刚刚我们那个操作

688
00:23:07,920 --> 00:23:09,519
把你RGB给弄一弄

689
00:23:10,440 --> 00:23:11,480
就是你的transform

690
00:23:11,640 --> 00:23:13,440
transform我们定义的东西

691
00:23:14,480 --> 00:23:15,600
然后get item

692
00:23:15,680 --> 00:23:16,800
就get item是说

693
00:23:16,800 --> 00:23:20,080
我每一次返回第二个样本

694
00:23:20,080 --> 00:23:20,840
要干什么事情

695
00:23:21,440 --> 00:23:22,440
就其实很简单

696
00:23:22,440 --> 00:23:25,120
就是说我们每次返回的样本

697
00:23:25,160 --> 00:23:26,840
就是做一次data augmentation

698
00:23:26,840 --> 00:23:28,720
就是做一次random crop

699
00:23:29,800 --> 00:23:30,240
对吧

700
00:23:30,240 --> 00:23:32,920
就是把一个图片和它的标号拿过来

701
00:23:32,960 --> 00:23:35,640
然后弄成我们要的

702
00:23:35,640 --> 00:23:37,240
那个fixed crop size

703
00:23:37,600 --> 00:23:40,680
这样子保证我们可以做batching在之后

704
00:23:41,600 --> 00:23:42,160
OK

705
00:23:42,400 --> 00:23:43,600
就干这个事情

706
00:23:44,360 --> 00:23:45,200
另外一个事情是说

707
00:23:45,200 --> 00:23:48,720
我们标号需要换成我们的编号

708
00:23:48,920 --> 00:23:51,960
就是说我们把标号里面的RGB值

709
00:23:51,960 --> 00:23:55,360
换成从1234开始的那些

710
00:23:55,400 --> 00:23:56,360
那些坐标

711
00:23:56,920 --> 00:23:57,480
OK

712
00:23:57,520 --> 00:24:00,400
所以这个就是我们整个data set

713
00:24:00,400 --> 00:24:01,720
长成什么样子了

714
00:24:02,760 --> 00:24:03,040
好

715
00:24:03,040 --> 00:24:06,760
最后我们来看一下长什么样子

716
00:24:07,560 --> 00:24:09,400
我们说我们crop size

717
00:24:09,400 --> 00:24:11,000
假设我的最后的训练图片

718
00:24:11,000 --> 00:24:14,039
是一个3220×480

719
00:24:14,319 --> 00:24:15,480
之所以取这一个

720
00:24:15,480 --> 00:24:16,160
就是要你

721
00:24:16,160 --> 00:24:18,440
我们其实大概看一眼里面长什么样子

722
00:24:18,960 --> 00:24:20,440
就是说里面大概是

723
00:24:21,920 --> 00:24:24,000
大部分图片比这个大一些

724
00:24:24,000 --> 00:24:25,359
但是大不了太多

725
00:24:25,359 --> 00:24:27,319
所以我们就取了一个整在这个地方

726
00:24:28,599 --> 00:24:30,640
我们把这个读进来

727
00:24:31,039 --> 00:24:31,720
读进来的话

728
00:24:31,720 --> 00:24:33,759
我们会得到了训练级

729
00:24:33,759 --> 00:24:37,119
我们是1114个图片

730
00:24:37,160 --> 00:24:39,920
然后我的测试级是1078个图片

731
00:24:40,240 --> 00:24:40,640
OK

732
00:24:41,400 --> 00:24:43,600
所以说我们的数据级不是那么的大

733
00:24:44,200 --> 00:24:45,040
通常来说

734
00:24:45,040 --> 00:24:46,120
语义分割的数据级

735
00:24:46,320 --> 00:24:48,920
一般来说比你的图片分类

736
00:24:49,080 --> 00:24:50,920
目标检测要少很多

737
00:24:51,280 --> 00:24:52,200
为什么呢

738
00:24:52,920 --> 00:24:53,960
标起来很贵

739
00:24:55,240 --> 00:24:59,040
就是说一般说你说标一张图片分类

740
00:24:59,040 --> 00:25:00,520
一分钱两分钱

741
00:25:01,040 --> 00:25:01,840
就找人标

742
00:25:03,240 --> 00:25:04,320
标一个目标检测

743
00:25:04,320 --> 00:25:05,240
就是画几个框

744
00:25:05,320 --> 00:25:06,200
数据画几个框

745
00:25:06,200 --> 00:25:08,840
可能就是一毛钱

746
00:25:09,240 --> 00:25:10,759
但是标一个图片

747
00:25:12,039 --> 00:25:12,839
分割的话

748
00:25:12,839 --> 00:25:14,000
我得用一个手

749
00:25:14,559 --> 00:25:15,439
整个图片

750
00:25:15,439 --> 00:25:18,119
我得用拿一个手写板

751
00:25:18,279 --> 00:25:19,319
一般是拿个手写板

752
00:25:19,319 --> 00:25:20,799
真的去把它描一遍

753
00:25:21,480 --> 00:25:23,119
是一件很耗时的事情

754
00:25:23,279 --> 00:25:25,399
你想一想一个人做可能要

755
00:25:25,439 --> 00:25:26,480
你标个图片分类

756
00:25:26,480 --> 00:25:27,720
我大概就几秒钟

757
00:25:28,240 --> 00:25:30,319
目标分类目标识别的话

758
00:25:30,319 --> 00:25:32,240
我觉得你画几个框

759
00:25:32,240 --> 00:25:33,879
可能就十几秒20秒

760
00:25:34,559 --> 00:25:36,399
但你标起来就很难了

761
00:25:36,800 --> 00:25:37,560
几分钟

762
00:25:37,840 --> 00:25:38,720
至少几分钟

763
00:25:39,080 --> 00:25:40,360
所以的话标一张图片

764
00:25:40,360 --> 00:25:41,640
我觉得应该是几块钱

765
00:25:41,640 --> 00:25:42,720
我没有标过这个东西

766
00:25:42,840 --> 00:25:44,519
我觉得起码要几块钱的样子

767
00:25:44,840 --> 00:25:45,720
所以一般来说

768
00:25:46,440 --> 00:25:48,800
大家标这个东西比较贵

769
00:25:48,800 --> 00:25:50,640
所以相对来说数据基因不大

770
00:25:50,920 --> 00:25:54,400
现在其实也主要是靠无人车

771
00:25:54,400 --> 00:25:56,680
那一块数据基因比较多一点

772
00:25:56,680 --> 00:25:57,280
无人车

773
00:25:57,480 --> 00:25:59,240
都大家不缺钱

774
00:25:59,240 --> 00:26:01,280
所以标的数据相对来说多一点

775
00:26:01,600 --> 00:26:02,280
不然的话

776
00:26:02,280 --> 00:26:03,440
你说我是一个

777
00:26:03,880 --> 00:26:05,840
要做一个

778
00:26:07,120 --> 00:26:08,880
人的一个虚化的话

779
00:26:09,080 --> 00:26:10,720
手机上可能也不那么缺钱

780
00:26:10,720 --> 00:26:12,240
但是跟别的的话

781
00:26:12,240 --> 00:26:14,000
大家就觉得不会标那么多数据了

782
00:26:14,000 --> 00:26:15,120
所以相对来说

783
00:26:15,360 --> 00:26:17,200
它的数据基因都不会那么的大

784
00:26:18,080 --> 00:26:18,840
但反过来讲

785
00:26:18,840 --> 00:26:20,480
它的分辨率会相对高一点

786
00:26:20,600 --> 00:26:22,480
假设你是一个很低质量的图

787
00:26:22,480 --> 00:26:24,360
那我标它有意义吗

788
00:26:24,400 --> 00:26:25,000
就是

789
00:26:26,000 --> 00:26:27,360
就没太多意义了

790
00:26:27,360 --> 00:26:28,279
所以相对来说

791
00:26:28,640 --> 00:26:30,960
很做语音分割的话

792
00:26:30,960 --> 00:26:32,640
大家说我要做4K的

793
00:26:33,040 --> 00:26:34,960
4K video出来的那种语音分割

794
00:26:34,960 --> 00:26:36,120
也大家不要奇怪

795
00:26:36,480 --> 00:26:39,000
大家可以把整个图片做特别大

796
00:26:40,240 --> 00:26:40,560
好

797
00:26:40,560 --> 00:26:42,120
然后我们就最后就是说

798
00:26:42,160 --> 00:26:43,360
可以看一下我们

799
00:26:43,759 --> 00:26:45,000
数据集拿出来之后

800
00:26:45,000 --> 00:26:46,440
我们就可以把我们的

801
00:26:47,000 --> 00:26:48,440
放到data loader里面

802
00:26:48,680 --> 00:26:51,120
然后我们把第一个batch拿出来

803
00:26:51,480 --> 00:26:53,480
这batch size如果是64的话

804
00:26:53,520 --> 00:26:55,720
那么看到是我的x的shape

805
00:26:55,759 --> 00:26:57,440
就是一个64×RGB

806
00:26:57,440 --> 00:27:00,680
30×480

807
00:27:00,920 --> 00:27:01,560
我的y

808
00:27:01,960 --> 00:27:03,279
主要不一样的就是y

809
00:27:03,879 --> 00:27:05,319
y就是一个64

810
00:27:05,759 --> 00:27:07,599
高宽跟你的前面是一样的

811
00:27:07,599 --> 00:27:08,839
32×480

812
00:27:08,839 --> 00:27:10,839
对的是每个像素它的值

813
00:27:11,240 --> 00:27:12,279
这里就没有RGB

814
00:27:12,279 --> 00:27:13,319
没有3这个事情了

815
00:27:13,319 --> 00:27:15,159
因为我们已经换算成了

816
00:27:15,159 --> 00:27:16,159
标号所对应的

817
00:27:17,359 --> 00:27:18,359
01234

818
00:27:18,839 --> 00:27:19,399
OK

819
00:27:20,119 --> 00:27:22,599
这就是我们怎么样读取一个

820
00:27:22,599 --> 00:27:23,879
语音分割的数据集

821
00:27:24,440 --> 00:27:26,200
最后我们把所有东西放在这个地方

822
00:27:26,919 --> 00:27:28,079
放在一个

823
00:27:28,319 --> 00:27:30,319
函数里面叫loader data voc

824
00:27:30,359 --> 00:27:31,759
然后告诉你一个批量大小

825
00:27:31,759 --> 00:27:33,879
告诉你要裁减的图片大小

826
00:27:34,200 --> 00:27:36,319
把刚刚所有的所有东西就放在里面

827
00:27:36,519 --> 00:27:38,720
然后就直接会返回train iterator

828
00:27:38,720 --> 00:27:39,879
和test iterator

829
00:27:40,200 --> 00:27:41,599
这样子我们之后可以用

830
00:27:43,359 --> 00:27:43,759
OK

831
00:27:43,759 --> 00:27:46,079
这就是我们

832
00:27:46,559 --> 00:27:48,039
怎么样去

833
00:27:48,079 --> 00:27:50,159
读一个语音分割的数据集

834
00:27:50,159 --> 00:27:51,639
然后把它加载成

835
00:27:51,639 --> 00:27:54,480
我们之后神经网络能用的小批量

836
00:27:54,519 --> 00:27:55,759
就是这样子做的

