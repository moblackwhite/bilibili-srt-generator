1
00:00:00,000 --> 00:00:04,960
好 我们来真的用代码实现一下我刚刚讲的东西

2
00:00:04,960 --> 00:00:08,279
来把东西放大一点点

3
00:00:08,279 --> 00:00:13,519
首先我们来实现我们的互相关运算这个运算

4
00:00:13,519 --> 00:00:16,039
我们实现一个

5
00:00:16,039 --> 00:00:18,960
Core2D

6
00:00:18,960 --> 00:00:20,120
就不是Conv2D

7
00:00:20,120 --> 00:00:21,480
Correlation2D

8
00:00:21,480 --> 00:00:23,480
实现一个互相关运算

9
00:00:23,480 --> 00:00:25,879
我们的输入是我们的X

10
00:00:25,879 --> 00:00:27,000
就是我们的输入

11
00:00:27,320 --> 00:00:30,000
K是我们的核矩阵

12
00:00:31,519 --> 00:00:36,120
然后我的K的Shape就会拿出一个H和一个W

13
00:00:36,120 --> 00:00:38,399
就是行数和我们的列数

14
00:00:40,560 --> 00:00:41,439
然后我们的Y

15
00:00:41,439 --> 00:00:46,879
我们知道我们的Y就是我们的输入的高

16
00:00:46,879 --> 00:00:50,079
减去我的核的高加上1

17
00:00:50,079 --> 00:00:53,920
这就是我的输出的一个高度

18
00:00:53,920 --> 00:00:55,079
输出的宽度呢

19
00:00:55,079 --> 00:00:57,960
也就是我的输入的宽度减去我的核的宽度

20
00:00:57,960 --> 00:00:58,559
再加上1

21
00:01:00,159 --> 00:01:00,759
对吧

22
00:01:00,759 --> 00:01:01,759
所以这个就是

23
00:01:03,239 --> 00:01:04,439
我们的输出

24
00:01:06,879 --> 00:01:08,719
然后接下来是我们有两个

25
00:01:08,719 --> 00:01:11,000
记得我们有两个

26
00:01:11,000 --> 00:01:14,000
我们是对于

27
00:01:14,000 --> 00:01:14,719
编译一下

28
00:01:14,719 --> 00:01:20,640
就是我们要去对于所谓的Yi和Yj组一座计算

29
00:01:20,640 --> 00:01:22,280
就是我们通过两个Followup

30
00:01:22,280 --> 00:01:24,079
最傻的两个Followup

31
00:01:24,079 --> 00:01:27,200
来编译我们所有的输出的一些元素

32
00:01:28,159 --> 00:01:31,799
我们知道我们的Dij的输出

33
00:01:31,799 --> 00:01:32,799
它就是

34
00:01:34,120 --> 00:01:38,400
从X开始到它的H列

35
00:01:38,400 --> 00:01:40,799
就是它的往后看H列

36
00:01:42,079 --> 00:01:43,000
往后看

37
00:01:45,240 --> 00:01:46,879
H行

38
00:01:46,879 --> 00:01:51,480
然后J就是从J列开始往后看W列

39
00:01:52,480 --> 00:01:55,480
把这一个整个一个小区域拿出来

40
00:01:55,480 --> 00:01:57,879
就是一个小的那个小方块啊

41
00:01:57,879 --> 00:01:59,079
记得啊

42
00:01:59,079 --> 00:02:02,120
然后跟我的核矩阵

43
00:02:02,120 --> 00:02:03,120
它的大小是一样的

44
00:02:03,120 --> 00:02:06,920
也是一个WxHxW的一个矩阵

45
00:02:06,920 --> 00:02:08,199
做点击

46
00:02:08,199 --> 00:02:09,000
然后求核

47
00:02:10,920 --> 00:02:14,520
这就是我们的二维互相关运算的计算

48
00:02:20,840 --> 00:02:21,719
我们来验证一下

49
00:02:22,359 --> 00:02:24,080
就是之前我们有讲过

50
00:02:24,080 --> 00:02:25,840
我们的样例里面有讲过

51
00:02:25,840 --> 00:02:28,479
是我们构造一个0123

52
00:02:28,479 --> 00:02:33,039
012345678的一个33的矩阵

53
00:02:33,039 --> 00:02:35,479
然后我们的核矩阵就是01

54
00:02:35,479 --> 00:02:37,199
23的一个2乘2的矩阵

55
00:02:37,199 --> 00:02:39,039
我们做互相关运算的话

56
00:02:39,039 --> 00:02:41,000
又会得到一个2乘2的输出

57
00:02:41,000 --> 00:02:42,800
然后它的元素就是这几个元素

58
00:02:42,800 --> 00:02:47,479
是跟我们之前的PPT里面是能够一一对应的

59
00:02:47,479 --> 00:02:50,079
所以大家可以验证一下

60
00:02:52,719 --> 00:02:55,639
那么卷积层呢

61
00:02:55,639 --> 00:02:57,439
卷积层其实也就是说

62
00:02:57,439 --> 00:03:00,280
我们之前有讲过怎么样用

63
00:03:00,280 --> 00:03:03,360
继承NN module来实现一个类

64
00:03:03,360 --> 00:03:04,520
那么这个地方的话

65
00:03:04,520 --> 00:03:06,840
我们的weight w

66
00:03:06,840 --> 00:03:07,759
那就是

67
00:03:08,759 --> 00:03:11,639
一个我们取一个随机值

68
00:03:11,639 --> 00:03:13,199
就是一个可学的一个参数

69
00:03:13,199 --> 00:03:15,400
我们就放在NN的parameter里面

70
00:03:15,400 --> 00:03:17,439
然后它的kernel size就是要指定了

71
00:03:17,439 --> 00:03:19,719
就是说这是我们的超参数

72
00:03:19,719 --> 00:03:21,400
可以是33

73
00:03:21,400 --> 00:03:24,360
我们就指定一个随机变量

74
00:03:24,360 --> 00:03:25,879
然后作为初始值

75
00:03:25,879 --> 00:03:28,439
然后它是一个可学的一个33的矩阵

76
00:03:28,439 --> 00:03:30,360
然后我的偏移跟之前一样

77
00:03:30,360 --> 00:03:33,439
可以做一个初始化为0

78
00:03:33,439 --> 00:03:35,159
就是一个标量了

79
00:03:35,159 --> 00:03:36,920
所以weight和bios

80
00:03:36,920 --> 00:03:38,599
这是我们可学系的

81
00:03:38,599 --> 00:03:41,360
然后我们潜向运算就是给一个x的话

82
00:03:41,360 --> 00:03:45,280
那我们就用x和我们的weight做互相关运算

83
00:03:45,280 --> 00:03:46,800
再加上我们的偏移

84
00:03:46,800 --> 00:03:49,280
这就是我们的潜向运算了

85
00:03:49,319 --> 00:03:51,319
好这就是解极层

86
00:03:52,319 --> 00:03:53,560
还挺简单的吧

87
00:03:58,879 --> 00:03:59,960
好我们来看一个

88
00:03:59,960 --> 00:04:01,240
用这个东西做一个简单应用

89
00:04:02,800 --> 00:04:04,759
我们用来检测说

90
00:04:06,159 --> 00:04:10,840
一个图片中不同颜色的一个边缘

91
00:04:10,840 --> 00:04:12,680
就是说一个边缘

92
00:04:12,680 --> 00:04:16,439
我们首先来做一个简单的一个矩阵

93
00:04:16,439 --> 00:04:18,279
我们说一个给一个输入

94
00:04:18,280 --> 00:04:19,400
是一个6×8的

95
00:04:19,400 --> 00:04:21,240
然后我们是为1

96
00:04:21,240 --> 00:04:23,520
我们把中间一块搞成0

97
00:04:23,520 --> 00:04:25,720
所以看到我们的输入就是一个

98
00:04:25,720 --> 00:04:28,480
1有两列0是4列

99
00:04:28,480 --> 00:04:29,840
然后又是1有两列

100
00:04:31,080 --> 00:04:32,160
这就是我们输入

101
00:04:32,160 --> 00:04:34,520
我们的我们就是我们的

102
00:04:34,520 --> 00:04:37,080
job是说去把边缘

103
00:04:37,080 --> 00:04:39,840
就是这一个1变到0的时候

104
00:04:39,840 --> 00:04:40,840
就有一个竖线

105
00:04:40,920 --> 00:04:41,640
你把它画出来

106
00:04:41,640 --> 00:04:44,560
就是有一根线在有一个黑变白

107
00:04:44,560 --> 00:04:46,480
再变黑的一个过程

108
00:04:47,000 --> 00:04:48,040
就这里有个边缘

109
00:04:48,040 --> 00:04:49,160
一个竖线的边缘

110
00:04:49,160 --> 00:04:51,120
这个地方也有一个竖线的边缘

111
00:04:51,120 --> 00:04:52,160
我们的

112
00:04:52,160 --> 00:04:53,800
假设我们要做一个事情

113
00:04:53,800 --> 00:04:55,360
就是把这个边缘检测出来的话

114
00:04:55,360 --> 00:04:56,040
怎么做呢

115
00:04:56,800 --> 00:04:58,280
那我们做一个

116
00:04:58,720 --> 00:05:00,840
1×2的一个和

117
00:05:01,160 --> 00:05:02,680
然后第一个元素是

118
00:05:03,240 --> 00:05:03,960
1.0

119
00:05:03,960 --> 00:05:05,680
第二个元素是负1.0

120
00:05:06,040 --> 00:05:07,400
所以假设你的

121
00:05:07,640 --> 00:05:09,120
你两个元素没有变的话

122
00:05:09,120 --> 00:05:11,080
那么它的输出就是一个

123
00:05:11,080 --> 00:05:12,600
就是一个0

124
00:05:12,720 --> 00:05:13,920
假设你从1变成0

125
00:05:13,920 --> 00:05:14,840
或0变成1的话

126
00:05:14,840 --> 00:05:16,040
你的输出要么是1

127
00:05:16,040 --> 00:05:16,640
要么是负1

128
00:05:16,640 --> 00:05:17,160
对吧

129
00:05:17,840 --> 00:05:19,080
可以看一下是说

130
00:05:19,320 --> 00:05:20,800
假设我有这个输入

131
00:05:20,800 --> 00:05:23,280
我构造出来K输出的话

132
00:05:23,280 --> 00:05:25,520
那么当然我是可以做我的

133
00:05:25,880 --> 00:05:27,360
白到黑的边缘的

134
00:05:27,600 --> 00:05:28,440
检测了

135
00:05:28,440 --> 00:05:29,760
就把X放进去

136
00:05:29,760 --> 00:05:30,760
K放进去

137
00:05:30,760 --> 00:05:32,080
那我们的输出就是

138
00:05:32,320 --> 00:05:33,400
这个地方边缘

139
00:05:33,800 --> 00:05:34,960
这个地方有一列

140
00:05:35,880 --> 00:05:36,680
拿个笔

141
00:05:37,200 --> 00:05:38,480
这个地方有一列

142
00:05:38,800 --> 00:05:40,480
就是边缘被检测出来了

143
00:05:40,680 --> 00:05:41,520
这个是

144
00:05:41,519 --> 00:05:44,959
黑变白就是变成负1

145
00:05:45,759 --> 00:05:46,279
OK

146
00:05:47,799 --> 00:05:49,599
这就是我们这个和

147
00:05:49,599 --> 00:05:50,799
怎么把它检测出来

148
00:05:54,560 --> 00:05:55,560
当然是说

149
00:05:55,599 --> 00:05:59,000
它只能检测垂直的边缘

150
00:05:59,680 --> 00:06:01,359
不垂直的也不能检测了

151
00:06:01,479 --> 00:06:03,719
就是说比如说我们把X做个转制

152
00:06:03,719 --> 00:06:05,399
那么它边缘变成横向了

153
00:06:05,519 --> 00:06:07,279
因为我们和就是一个1乘2的

154
00:06:07,279 --> 00:06:09,240
一个它只能检测垂直的

155
00:06:09,279 --> 00:06:10,680
所以你把它转制之后

156
00:06:10,680 --> 00:06:11,759
它就不能检测东西了

157
00:06:11,759 --> 00:06:12,879
它全部为0

158
00:06:12,879 --> 00:06:14,959
所以它是不能检测横向边

159
00:06:15,959 --> 00:06:16,439
OK

160
00:06:19,360 --> 00:06:21,400
那么我们接下来是说

161
00:06:21,759 --> 00:06:26,360
我就去给定我们的X输入

162
00:06:26,360 --> 00:06:28,120
给定我们的Y输出

163
00:06:28,720 --> 00:06:30,399
我们去学那个K

164
00:06:31,040 --> 00:06:33,079
刚刚我们是我们知道K生出了Y

165
00:06:33,480 --> 00:06:36,000
现在是说我不知道我的和是什么样子

166
00:06:36,240 --> 00:06:38,240
我就知道我们的输入是一个

167
00:06:38,240 --> 00:06:39,600
有两条列

168
00:06:39,600 --> 00:06:42,840
我的输出要白边黑是1

169
00:06:42,840 --> 00:06:43,960
黑边白是-1

170
00:06:43,960 --> 00:06:45,760
这些输出

171
00:06:47,320 --> 00:06:48,400
我们把它学出来

172
00:06:49,200 --> 00:06:49,640
好

173
00:06:49,640 --> 00:06:51,080
我们来看一下怎么学

174
00:06:51,200 --> 00:06:54,480
我们这里直接调用的是PyTorch NN的

175
00:06:54,480 --> 00:06:56,000
那个Comp2D的定义

176
00:06:56,480 --> 00:06:58,640
就跟之前我们的东西差不多

177
00:06:58,640 --> 00:07:00,800
但是唯一的是说它加入了两个1

178
00:07:01,000 --> 00:07:02,000
1我们先不说

179
00:07:02,320 --> 00:07:04,080
就输入的通道

180
00:07:04,280 --> 00:07:06,360
就通道我们现在都是一个

181
00:07:06,400 --> 00:07:08,400
我们就是单一个矩阵

182
00:07:08,520 --> 00:07:09,400
通道就是一个1

183
00:07:09,520 --> 00:07:10,720
就是之前我们有讲过

184
00:07:10,720 --> 00:07:12,560
我们的黑白图片通道为1

185
00:07:12,560 --> 00:07:14,200
彩色图片通道为3

186
00:07:14,720 --> 00:07:16,960
所以我们先说输出通道为1

187
00:07:16,960 --> 00:07:18,560
输入为1

188
00:07:18,560 --> 00:07:19,320
输出也是1

189
00:07:19,320 --> 00:07:20,080
现在先不管

190
00:07:20,080 --> 00:07:21,040
我们之后会介绍

191
00:07:22,440 --> 00:07:24,720
那我们的和就是我们要学一个

192
00:07:24,720 --> 00:07:26,640
我们知道我们是一个1乘2的一个和

193
00:07:27,400 --> 00:07:28,360
我们要去学它

194
00:07:28,560 --> 00:07:30,400
Bias我们说我们不需要Bias

195
00:07:30,400 --> 00:07:31,480
这个地方先不需要

196
00:07:31,600 --> 00:07:32,400
就等于false

197
00:07:33,480 --> 00:07:36,480
那么我们要把X做一个reshape

198
00:07:36,480 --> 00:07:38,240
是因为我们要加两个维度

199
00:07:38,400 --> 00:07:40,280
第一个是一个通道为

200
00:07:40,280 --> 00:07:41,800
第二个是我的pn大小为

201
00:07:41,800 --> 00:07:45,519
所以对所有的框架来说

202
00:07:45,519 --> 00:07:49,079
我的conf2d的输入都是一个4d的东西

203
00:07:50,040 --> 00:07:50,840
通道数

204
00:07:51,280 --> 00:07:52,120
pn大小数

205
00:07:52,120 --> 00:07:53,160
我们这里都是唯一

206
00:07:53,160 --> 00:07:54,720
所以我们就直接reshaper

207
00:07:54,960 --> 00:07:57,040
它其实是个68和67的东西

208
00:07:58,720 --> 00:08:00,160
那么我们怎么做呢

209
00:08:00,560 --> 00:08:03,680
就我们就手写了一个训练逻辑

210
00:08:03,879 --> 00:08:05,400
就是我们迭代10轮

211
00:08:06,400 --> 00:08:10,280
每一次我就是把我的X放到我的

212
00:08:10,280 --> 00:08:12,480
conf2d的一个layer里面

213
00:08:12,680 --> 00:08:13,880
得到一个y hat

214
00:08:14,560 --> 00:08:15,920
我们用一个军方误差

215
00:08:15,920 --> 00:08:18,360
就直接y hat减去w

216
00:08:18,360 --> 00:08:19,400
然后均值

217
00:08:19,640 --> 00:08:21,440
作为我的loss

218
00:08:22,000 --> 00:08:24,120
然后我就把conf2d的t2设成0

219
00:08:24,280 --> 00:08:26,240
求和之后算一个backward

220
00:08:26,760 --> 00:08:28,960
然后我就直接罗写

221
00:08:28,960 --> 00:08:31,680
这都是t2下降

222
00:08:31,680 --> 00:08:34,639
就它的weight的data

223
00:08:34,639 --> 00:08:37,080
我们之前有讲过怎么访问一个weight的data

224
00:08:37,279 --> 00:08:38,799
就是做inplace操作

225
00:08:39,559 --> 00:08:41,240
它减等于

226
00:08:41,639 --> 00:08:43,960
t学习率就是3e分2

227
00:08:44,199 --> 00:08:46,439
乘以我的t2

228
00:08:46,439 --> 00:08:47,360
就是我们也讲过

229
00:08:47,360 --> 00:08:49,000
做了backward之后

230
00:08:49,000 --> 00:08:50,840
weight.grad就给拿到t2

231
00:08:52,000 --> 00:08:54,519
然后如果每两个batch之后

232
00:08:54,519 --> 00:08:56,120
我就来print一下我的loss

233
00:08:56,720 --> 00:08:59,240
这就是我们罗写的t2下降

234
00:08:59,240 --> 00:09:01,559
所以看到是说

235
00:09:01,600 --> 00:09:03,000
你基本上就是这么

236
00:09:03,000 --> 00:09:04,840
到第10个batch的时候

237
00:09:04,840 --> 00:09:07,120
你的loss就是0.462了

238
00:09:07,919 --> 00:09:09,840
就是我们其实loss就很低了

239
00:09:10,320 --> 00:09:11,480
最后看一下结果

240
00:09:12,480 --> 00:09:13,159
就是说

241
00:09:13,559 --> 00:09:16,679
看到我们的weight的data

242
00:09:16,679 --> 00:09:18,320
我们reshape成1和2

243
00:09:18,360 --> 00:09:19,759
可以看到是说我们学出来

244
00:09:19,759 --> 00:09:21,960
大概就是一个0.91

245
00:09:22,000 --> 00:09:22,639
0.92

246
00:09:23,240 --> 00:09:26,039
一个-1.05的

247
00:09:26,039 --> 00:09:28,679
基本上是一个这样子的权重

248
00:09:29,159 --> 00:09:30,759
跟我们之前的构造出来的

249
00:09:31,039 --> 00:09:33,039
1和-1已经很接近了

250
00:09:33,720 --> 00:09:34,679
所以就是说

251
00:09:34,879 --> 00:09:36,159
给大家举个例子

252
00:09:36,360 --> 00:09:42,240
怎么样去学一个卷积层的权重

253
00:09:42,600 --> 00:09:46,120
通过构造一个人工的数据机

254
00:09:47,319 --> 00:09:47,679
好

255
00:09:47,679 --> 00:09:51,279
这就是我们最简单的

256
00:09:51,279 --> 00:09:52,240
就是一层的定义

257
00:09:52,840 --> 00:09:54,840
输入输出通道都为1

258
00:09:54,879 --> 00:09:56,279
没有做任何的填充

259
00:09:56,279 --> 00:09:58,399
没有做任何的不符

260
00:09:58,519 --> 00:10:00,360
就最简单的操作是这样

261
00:10:00,440 --> 00:10:01,000
这样子

262
00:10:01,480 --> 00:10:03,800
其实也是一个很简单的一个计算

263
00:10:03,800 --> 00:10:04,560
在这里面

264
00:10:05,000 --> 00:10:07,080
这就是我们的代码实现

