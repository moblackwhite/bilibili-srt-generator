1
00:00:00,000 --> 00:00:01,720
好 先行代数

2
00:00:02,319 --> 00:00:05,080
首先我们讲一下标量

3
00:00:05,080 --> 00:00:05,400
对吧

4
00:00:05,400 --> 00:00:06,759
最简单的是标量

5
00:00:06,919 --> 00:00:08,919
对Torch而言

6
00:00:08,919 --> 00:00:12,040
你可以给一个list

7
00:00:12,040 --> 00:00:12,880
Python的list

8
00:00:12,880 --> 00:00:15,960
然后给一个元素3.0

9
00:00:16,000 --> 00:00:17,800
它就变成一个标量

10
00:00:18,359 --> 00:00:20,359
然后给个2.0

11
00:00:20,359 --> 00:00:21,400
它也变成一个标量

12
00:00:21,400 --> 00:00:24,519
当然标量可以做最简单的计算

13
00:00:24,519 --> 00:00:27,640
就是你可以跟Python可能就差不多了

14
00:00:27,760 --> 00:00:29,440
加法乘法除法

15
00:00:29,440 --> 00:00:31,120
指数运算都是一样的

16
00:00:31,880 --> 00:00:33,280
我们昨天也讲过

17
00:00:34,120 --> 00:00:35,039
向量的话

18
00:00:35,039 --> 00:00:38,520
那就是标量值组成的列表

19
00:00:38,560 --> 00:00:39,880
我们昨天也讲过了

20
00:00:39,880 --> 00:00:42,320
怎么样一个arrange来生成一个list

21
00:00:42,560 --> 00:00:43,679
变成0 1 2 3

22
00:00:44,159 --> 00:00:47,159
然后我们给通过它的索引来访问

23
00:00:47,159 --> 00:00:48,159
任何一个元素

24
00:00:48,280 --> 00:00:50,920
就访问第三个元素

25
00:00:50,920 --> 00:00:53,200
就是说这个index是从0开始的

26
00:00:53,200 --> 00:00:54,960
跟计算机语言都是一样的

27
00:00:55,000 --> 00:00:57,600
数学的index是从1开始

28
00:00:57,600 --> 00:01:00,039
所以这样子大家可能要区分一下

29
00:01:02,560 --> 00:01:03,960
然后我们当然可以访问说

30
00:01:03,960 --> 00:01:05,799
这个张量的长度是什么样子

31
00:01:06,079 --> 00:01:07,319
这长度数为4

32
00:01:08,400 --> 00:01:10,680
因为只有一个轴的张量

33
00:01:10,680 --> 00:01:12,640
所以它的形状我们昨天提到

34
00:01:12,640 --> 00:01:13,840
它只有一个元素

35
00:01:13,840 --> 00:01:15,760
所以它是一个长为1的一个列表

36
00:01:15,760 --> 00:01:18,159
它的长度为4

37
00:01:19,400 --> 00:01:19,920
OK

38
00:01:21,400 --> 00:01:24,200
那么接下来我们来创建一个矩阵

39
00:01:24,200 --> 00:01:25,519
我们昨天也讲过

40
00:01:25,880 --> 00:01:26,600
矩阵的话

41
00:01:26,600 --> 00:01:28,960
我们创建一个有20个元素的列表

42
00:01:28,960 --> 00:01:30,600
然后把它reshape成一个

43
00:01:30,600 --> 00:01:32,280
五行四列的一个矩阵

44
00:01:33,280 --> 00:01:34,719
然后矩阵的转制

45
00:01:34,879 --> 00:01:37,400
转制就是将这一个

46
00:01:37,400 --> 00:01:39,079
我的手是有点问题

47
00:01:39,520 --> 00:01:41,879
将这一个

48
00:01:42,280 --> 00:01:44,640
按照对角线把它翻转一下

49
00:01:44,640 --> 00:01:48,200
可以看到是说4翻转到了这个地方

50
00:01:48,760 --> 00:01:52,439
然后8也是翻转到了这个地方

51
00:01:52,759 --> 00:01:55,799
所以基本上做了一个轴对称的翻转

52
00:01:59,560 --> 00:02:01,599
然后对对称矩阵来讲

53
00:02:01,719 --> 00:02:04,959
它其实说就是它的转制等于自己

54
00:02:04,959 --> 00:02:07,759
我们当然可以创建一个对称矩阵

55
00:02:07,759 --> 00:02:09,039
可以看到是说1

56
00:02:09,319 --> 00:02:10,840
对角线上是没关系

57
00:02:10,840 --> 00:02:12,840
但是不是对角线的元素的话

58
00:02:12,840 --> 00:02:15,439
它是可以按照对角线是对称的

59
00:02:15,719 --> 00:02:16,919
所以我们可以比较说

60
00:02:16,919 --> 00:02:18,759
B和B的转制是不是一样

61
00:02:18,800 --> 00:02:20,599
如果它是对称矩阵的话

62
00:02:20,599 --> 00:02:22,960
意味着所有的元素它都是为真的

63
00:02:23,120 --> 00:02:24,919
就是它和它的转制

64
00:02:24,919 --> 00:02:27,280
所有的元素都是可以相等

65
00:02:30,199 --> 00:02:32,799
就像向量是标量的推广

66
00:02:32,799 --> 00:02:34,439
矩阵是向量的推广

67
00:02:34,439 --> 00:02:36,039
我们当然可以构造

68
00:02:36,039 --> 00:02:39,120
有任何具有多轴的数据结构

69
00:02:39,120 --> 00:02:41,719
我可以使用任何维度

70
00:02:41,719 --> 00:02:44,799
只要我的元素个数不发生变化

71
00:02:44,919 --> 00:02:47,879
比如说我们创建一个24的长的向量

72
00:02:48,039 --> 00:02:49,919
然后变成一个三维的矩阵

73
00:02:49,960 --> 00:02:51,200
三维的张量

74
00:02:51,240 --> 00:02:54,160
然后有第一维长度是2 3 4

75
00:02:54,920 --> 00:02:56,680
比如说你可以看到

76
00:02:56,800 --> 00:03:00,280
横是最后一维

77
00:03:00,280 --> 00:03:01,760
就是这个是最后一维

78
00:03:01,800 --> 00:03:06,240
然后列就是倒数第二维

79
00:03:06,240 --> 00:03:07,720
就是也是顺数第二维

80
00:03:07,800 --> 00:03:09,600
然后接下来这个2就表示说

81
00:03:09,760 --> 00:03:11,800
这是第一个维度

82
00:03:11,800 --> 00:03:12,800
这是第二个维度

83
00:03:12,840 --> 00:03:14,160
这就是2的意思

84
00:03:14,960 --> 00:03:17,880
大家是说可能会要多练习一下

85
00:03:17,880 --> 00:03:19,680
到底是2 3 4

86
00:03:19,680 --> 00:03:21,480
到底是怎么样排序

87
00:03:21,480 --> 00:03:24,200
大家有需要有一个直观上的理解

88
00:03:24,240 --> 00:03:25,159
不然的话

89
00:03:25,159 --> 00:03:27,319
人的直觉对于高维的矩阵

90
00:03:27,319 --> 00:03:29,040
确实是有一定局限性的

91
00:03:30,640 --> 00:03:31,319
OK

92
00:03:32,200 --> 00:03:34,400
那么我们昨天也提到过是说

93
00:03:34,400 --> 00:03:36,760
给定任何相同形状的张量

94
00:03:36,760 --> 00:03:39,480
我们都可以按照元素的二维运算

95
00:03:39,480 --> 00:03:40,760
来进行计算

96
00:03:40,800 --> 00:03:41,840
所以得到的结果

97
00:03:41,840 --> 00:03:43,879
跟它的输入是一样的形状

98
00:03:44,319 --> 00:03:46,719
比如说我们同样的例子

99
00:03:46,719 --> 00:03:49,719
我们创建一个5乘4的矩阵

100
00:03:50,120 --> 00:03:51,639
然后我们通过clone

101
00:03:51,759 --> 00:03:53,360
我们昨天也讲过是说

102
00:03:53,360 --> 00:03:54,520
你如果你b等于a

103
00:03:54,520 --> 00:03:55,680
它其实是

104
00:03:55,919 --> 00:03:58,680
就是不会给你做任何的

105
00:03:58,719 --> 00:04:00,280
重新内存的分配

106
00:04:00,280 --> 00:04:02,039
它就是把你的索引给你

107
00:04:02,159 --> 00:04:03,840
重新指定一下

108
00:04:03,879 --> 00:04:05,680
所以你可以通过显示的时候

109
00:04:05,680 --> 00:04:07,159
我要复制一下a

110
00:04:07,319 --> 00:04:09,719
这样子我们把内存给你重新分配一次

111
00:04:09,719 --> 00:04:11,360
所以b和a就没有关系了

112
00:04:11,759 --> 00:04:12,439
但这个运算

113
00:04:12,439 --> 00:04:13,840
当然我们不需要来clone

114
00:04:13,840 --> 00:04:15,240
但是我们只是说告诉大家

115
00:04:15,240 --> 00:04:16,439
有这样子一个选项

116
00:04:16,800 --> 00:04:17,760
然后我们当时说

117
00:04:17,760 --> 00:04:19,560
可以把a和a加b打印出来

118
00:04:19,760 --> 00:04:21,200
就a加b的结果

119
00:04:21,200 --> 00:04:22,600
当然跟a是一样的

120
00:04:22,920 --> 00:04:25,240
大家可以验证一下

121
00:04:25,240 --> 00:04:26,200
是不是正确的

122
00:04:27,000 --> 00:04:27,600
OK

123
00:04:29,200 --> 00:04:33,160
就是说两个矩阵按元素的乘法

124
00:04:33,160 --> 00:04:36,680
在数学上叫做哈德玛基

125
00:04:37,040 --> 00:04:38,800
然后数学符号是一个圈

126
00:04:38,800 --> 00:04:39,960
里面有一个点

127
00:04:41,040 --> 00:04:43,160
但是对计算机的人来讲

128
00:04:43,160 --> 00:04:44,880
就是你乘法就是按元素乘

129
00:04:44,920 --> 00:04:46,800
当然是一个很简单的一些事情

130
00:04:46,800 --> 00:04:48,639
但是从数学家的语言来讲

131
00:04:48,920 --> 00:04:51,519
这个其实是不是一个很常用的乘法

132
00:04:51,719 --> 00:04:54,560
所以它的名字就是比较长一点

133
00:04:54,719 --> 00:04:56,639
而且它的符号也不是那么常用

134
00:04:57,120 --> 00:04:58,159
所以就a乘b

135
00:05:00,000 --> 00:05:01,480
另外一个是说

136
00:05:01,600 --> 00:05:02,480
我们也讲过

137
00:05:02,480 --> 00:05:07,360
如果是一个张量和一个标量的话

138
00:05:07,480 --> 00:05:12,920
就是把标量跟所有的元素做一个加

139
00:05:12,920 --> 00:05:14,360
就是说我a等于2

140
00:05:14,360 --> 00:05:16,560
x等于是一个234的矩阵的话

141
00:05:16,560 --> 00:05:18,439
那么a加上x

142
00:05:18,439 --> 00:05:19,640
就是意味着是说

143
00:05:19,640 --> 00:05:21,199
对于x的所有元素

144
00:05:21,240 --> 00:05:22,199
我都加上a

145
00:05:22,800 --> 00:05:24,280
a乘x也是一样的

146
00:05:24,360 --> 00:05:26,280
对x的所有元素

147
00:05:26,280 --> 00:05:27,319
我都乘以a

148
00:05:27,520 --> 00:05:29,200
大家可以当然可以验我放小一点

149
00:05:29,360 --> 00:05:30,560
大家可以验证一下

150
00:05:31,040 --> 00:05:32,240
的结果的正确性

151
00:05:35,520 --> 00:05:37,400
昨天我们当然也讲过是说

152
00:05:37,400 --> 00:05:39,360
我可以对x求sum

153
00:05:39,600 --> 00:05:42,480
来把所有x的元素给你求和出来

154
00:05:43,920 --> 00:05:45,680
然后你可以sum

155
00:05:45,680 --> 00:05:47,840
你不管是x的形状是什么样子

156
00:05:48,080 --> 00:05:50,160
你的sum永远是一个标量

157
00:05:51,240 --> 00:05:51,840
OK

158
00:05:52,040 --> 00:05:53,800
给你大家再演示一下

159
00:05:53,840 --> 00:05:56,400
如果是变成一个254的情况下

160
00:05:56,400 --> 00:05:58,240
我就是说会怎么样呢

161
00:05:59,280 --> 00:06:00,840
那就是一个254

162
00:06:01,080 --> 00:06:05,080
那么我再对它x等于0求和

163
00:06:05,120 --> 00:06:06,560
那就变成5和4

164
00:06:06,639 --> 00:06:09,000
那就是说我最对外的

165
00:06:09,040 --> 00:06:13,040
我把第一个维度进行了求和

166
00:06:13,120 --> 00:06:14,879
就把剩下两个留下来了

167
00:06:15,040 --> 00:06:16,600
然后同样的道理

168
00:06:16,600 --> 00:06:18,319
我如果按照第二个的话

169
00:06:18,600 --> 00:06:20,720
那么就是说把中间那一个

170
00:06:20,720 --> 00:06:23,360
就是从这个shape是说

171
00:06:23,560 --> 00:06:24,639
这是0

172
00:06:24,879 --> 00:06:25,759
这是0

173
00:06:26,040 --> 00:06:26,879
这是1

174
00:06:27,319 --> 00:06:28,120
这是2

175
00:06:28,160 --> 00:06:30,199
那么我把这一个维度进行了求和

176
00:06:30,199 --> 00:06:31,600
剩下的就是2和4

177
00:06:31,959 --> 00:06:32,439
不好意思

178
00:06:32,600 --> 00:06:34,040
我们刚刚搞混了一点

179
00:06:35,040 --> 00:06:36,040
当然是说

180
00:06:36,040 --> 00:06:38,240
如果我可以按照两个维度求和

181
00:06:39,920 --> 00:06:41,480
大家可以看一下怎么样子

182
00:06:41,680 --> 00:06:43,160
因为两个维度求和的话

183
00:06:43,160 --> 00:06:44,800
我把shape打出来

184
00:06:49,040 --> 00:06:51,480
就是说因为我是第一个和第二个

185
00:06:51,480 --> 00:06:53,959
就是把这两个维度给你求和

186
00:06:53,959 --> 00:06:55,360
然后剩下的shape

187
00:06:55,360 --> 00:06:58,120
应该是长成为最后一个维度的样子

188
00:06:58,560 --> 00:06:59,959
是长这样子的

189
00:07:00,800 --> 00:07:01,360
OK

190
00:07:03,120 --> 00:07:05,240
所以这一块确实是说

191
00:07:05,240 --> 00:07:08,600
每一次你是按照某一个轴来

192
00:07:08,600 --> 00:07:11,000
或者某一个维度来做一些运算的话

193
00:07:11,000 --> 00:07:11,920
经常容易搞混

194
00:07:11,920 --> 00:07:15,320
所以比如说我就刚刚搞混了一下

195
00:07:16,200 --> 00:07:16,520
好

196
00:07:16,520 --> 00:07:18,439
接下来当然是说你可以求和

197
00:07:18,439 --> 00:07:19,600
你也可以求均值

198
00:07:20,000 --> 00:07:22,120
均值的意思是说你先求和

199
00:07:22,120 --> 00:07:23,240
然后把它的

200
00:07:23,280 --> 00:07:26,240
它等价于说你对它求和

201
00:07:26,240 --> 00:07:28,000
然后除以它元素的个数

202
00:07:28,920 --> 00:07:29,960
但同样的话

203
00:07:29,960 --> 00:07:32,400
你可以按照某一个维度来算均值

204
00:07:32,640 --> 00:07:33,640
它同样道理

205
00:07:33,720 --> 00:07:36,840
它可以跟你的求和

206
00:07:36,840 --> 00:07:39,200
然后除以它的维度的形状是一样的

207
00:07:39,200 --> 00:07:40,400
可以等价的操作

208
00:07:44,280 --> 00:07:46,720
还有一个经常我们想用到的是说

209
00:07:46,760 --> 00:07:50,160
我们想在按某一个维度求和的话

210
00:07:50,160 --> 00:07:52,560
我们不想把这个维度给丢掉

211
00:07:52,720 --> 00:07:55,160
就刚刚说我们如果按照维度

212
00:07:55,160 --> 00:07:56,320
为1来求和的话

213
00:07:56,320 --> 00:07:57,320
我们把维度为1

214
00:07:57,320 --> 00:07:58,680
那个维度就丢掉了

215
00:07:58,760 --> 00:08:00,360
如果是一个三维的矩阵

216
00:08:00,360 --> 00:08:01,720
按一个维度求和

217
00:08:01,720 --> 00:08:03,200
它会变成一个二维的矩阵

218
00:08:03,680 --> 00:08:04,760
如果是个二维的矩阵

219
00:08:04,760 --> 00:08:05,960
按一个维度求和

220
00:08:05,960 --> 00:08:07,520
它会变成一个一维的向量

221
00:08:08,200 --> 00:08:10,800
但我们想说我们不丢掉维度

222
00:08:10,800 --> 00:08:13,000
就是keep dimension等于true

223
00:08:13,000 --> 00:08:14,200
那么意味着就是说

224
00:08:14,200 --> 00:08:15,360
我会变成一个

225
00:08:15,360 --> 00:08:17,840
那个被求和的维度的大小

226
00:08:17,840 --> 00:08:18,800
就变成为1

227
00:08:19,800 --> 00:08:21,240
唯一的好处是说

228
00:08:21,240 --> 00:08:21,960
因为这样子

229
00:08:21,960 --> 00:08:23,800
我们就可以通过广播机制

230
00:08:23,800 --> 00:08:25,760
让A会除以A的sum

231
00:08:26,520 --> 00:08:27,480
大家记得吗

232
00:08:27,480 --> 00:08:29,360
如果要用广播机制的话

233
00:08:29,360 --> 00:08:31,600
那么A的维度的个数

234
00:08:31,600 --> 00:08:34,080
和另外一个sum A的维度的个数

235
00:08:34,080 --> 00:08:35,160
必须是一样的

236
00:08:35,759 --> 00:08:37,759
如果你不keep dimension的话

237
00:08:37,759 --> 00:08:39,039
那么你就少掉一个维度

238
00:08:39,039 --> 00:08:40,600
你就不能做广播了

239
00:08:40,600 --> 00:08:42,240
所以经常来说

240
00:08:42,240 --> 00:08:43,799
这个选项

241
00:08:43,799 --> 00:08:45,319
对如果你要用广播机制

242
00:08:45,319 --> 00:08:47,839
是一个非常有用的选项

243
00:08:47,839 --> 00:08:49,360
我们经常会看到

244
00:08:49,360 --> 00:08:51,199
我们以后会给一些样例

245
00:08:54,480 --> 00:08:55,480
OK

246
00:08:55,480 --> 00:08:56,679
当然还是说

247
00:08:56,679 --> 00:08:57,799
我们可以求和

248
00:08:57,799 --> 00:08:59,759
我们可以做累加求和

249
00:08:59,759 --> 00:09:01,120
累加求和是说

250
00:09:01,120 --> 00:09:05,079
我们0求和之后

251
00:09:05,080 --> 00:09:06,879
然后再往前做累加

252
00:09:06,879 --> 00:09:08,320
一直往下累加下去

253
00:09:08,320 --> 00:09:13,320
这就是一个常用的一个计算符

254
00:09:16,600 --> 00:09:17,400
另外一个是说

255
00:09:17,400 --> 00:09:18,800
昨天我们讲到

256
00:09:18,800 --> 00:09:20,320
真正的矩阵的乘法

257
00:09:20,320 --> 00:09:21,800
是有明确定义的

258
00:09:22,600 --> 00:09:23,560
就是说

259
00:09:24,520 --> 00:09:26,240
比如说x是一个

260
00:09:27,080 --> 00:09:28,160
向量的话

261
00:09:28,160 --> 00:09:29,840
xy都是向量的话

262
00:09:29,840 --> 00:09:31,680
dot就表示它的点击

263
00:09:31,680 --> 00:09:32,040
就是说

264
00:09:32,039 --> 00:09:35,319
如果你的x是一个常为4的向量

265
00:09:35,319 --> 00:09:37,000
y也是一个常为4的向量

266
00:09:37,000 --> 00:09:39,480
它的点击就是按元素乘

267
00:09:39,480 --> 00:09:40,719
然后再求和

268
00:09:40,719 --> 00:09:42,000
所以它是一个标量

269
00:09:43,519 --> 00:09:44,959
它等价其实是说

270
00:09:44,959 --> 00:09:46,319
就是把x乘以y

271
00:09:46,319 --> 00:09:48,599
然后对它进行求和

272
00:09:48,599 --> 00:09:50,120
这就是向量的点击

273
00:09:50,120 --> 00:09:51,319
我们昨天也介绍过

274
00:09:53,039 --> 00:09:55,319
那么矩阵乘以向量

275
00:09:55,319 --> 00:09:56,759
就是一个

276
00:09:56,759 --> 00:09:59,599
假设a是一个n乘m的一个矩阵

277
00:09:59,639 --> 00:10:00,879
x是一个

278
00:10:03,040 --> 00:10:05,200
a是一个m乘n的矩阵

279
00:10:05,200 --> 00:10:07,080
x是一个n乘1的矩阵的话

280
00:10:07,080 --> 00:10:08,600
那么它的就是一个

281
00:10:08,600 --> 00:10:10,320
长度为m的一个列向量

282
00:10:10,879 --> 00:10:13,200
而且它的第二个元素

283
00:10:13,200 --> 00:10:15,320
就是a的di列

284
00:10:15,680 --> 00:10:16,840
a的di行

285
00:10:16,840 --> 00:10:20,159
其实是和x做点击的乘法

286
00:10:21,159 --> 00:10:22,519
这样子我们可以看到是说

287
00:10:22,519 --> 00:10:25,160
如果a的是一个5乘4的一个矩阵

288
00:10:25,160 --> 00:10:27,320
x是一个常为4的向量的话

289
00:10:27,320 --> 00:10:28,720
那么它的结果

290
00:10:28,720 --> 00:10:30,639
应该就是一个常为5的一个向量

291
00:10:31,480 --> 00:10:33,560
然后在PyTorch里面

292
00:10:33,560 --> 00:10:34,920
这个是叫MV

293
00:10:34,920 --> 00:10:37,560
就是Matrix Vector Multiplication的意思

294
00:10:37,840 --> 00:10:41,320
就是用矩阵a乘以ax作为向量

295
00:10:41,879 --> 00:10:44,080
然后做矩阵向量的乘积

296
00:10:46,680 --> 00:10:48,440
当然是说昨天我们说过

297
00:10:48,440 --> 00:10:50,279
两个矩阵也得做乘法

298
00:10:50,759 --> 00:10:52,840
如果我们再创建一个矩阵为b

299
00:10:53,279 --> 00:10:56,080
那么a是一个5乘4的一个矩阵

300
00:10:56,120 --> 00:10:58,680
b是一个4乘3的矩阵

301
00:10:58,680 --> 00:11:01,000
那么a和b做MM

302
00:11:01,000 --> 00:11:03,480
就是Matrix Multiplication的话

303
00:11:03,480 --> 00:11:05,920
它会变成一个5乘3的矩阵

304
00:11:06,480 --> 00:11:08,160
我们昨天也定义过它是

305
00:11:08,160 --> 00:11:10,160
具体运算是什么样子

306
00:11:13,520 --> 00:11:15,080
另外我们也讲过范数

307
00:11:15,080 --> 00:11:18,759
范数就是一个向量或者矩阵的一个长度

308
00:11:19,600 --> 00:11:23,000
如果u是一个向量的话

309
00:11:23,200 --> 00:11:26,320
那么它的范数就是一个L2的范数

310
00:11:26,320 --> 00:11:28,399
就是所谓的元素做平方

311
00:11:28,399 --> 00:11:30,159
然后求和再开根号

312
00:11:30,639 --> 00:11:33,200
它的范数就是用none来定义的

313
00:11:33,519 --> 00:11:34,799
就是给一个向量

314
00:11:35,080 --> 00:11:35,960
而用none的话

315
00:11:35,960 --> 00:11:37,399
我们会得到一个标量

316
00:11:38,519 --> 00:11:39,120
同样的话

317
00:11:39,120 --> 00:11:42,159
我们有不一样的范数的定义

318
00:11:42,159 --> 00:11:43,759
我们是L1范数的话

319
00:11:43,759 --> 00:11:46,159
那就是每个元素的绝对和

320
00:11:46,320 --> 00:11:47,720
绝对值求和

321
00:11:49,440 --> 00:11:52,279
PyTorch并没有定义说L1范数怎么运算

322
00:11:52,319 --> 00:11:55,639
那么最简单就是说对u取绝对值

323
00:11:55,639 --> 00:11:56,559
然后求和

324
00:11:56,559 --> 00:11:57,799
这是L1范数

325
00:11:58,240 --> 00:12:00,039
也是一个非常常用的一个范数

326
00:12:00,039 --> 00:12:01,399
我们以后可能会看到

327
00:12:03,439 --> 00:12:05,319
另外对于矩阵也一样

328
00:12:05,319 --> 00:12:07,279
矩阵有很多不一样的范数

329
00:12:07,399 --> 00:12:09,720
最常用的就是F范数

330
00:12:10,079 --> 00:12:13,480
它其实就是每个矩阵的元素的平方

331
00:12:13,480 --> 00:12:15,199
然后求和再开根号

332
00:12:15,439 --> 00:12:17,879
等价是把这个矩阵拉成一个向量

333
00:12:18,600 --> 00:12:20,679
然后把它做一个向量的范数

334
00:12:21,560 --> 00:12:23,760
这可以看到是因为它计算简单

335
00:12:23,760 --> 00:12:26,080
所以是最常用的一个范数

336
00:12:26,080 --> 00:12:26,920
所以Torch的话

337
00:12:26,920 --> 00:12:29,680
你直接通过Long就可以得到F范数

338
00:12:31,920 --> 00:12:32,280
OK

339
00:12:32,280 --> 00:12:35,680
这个就是我们对于所有的线性代数的

340
00:12:35,680 --> 00:12:38,000
一些很简单的一些实现

341
00:12:38,360 --> 00:12:41,560
跟之前的我们讲过的多元素

342
00:12:41,560 --> 00:12:42,760
所获得的标

343
00:12:42,760 --> 00:12:44,840
张量有点类似

344
00:12:44,920 --> 00:12:46,040
但是这里的话

345
00:12:46,040 --> 00:12:48,800
我们主要引进的一些范数和矩阵的

346
00:12:48,800 --> 00:12:49,480
乘法

347
00:12:49,480 --> 00:12:51,039
矩阵和向量的乘法

