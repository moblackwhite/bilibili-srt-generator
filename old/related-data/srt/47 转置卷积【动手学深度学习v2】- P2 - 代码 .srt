1
00:00:00,000 --> 00:00:04,679
好 我们来看一下转制卷迹的实现

2
00:00:05,240 --> 00:00:09,800
我们这个就是刚刚我们所说的转制卷迹的公式

3
00:00:09,800 --> 00:00:11,080
怎么实现它

4
00:00:11,519 --> 00:00:13,720
实现最简单的没有padding

5
00:00:13,720 --> 00:00:15,439
strategy1的时候

6
00:00:15,679 --> 00:00:18,320
就给我一个x 给我一个kernel

7
00:00:18,320 --> 00:00:21,440
然后我能去看出我的kernel的h和w

8
00:00:21,679 --> 00:00:23,879
然后我们就开出我的y

9
00:00:23,879 --> 00:00:26,359
就y我们记得之前

10
00:00:26,359 --> 00:00:30,559
我们就是x的高

11
00:00:31,119 --> 00:00:32,679
减去h加e

12
00:00:34,159 --> 00:00:34,560
你懂吗

13
00:00:34,560 --> 00:00:36,640
就是说我们之前的卷迹这么实现的

14
00:00:36,920 --> 00:00:38,560
就是你得被吃掉一点点

15
00:00:38,920 --> 00:00:40,079
吃掉h减1

16
00:00:40,240 --> 00:00:44,159
现在我们就变成加上h减1

17
00:00:44,159 --> 00:00:45,439
就是说你看到就是说

18
00:00:45,439 --> 00:00:47,840
基本上这个地方就是符号全部变掉了

19
00:00:47,840 --> 00:00:49,879
就是说加法变减法

20
00:00:49,879 --> 00:00:50,960
除法变乘法

21
00:00:50,960 --> 00:00:52,719
基本上就是转制卷迹的做法

22
00:00:52,719 --> 00:00:54,039
对于形状的改变

23
00:00:55,039 --> 00:00:57,719
然后对于每一个x

24
00:00:57,719 --> 00:01:00,479
就是说对每一个x里面的一个element

25
00:01:01,000 --> 00:01:02,479
我们就会得到对应的

26
00:01:02,479 --> 00:01:04,000
它对的就是y

27
00:01:04,000 --> 00:01:08,439
就y里面就是i和i加上h和j和j加上w

28
00:01:08,719 --> 00:01:11,840
加等于xij

29
00:01:12,480 --> 00:01:13,920
传递你的kernel

30
00:01:14,400 --> 00:01:15,039
ok

31
00:01:15,079 --> 00:01:16,400
按元素乘法

32
00:01:16,400 --> 00:01:18,079
但是没有一个sum在这里

33
00:01:18,120 --> 00:01:21,359
然后把它加回到资据证据

34
00:01:21,719 --> 00:01:22,039
ok

35
00:01:22,039 --> 00:01:23,359
就返回我们的y

36
00:01:24,760 --> 00:01:25,200
ok

37
00:01:25,200 --> 00:01:27,880
这就是最基本的转制卷迹

38
00:01:27,880 --> 00:01:30,600
我们刚刚的公式是怎么样实现过来的

39
00:01:32,840 --> 00:01:36,240
然后就是说这个是我们刚刚给的一个样例

40
00:01:36,480 --> 00:01:38,920
样例就是0123

41
00:01:39,280 --> 00:01:40,600
就2×2的x

42
00:01:40,600 --> 00:01:42,280
2×2的kernel

43
00:01:42,320 --> 00:01:44,040
然后帮你做转制卷迹的话

44
00:01:44,160 --> 00:01:45,960
就是得到了我们一个3300的矩阵

45
00:01:46,600 --> 00:01:52,960
也就是我们刚刚在slides里面讲过的样例

46
00:01:54,040 --> 00:01:57,640
然后当然是说我们可以通过

47
00:01:58,800 --> 00:02:00,000
如果是用PyTorch的话

48
00:02:00,000 --> 00:02:02,120
有个n里面一个conf

49
00:02:02,480 --> 00:02:04,960
transpose2d

50
00:02:04,960 --> 00:02:06,400
这个我就

51
00:02:07,640 --> 00:02:10,040
conf里面加了一个transpose

52
00:02:10,360 --> 00:02:11,640
你大家很有

53
00:02:11,640 --> 00:02:13,040
就是说一般来说

54
00:02:14,040 --> 00:02:16,000
有人叫做transpose的conf

55
00:02:16,000 --> 00:02:18,520
或者conftranspose的都有可能

56
00:02:18,920 --> 00:02:20,480
就是PyTorch用的是transpose

57
00:02:21,080 --> 00:02:22,040
然后基本上就是说

58
00:02:22,039 --> 00:02:23,959
你看到它的超参数

59
00:02:23,959 --> 00:02:25,199
跟之前是一样的

60
00:02:25,359 --> 00:02:26,799
就是输入的通道数

61
00:02:27,799 --> 00:02:29,079
输出的通道数

62
00:02:30,680 --> 00:02:32,599
然后你的核的大小

63
00:02:32,599 --> 00:02:34,959
就是你的窗口的大小

64
00:02:35,159 --> 00:02:37,079
然后bios就是说我们就force了

65
00:02:37,079 --> 00:02:38,919
就是就不需要偏差了

66
00:02:40,799 --> 00:02:42,959
然后这里的话

67
00:02:42,959 --> 00:02:45,159
我们就把你的weight的data

68
00:02:45,159 --> 00:02:46,519
直接设成我们的k

69
00:02:46,519 --> 00:02:48,680
然后我们直接把x放进去的话

70
00:02:48,680 --> 00:02:50,439
就会得到以前一样的

71
00:02:50,719 --> 00:02:51,359
唯一的不一样

72
00:02:51,359 --> 00:02:54,439
是说我们这里要加了一个pgin大小

73
00:02:54,439 --> 00:02:55,560
加了一个通道数

74
00:02:55,560 --> 00:02:56,319
两个都是1

75
00:02:58,039 --> 00:02:58,400
Ok

76
00:02:58,400 --> 00:03:00,960
这就是PyTorch的使用

77
00:03:00,960 --> 00:03:03,840
它的conftranspose2d的

78
00:03:04,199 --> 00:03:04,960
怎么用起来

79
00:03:04,960 --> 00:03:05,599
怎么用

80
00:03:05,879 --> 00:03:07,000
基本上可以看到

81
00:03:07,000 --> 00:03:08,079
它的超参数

82
00:03:08,079 --> 00:03:10,199
跟你的conf2d是一样的

83
00:03:10,199 --> 00:03:11,479
一一对应的关系

84
00:03:13,360 --> 00:03:13,599
好

85
00:03:13,599 --> 00:03:14,400
当然我们可以看一下

86
00:03:14,599 --> 00:03:16,360
通过填充

87
00:03:16,840 --> 00:03:17,319
不服

88
00:03:17,520 --> 00:03:18,479
多通道

89
00:03:19,000 --> 00:03:21,520
多通道跟卷积是其实是一样的

90
00:03:21,920 --> 00:03:24,080
主要看一下填充和不服

91
00:03:25,200 --> 00:03:26,800
首先我们看一下填充

92
00:03:29,000 --> 00:03:32,000
填充这个东西就挺好玩的

93
00:03:32,160 --> 00:03:33,040
你可以看一下

94
00:03:35,040 --> 00:03:36,120
填充为1

95
00:03:36,280 --> 00:03:37,520
我们记得填充为1

96
00:03:37,520 --> 00:03:43,040
是在卷积里面通过填充

97
00:03:43,040 --> 00:03:45,680
我们是可以增大我的输出的大小

98
00:03:45,840 --> 00:03:47,400
但现在是反过来了

99
00:03:47,400 --> 00:03:49,640
所以你加了一个排令等于1

100
00:03:49,840 --> 00:03:50,719
你会发现

101
00:03:50,719 --> 00:03:52,879
同样别的东西不变的情况下

102
00:03:52,879 --> 00:03:55,040
你会发现你的输入

103
00:03:55,040 --> 00:03:58,480
会输出会变成了一个单个元素了

104
00:04:00,200 --> 00:04:02,920
刚刚我们其实是一个2×2的矩阵

105
00:04:04,280 --> 00:04:04,680
为什么

106
00:04:05,159 --> 00:04:06,560
因为填充

107
00:04:06,560 --> 00:04:08,200
它你可以理解为

108
00:04:08,200 --> 00:04:11,439
它的填充应该是填充在你的

109
00:04:12,240 --> 00:04:13,319
输出上面

110
00:04:13,319 --> 00:04:14,439
就等于是说

111
00:04:14,479 --> 00:04:17,680
我对输出在填充的1

112
00:04:17,680 --> 00:04:19,480
就上下都填充了1

113
00:04:20,360 --> 00:04:23,639
然后再用同样的克劳等于2的

114
00:04:23,639 --> 00:04:25,279
卷积作用回去之后

115
00:04:25,600 --> 00:04:27,560
就是说填充1就变成3×3

116
00:04:28,079 --> 00:04:28,759
3×3

117
00:04:28,759 --> 00:04:30,279
然后再作用回去之后

118
00:04:30,279 --> 00:04:31,519
会变成一个2×2

119
00:04:33,959 --> 00:04:34,519
OK

120
00:04:34,519 --> 00:04:35,519
所以填充

121
00:04:35,519 --> 00:04:37,319
你可以想象一下

122
00:04:37,319 --> 00:04:41,159
它其实填充在你的输出上面

123
00:04:41,280 --> 00:04:44,439
就是说你要去这么理解

124
00:04:44,439 --> 00:04:45,439
所谓填充

125
00:04:45,439 --> 00:04:46,160
加了填充

126
00:04:46,160 --> 00:04:49,240
其实是让你的输出的大小变小了

127
00:04:50,080 --> 00:04:50,640
OK

128
00:04:52,880 --> 00:04:54,440
另外一个是

129
00:04:54,440 --> 00:04:56,000
stride

130
00:04:56,200 --> 00:04:58,720
就是说我们这里有个stride的东西

131
00:04:58,720 --> 00:04:59,360
在这边

132
00:04:59,480 --> 00:05:00,960
假设我stride等于2的话

133
00:05:00,960 --> 00:05:01,760
会变什么样子

134
00:05:02,320 --> 00:05:04,480
stride2就会变成刚刚是2×2

135
00:05:04,920 --> 00:05:05,400
2×2

136
00:05:05,400 --> 00:05:06,360
stride等于2的话

137
00:05:06,360 --> 00:05:09,480
那就是每一次我们不再是后面

138
00:05:09,480 --> 00:05:09,960
挑一个

139
00:05:09,960 --> 00:05:10,879
而是挑两个

140
00:05:11,680 --> 00:05:13,879
比如说这一个就是我的

141
00:05:14,560 --> 00:05:16,120
第一行第二列的元素

142
00:05:16,120 --> 00:05:17,480
它的对应的就是

143
00:05:17,480 --> 00:05:19,560
写在这个地方

144
00:05:19,920 --> 00:05:20,879
所以就是说

145
00:05:20,879 --> 00:05:25,639
它会变成了一个4×4的一个东西

146
00:05:26,159 --> 00:05:26,920
比如说

147
00:05:27,759 --> 00:05:29,079
增大stride

148
00:05:29,079 --> 00:05:31,279
其实会把我的输出变大的

149
00:05:34,639 --> 00:05:35,240
OK

150
00:05:36,279 --> 00:05:37,199
然后

151
00:05:38,360 --> 00:05:39,959
多通道的话

152
00:05:40,159 --> 00:05:44,759
其实是没什么太多区别的

153
00:05:45,439 --> 00:05:46,120
比如说

154
00:05:46,439 --> 00:05:47,039
通道的话

155
00:05:47,039 --> 00:05:49,120
我们x有10个通道的话

156
00:05:49,120 --> 00:05:52,199
那么做一个卷积10会变成20

157
00:05:52,279 --> 00:05:53,399
那么我会

158
00:05:53,399 --> 00:05:55,439
然后我可以20变成10

159
00:05:56,079 --> 00:05:59,319
就是说跟你的卷积的多通道是一回事

160
00:05:59,319 --> 00:06:00,399
因为转制卷积

161
00:06:00,399 --> 00:06:02,919
它主要是在你这个kernel

162
00:06:02,919 --> 00:06:05,439
你那个kernel怎么作用在一个上面

163
00:06:05,439 --> 00:06:06,839
在多通道上是一样的

164
00:06:07,000 --> 00:06:08,560
所以就是说

165
00:06:08,600 --> 00:06:10,120
假设我有一个

166
00:06:10,600 --> 00:06:11,680
一个conf的RD

167
00:06:11,680 --> 00:06:13,120
一个conf transpose Rd

168
00:06:13,480 --> 00:06:14,199
别的参数

169
00:06:14,199 --> 00:06:15,439
假设都是一样的话

170
00:06:15,439 --> 00:06:16,280
那么kernel等于5

171
00:06:16,280 --> 00:06:17,000
padding等于2

172
00:06:17,000 --> 00:06:19,280
stride等于那些3

173
00:06:19,439 --> 00:06:20,079
就是说

174
00:06:20,480 --> 00:06:21,519
后面的那一块

175
00:06:21,639 --> 00:06:22,720
我可以给大家

176
00:06:23,040 --> 00:06:23,759
画出来

177
00:06:23,920 --> 00:06:24,879
写出来这个

178
00:06:29,800 --> 00:06:30,959
就可以看到是说

179
00:06:30,959 --> 00:06:33,959
假设你的后面那些东西都长一样的话

180
00:06:35,040 --> 00:06:37,160
而且你的卷积是从10变成20

181
00:06:37,160 --> 00:06:38,480
从20变成10的话

182
00:06:38,480 --> 00:06:40,400
那么我一个x

183
00:06:40,400 --> 00:06:41,960
一个任意的x进来

184
00:06:41,960 --> 00:06:43,200
先通过conf

185
00:06:43,240 --> 00:06:44,360
再通过transpose

186
00:06:44,360 --> 00:06:45,439
transpose

187
00:06:45,439 --> 00:06:46,280
conf的话

188
00:06:46,280 --> 00:06:48,319
回去的shape应该是一样的

189
00:06:48,319 --> 00:06:49,480
你可以认为是说

190
00:06:49,480 --> 00:06:51,439
你看x被conf一下

191
00:06:51,480 --> 00:06:52,560
再被transpose

192
00:06:52,560 --> 00:06:53,400
conf一下

193
00:06:53,439 --> 00:06:55,800
然后的shape是等于原来的

194
00:06:55,800 --> 00:06:56,200
shape

195
00:06:56,879 --> 00:06:59,600
因为你像通道从10变成20

196
00:06:59,600 --> 00:07:01,160
然后再从20变成10

197
00:07:01,200 --> 00:07:02,200
然后这一块

198
00:07:02,200 --> 00:07:03,960
就是因为超参数是一样的

199
00:07:03,960 --> 00:07:04,600
就是说

200
00:07:04,640 --> 00:07:06,759
它把一个16×16

201
00:07:06,759 --> 00:07:08,400
变回到某一个大小

202
00:07:08,400 --> 00:07:11,000
然后同样的超参数

203
00:07:11,000 --> 00:07:13,040
又会变回到16×16

204
00:07:13,040 --> 00:07:14,120
所以这就是

205
00:07:14,760 --> 00:07:16,400
他们两个的关系

206
00:07:19,400 --> 00:07:21,040
然后最后我们来看一下

207
00:07:21,040 --> 00:07:22,440
说我们有提到过

208
00:07:22,440 --> 00:07:23,520
跟矩阵

209
00:07:24,400 --> 00:07:26,320
乘法和矩阵转制的关系

210
00:07:26,320 --> 00:07:27,440
我们给大家来看一下

211
00:07:27,440 --> 00:07:28,360
这是怎么回事

212
00:07:29,840 --> 00:07:30,760
然后我们一样的

213
00:07:30,840 --> 00:07:32,840
我们构造一个x是一个33

214
00:07:33,560 --> 00:07:35,560
从01-9的一个

215
00:07:35,600 --> 00:07:36,600
从01-8的

216
00:07:37,200 --> 00:07:39,840
然后你的k就是1234的

217
00:07:39,840 --> 00:07:41,000
一个2×2的kernel

218
00:07:41,480 --> 00:07:43,960
然后我的y反正就是

219
00:07:44,120 --> 00:07:46,360
我们之前有实现过correlation2d

220
00:07:46,439 --> 00:07:50,640
就是你的卷积的最简单版本

221
00:07:50,840 --> 00:07:52,120
可以得到这个结果

222
00:07:53,240 --> 00:07:55,080
然后我们可以把这个东西

223
00:07:55,720 --> 00:07:57,320
转换成一个矩阵

224
00:07:57,320 --> 00:07:58,920
怎么样来做计算

225
00:08:00,720 --> 00:08:02,080
所以kernel to matrix

226
00:08:02,080 --> 00:08:02,680
是怎么

227
00:08:03,320 --> 00:08:04,000
做什么事情

228
00:08:04,399 --> 00:08:06,839
就是给我一个kernel k

229
00:08:06,879 --> 00:08:09,759
我把它变成刚刚我们说的v

230
00:08:10,600 --> 00:08:12,439
就刚刚我们在slides里面讲过的

231
00:08:12,800 --> 00:08:15,839
就是说我把它变成一个大一样的矩阵

232
00:08:15,839 --> 00:08:18,800
使得我们能把卷积变成一个矩阵乘法

233
00:08:19,439 --> 00:08:21,199
具体怎么样来做

234
00:08:21,199 --> 00:08:24,040
我就具体怎么做出来的

235
00:08:24,040 --> 00:08:25,680
就是说给大家看一下

236
00:08:25,680 --> 00:08:27,600
最后说结果长这样子

237
00:08:28,759 --> 00:08:33,240
结果w是一个4×9的东西

238
00:08:34,879 --> 00:08:36,159
这为什么是4×9

239
00:08:36,320 --> 00:08:37,360
是因为你的输入

240
00:08:37,360 --> 00:08:39,279
你的x是一个3×3

241
00:08:40,399 --> 00:08:42,320
我把你的3×3拉长之后

242
00:08:42,320 --> 00:08:43,480
变成一个长为9的项链

243
00:08:43,480 --> 00:08:43,919
对吧

244
00:08:44,559 --> 00:08:45,720
所以你需要

245
00:08:45,720 --> 00:08:47,639
如果你想把w放在前面的话

246
00:08:47,960 --> 00:08:51,200
那么它的列数一定是等于9的

247
00:08:52,440 --> 00:08:54,360
然后你看第一行是什么意思

248
00:08:55,399 --> 00:08:56,480
第一行说白了

249
00:08:56,480 --> 00:09:00,600
就是在卷集和

250
00:09:00,639 --> 00:09:05,279
在对第一个块做的时候

251
00:09:05,279 --> 00:09:06,040
是怎么做的

252
00:09:06,399 --> 00:09:08,040
说白了就是卷集和

253
00:09:08,040 --> 00:09:10,399
把你的左上角那一块

254
00:09:10,399 --> 00:09:11,960
二乘二的东西拿出来

255
00:09:12,360 --> 00:09:14,279
然后做一下

256
00:09:14,279 --> 00:09:15,920
就是基本上把它拉成一个项链

257
00:09:15,920 --> 00:09:16,720
然后做下类机

258
00:09:16,720 --> 00:09:17,200
对吧

259
00:09:18,560 --> 00:09:20,240
所以你这个地方你怎么写

260
00:09:20,240 --> 00:09:21,279
你这个地方就是说

261
00:09:21,279 --> 00:09:22,920
把你对应的那些元素

262
00:09:22,920 --> 00:09:24,080
要参与做的时候

263
00:09:24,080 --> 00:09:26,320
填好你的科农那个值

264
00:09:26,800 --> 00:09:27,879
别的不参与

265
00:09:27,879 --> 00:09:28,600
现在卷集的

266
00:09:28,600 --> 00:09:30,040
在卷集窗口以外的

267
00:09:30,039 --> 00:09:31,039
全部变成0

268
00:09:31,799 --> 00:09:32,480
这样子的话

269
00:09:32,679 --> 00:09:36,839
我这一条去跟你的整个x

270
00:09:37,039 --> 00:09:39,439
做矩阵乘法的

271
00:09:39,439 --> 00:09:41,279
也就是说做类机的时候

272
00:09:41,279 --> 00:09:44,519
就会还原出我科农

273
00:09:44,519 --> 00:09:47,199
在某一个左上角位置

274
00:09:47,199 --> 00:09:48,439
做的时候效果

275
00:09:49,000 --> 00:09:50,120
把结果一写

276
00:09:50,559 --> 00:09:51,559
同样的道理的话

277
00:09:51,559 --> 00:09:52,879
我的输出是一个二乘二

278
00:09:52,919 --> 00:09:55,959
就是说我要做4次卷集的操作

279
00:09:55,959 --> 00:09:57,679
那么就是我有4行

280
00:09:57,679 --> 00:09:59,039
每一行对是

281
00:09:59,039 --> 00:10:00,439
我的输出元素

282
00:10:01,240 --> 00:10:02,879
对应的卷集操作

283
00:10:02,879 --> 00:10:03,399
是这么做了

284
00:10:03,639 --> 00:10:06,319
所以它就会变成一个矩阵的乘法

285
00:10:06,480 --> 00:10:08,799
所以它就是一个4乘9的一个

286
00:10:09,399 --> 00:10:10,039
一个矩阵

287
00:10:10,039 --> 00:10:12,799
而且是根据你的输入的大小

288
00:10:12,799 --> 00:10:13,679
给你构造出来的

289
00:10:13,799 --> 00:10:15,480
这个函数是给你构造这个事情

290
00:10:17,599 --> 00:10:18,439
然后可以看一下

291
00:10:18,599 --> 00:10:19,399
就是说

292
00:10:20,360 --> 00:10:22,480
我们拿到了w的话

293
00:10:22,480 --> 00:10:24,639
我们对xreshape成一个

294
00:10:24,719 --> 00:10:25,679
一个向量

295
00:10:26,079 --> 00:10:27,879
然后再做一个矩阵乘法

296
00:10:27,919 --> 00:10:30,399
直接w乘以x那个向量版本

297
00:10:30,799 --> 00:10:33,320
再把它reshape回二乘二的话

298
00:10:33,320 --> 00:10:35,840
它应该是等于我们之前的y

299
00:10:35,879 --> 00:10:38,720
y就是用卷集做出来的y

300
00:10:41,320 --> 00:10:41,600
好

301
00:10:41,600 --> 00:10:42,639
接下来看一下

302
00:10:43,320 --> 00:10:44,519
假设

303
00:10:45,320 --> 00:10:46,679
我用y

304
00:10:47,840 --> 00:10:51,320
对k做转制卷集

305
00:10:51,320 --> 00:10:52,600
转制就刚刚我们实现了

306
00:10:52,879 --> 00:10:54,080
等于z

307
00:10:55,120 --> 00:10:56,519
它等价于什么呢

308
00:10:56,639 --> 00:11:01,319
等价于我们刚刚对kr做的w

309
00:11:01,759 --> 00:11:02,439
w

310
00:11:03,720 --> 00:11:07,960
w的转制乘以你的输入y的reshape

311
00:11:08,399 --> 00:11:10,559
再把你reshape成三三

312
00:11:10,799 --> 00:11:11,960
它就会等于z

313
00:11:12,960 --> 00:11:14,559
所以这就是为什么说

314
00:11:14,559 --> 00:11:16,559
转制局卷集

315
00:11:16,559 --> 00:11:19,319
它的转制是因为来自于它对应的

316
00:11:19,319 --> 00:11:20,360
矩阵乘法

317
00:11:21,079 --> 00:11:23,439
它可以变成转制的形式

318
00:11:23,520 --> 00:11:26,600
就卷集是w乘以x

319
00:11:26,960 --> 00:11:27,720
转制卷集

320
00:11:27,760 --> 00:11:30,600
那就w的转制乘以你的

321
00:11:30,600 --> 00:11:32,120
也是我们向量的

322
00:11:32,120 --> 00:11:32,880
我们现在是y

323
00:11:32,960 --> 00:11:34,360
就是乘以你的输入

324
00:11:34,640 --> 00:11:35,240
OK

325
00:11:35,480 --> 00:11:38,360
这就是转制卷集的来历

326
00:11:38,640 --> 00:11:39,280
总结一下

327
00:11:39,920 --> 00:11:40,440
说白了

328
00:11:41,680 --> 00:11:43,560
卷集能够把一个东西变小

329
00:11:43,800 --> 00:11:45,600
转制卷集能把它变大

330
00:11:45,680 --> 00:11:46,680
具体怎么工作

331
00:11:46,680 --> 00:11:47,360
就是说

332
00:11:47,400 --> 00:11:48,680
只要超参数一样

333
00:11:49,000 --> 00:11:49,800
转制卷集

334
00:11:50,480 --> 00:11:54,000
把对应超参数的输出的大小

335
00:11:54,000 --> 00:11:55,200
变成输入的大小

336
00:11:56,080 --> 00:11:57,200
输入的大小变输出

337
00:11:57,200 --> 00:11:58,040
就反过来

338
00:11:58,200 --> 00:11:59,680
假设一个超参数的卷集

339
00:11:59,680 --> 00:12:02,440
把某一个变成另外一个的话

340
00:12:02,440 --> 00:12:03,040
对应的操作

341
00:12:03,040 --> 00:12:05,360
就把另外一个就变回去

342
00:12:06,120 --> 00:12:07,920
所以有了这一个对应的话

343
00:12:07,920 --> 00:12:10,320
就大家可以很容易的去判断说

344
00:12:10,320 --> 00:12:11,880
我这个东西

345
00:12:11,880 --> 00:12:12,920
你知道你搞清楚了

346
00:12:12,920 --> 00:12:15,440
转卷集是怎么样

347
00:12:15,480 --> 00:12:17,320
对形状进行变换的话

348
00:12:17,520 --> 00:12:19,160
之前我们怎么设piling

349
00:12:19,279 --> 00:12:20,159
怎么设stride

350
00:12:20,319 --> 00:12:21,519
怎么设kernel的话

351
00:12:21,559 --> 00:12:22,480
反过来讲

352
00:12:22,519 --> 00:12:24,439
转制卷集也是一样的

353
00:12:24,480 --> 00:12:26,120
就算你理解那个是怎么过去的

354
00:12:26,120 --> 00:12:28,039
转制卷集就是立一下就行了

355
00:12:28,199 --> 00:12:28,799
OK

356
00:12:29,679 --> 00:12:33,279
这个也是我们在明天会给大家讲的

357
00:12:33,319 --> 00:12:34,519
全链接设计网络

358
00:12:34,519 --> 00:12:36,039
做语音分割的时候

359
00:12:36,079 --> 00:12:37,559
最重要的一个层

360
00:12:37,559 --> 00:12:38,679
新引入的一个层

361
00:12:38,679 --> 00:12:40,639
我们今天先介绍到这个地方

