1
00:00:00,000 --> 00:00:00,840
好

2
00:00:00,840 --> 00:00:08,359
我们先讲卷积层的两个控制输出大小的一个超参数

3
00:00:08,359 --> 00:00:09,720
一个叫填充

4
00:00:09,720 --> 00:00:11,320
一个叫做不服

5
00:00:14,560 --> 00:00:17,920
首先我们来看一下我们为什么要有填充这个东西

6
00:00:18,480 --> 00:00:19,760
我先看一个例子

7
00:00:19,760 --> 00:00:25,039
假设我们给定一个32×32的输入的图像

8
00:00:25,599 --> 00:00:29,799
也就是我们之前用的整个FreshM list的图片

9
00:00:29,799 --> 00:00:31,879
都是一个32×32的图片

10
00:00:33,399 --> 00:00:37,359
然后如果我们用一个5×5大小的卷积核的话

11
00:00:38,000 --> 00:00:41,039
我们知道用了一个5×5的话

12
00:00:41,039 --> 00:00:43,920
我们的输出就会减少4×4

13
00:00:44,719 --> 00:00:49,560
那就是说32×32变成了28×28

14
00:00:50,799 --> 00:00:54,120
这个就是用一次卷积得到的输出

15
00:00:55,439 --> 00:00:57,240
然后用7层之后

16
00:00:57,240 --> 00:01:02,359
我们就得到输出是一个4×4的一个小方块了

17
00:01:04,359 --> 00:01:07,319
而且如果我们用更大的卷积核的话

18
00:01:07,319 --> 00:01:09,400
我们可以使得它变得更小

19
00:01:11,280 --> 00:01:16,799
就是说我们知道如果的输入是NH×NW的话

20
00:01:16,799 --> 00:01:18,519
NH是它的高

21
00:01:18,519 --> 00:01:19,640
NW是它的快

22
00:01:19,640 --> 00:01:20,599
就是它的劣数

23
00:01:21,039 --> 00:01:24,759
那么你的输出会减少到NH-KH加1

24
00:01:24,760 --> 00:01:27,920
这个是它的行数

25
00:01:27,920 --> 00:01:29,880
然后NW-KW加1

26
00:01:29,880 --> 00:01:30,840
这是它的劣数

27
00:01:31,120 --> 00:01:32,880
当你用特别大的卷积核的时候

28
00:01:32,880 --> 00:01:34,960
你的输入会变得比较小

29
00:01:37,240 --> 00:01:39,439
那么它会有个问题是说

30
00:01:39,439 --> 00:01:42,360
假设我不想要输入变得那么小

31
00:01:42,640 --> 00:01:43,360
那怎么办

32
00:01:44,560 --> 00:01:47,960
特别是说当我想用比较大的卷积核的时候

33
00:01:47,960 --> 00:01:52,280
如果我觉得我的图片的大小就不是很大

34
00:01:52,360 --> 00:01:53,920
就是一个32×32

35
00:01:53,920 --> 00:01:56,760
那么你可能用个三四层

36
00:01:57,079 --> 00:02:00,159
你就变得一个很小的一个核了

37
00:02:00,400 --> 00:02:01,560
你就无法再用了

38
00:02:01,760 --> 00:02:05,640
特别是说我们就用一个不是那么大的5×5的卷积核的话

39
00:02:05,680 --> 00:02:07,240
用到第7层的时候

40
00:02:07,240 --> 00:02:08,800
我的输出变成4×4

41
00:02:08,800 --> 00:02:10,639
我就不可能再用一个卷积核了

42
00:02:10,800 --> 00:02:14,920
也就是说我的乘数不能超过7层

43
00:02:16,560 --> 00:02:18,920
如果我要想做更深的设计网络怎么办

44
00:02:19,159 --> 00:02:23,439
我们知道整个深度学习是关于如何用更深的模型

45
00:02:23,439 --> 00:02:26,879
用几百个卷积层来做我们的模型

46
00:02:26,879 --> 00:02:29,439
那么这个情况我们肯定就不行了

47
00:02:30,039 --> 00:02:32,039
所以解决这个方向

48
00:02:32,319 --> 00:02:35,879
这个问题的一个办法叫做用填充

49
00:02:36,960 --> 00:02:38,599
填充其实很简单的思想

50
00:02:38,879 --> 00:02:42,120
就是说我们在输入的四周

51
00:02:42,680 --> 00:02:44,599
加入一些额外的行合列

52
00:02:45,879 --> 00:02:49,840
达到说我们的输出可以比以前更大

53
00:02:51,000 --> 00:02:52,680
这里举一个例子是说

54
00:02:53,759 --> 00:02:54,879
我们用笔了

55
00:02:56,039 --> 00:02:58,680
举个例子是说我们在这个地方

56
00:02:58,680 --> 00:03:01,719
这个是以前的原始的输入

57
00:03:01,719 --> 00:03:04,199
我们标一下原始的输入是这个地方

58
00:03:06,479 --> 00:03:10,159
我们在这里用在上下左右

59
00:03:10,319 --> 00:03:14,079
分别填充了一些零

60
00:03:14,199 --> 00:03:16,039
就是说我们上面填充了一行

61
00:03:16,039 --> 00:03:16,800
下面一行

62
00:03:16,800 --> 00:03:17,639
左边一行

63
00:03:17,639 --> 00:03:18,479
左边一列

64
00:03:18,479 --> 00:03:19,280
右边一列

65
00:03:19,719 --> 00:03:21,240
而且填充的只剩零

66
00:03:21,280 --> 00:03:25,120
那么我们填充之后

67
00:03:25,120 --> 00:03:27,000
我们再来做我们的剪辑

68
00:03:27,000 --> 00:03:29,640
可以发现我们昨天有讲过

69
00:03:30,280 --> 00:03:33,159
一块之前我们是在这个地方做对吧

70
00:03:33,520 --> 00:03:35,200
现在因为我们填充了之后

71
00:03:35,200 --> 00:03:36,520
那么可以挪到这个角落

72
00:03:37,280 --> 00:03:39,600
那么我们的第一个输出是为零了

73
00:03:40,080 --> 00:03:41,960
然后我们一直往下做的话

74
00:03:42,439 --> 00:03:44,520
那么会到这个地方

75
00:03:45,439 --> 00:03:46,800
所以可以看到是说

76
00:03:46,800 --> 00:03:49,520
假设我们填充了一圈零的话

77
00:03:49,520 --> 00:03:54,880
我们之前的输出会变成一个2×2的矩阵

78
00:03:55,159 --> 00:03:58,040
现在我们会变成一个4×4了

79
00:03:59,200 --> 00:03:59,640
对吧

80
00:03:59,640 --> 00:04:03,520
我们可以变得输出比输入还要大一点

81
00:04:03,800 --> 00:04:05,320
还多一行和多一列

82
00:04:05,680 --> 00:04:07,000
这就是填充的效果

83
00:04:09,840 --> 00:04:11,280
我们可以看一个

84
00:04:11,280 --> 00:04:13,520
我们这里应该有一个小小动画

85
00:04:13,520 --> 00:04:15,439
我把可以看一下

86
00:04:15,439 --> 00:04:17,120
就填充跟我们之前一样了

87
00:04:17,120 --> 00:04:17,879
填充完之后

88
00:04:17,879 --> 00:04:20,159
我们一样的滑动我们的窗口

89
00:04:20,159 --> 00:04:21,279
得到我们的输出

90
00:04:23,399 --> 00:04:23,759
OK

91
00:04:26,439 --> 00:04:27,959
一般定义上来上

92
00:04:27,959 --> 00:04:31,199
我们假设要填充PH行

93
00:04:31,199 --> 00:04:32,600
就P是padding的意思

94
00:04:33,120 --> 00:04:34,879
和PW列的话

95
00:04:35,319 --> 00:04:38,879
那我们的输出的形状就会变成了这个地方

96
00:04:39,240 --> 00:04:41,519
就是我们会多了一个这样子的参数进来

97
00:04:42,120 --> 00:04:44,040
假设没有填充的话

98
00:04:44,040 --> 00:04:45,000
那么这个是等于0

99
00:04:45,000 --> 00:04:46,519
就是我们之前的公式

100
00:04:46,919 --> 00:04:48,039
现在我们填充了之后

101
00:04:48,039 --> 00:04:50,560
我们会加了一个PH和一个PW进来

102
00:04:52,879 --> 00:04:57,799
就通常我们会选择PH等于KH-1

103
00:04:58,439 --> 00:05:02,479
就是说通常我们会填充你的和的高宽-1的

104
00:05:02,479 --> 00:05:03,039
那个值

105
00:05:03,039 --> 00:05:05,639
就是我们这是我们通常的取值

106
00:05:06,240 --> 00:05:07,919
它的取值的好处是什么样子

107
00:05:07,919 --> 00:05:11,680
好处是说你把这一个项带进去之后

108
00:05:11,680 --> 00:05:13,240
整个这一项会消成0

109
00:05:14,399 --> 00:05:14,680
对吧

110
00:05:14,680 --> 00:05:15,639
同样的值

111
00:05:15,959 --> 00:05:17,639
你把这个带进去的话

112
00:05:17,639 --> 00:05:19,120
那么这一项会消成等于0

113
00:05:21,079 --> 00:05:24,319
那就是说我的输出和我的输入

114
00:05:24,519 --> 00:05:26,199
它的形状不会发生变化

115
00:05:27,680 --> 00:05:30,399
就是我的输出也会变成NH乘以NW

116
00:05:31,839 --> 00:05:33,479
那这是一个挺好的东西

117
00:05:33,479 --> 00:05:34,839
因为这样子的话

118
00:05:34,839 --> 00:05:38,639
我们不管我们选取多大的和的大小

119
00:05:38,639 --> 00:05:41,839
我们都会不会改变我们输出的形状

120
00:05:43,399 --> 00:05:44,439
具体来说

121
00:05:44,759 --> 00:05:46,879
我们说的是填充PH

122
00:05:47,079 --> 00:05:48,639
我们在填充的时候

123
00:05:48,639 --> 00:05:50,680
我们可以在上面填充下面填充

124
00:05:51,199 --> 00:05:54,000
当你KH为奇数的时候

125
00:05:54,000 --> 00:05:55,000
那么挺简单的

126
00:05:55,000 --> 00:05:56,639
因为你的PH是个偶数

127
00:05:56,639 --> 00:05:59,959
那我们的上下两侧都会填充PH除以2

128
00:06:01,600 --> 00:06:02,959
填充值一般是取0

129
00:06:03,959 --> 00:06:06,159
当你的和为偶数的时候

130
00:06:06,839 --> 00:06:11,240
我们其实很少用一个为偶数的卷积和

131
00:06:11,240 --> 00:06:13,040
但是如果你发生了

132
00:06:14,040 --> 00:06:17,000
那么一个做法是说我们上侧会填一个

133
00:06:17,000 --> 00:06:18,520
多一行

134
00:06:18,520 --> 00:06:20,000
下侧会填少一行

135
00:06:20,000 --> 00:06:20,960
这都没关系

136
00:06:20,960 --> 00:06:22,240
但你反过来也是可以的

137
00:06:22,240 --> 00:06:25,360
一般来说大家不会发现

138
00:06:25,560 --> 00:06:27,160
反过来会有太多的变化

139
00:06:27,920 --> 00:06:28,120
好

140
00:06:28,120 --> 00:06:31,040
这个是我们填充的事情

141
00:06:32,040 --> 00:06:34,960
第二个是说不服

142
00:06:36,600 --> 00:06:37,879
我们来看一下不服

143
00:06:37,879 --> 00:06:39,759
它是一个什么样的想法

144
00:06:39,879 --> 00:06:44,399
假设我们的输入是一个比较大的一个

145
00:06:44,399 --> 00:06:45,000
输入的话

146
00:06:45,000 --> 00:06:47,000
我们之前是32×32

147
00:06:47,240 --> 00:06:51,879
现在假设我们的输入变成了一个224×224

148
00:06:52,599 --> 00:06:55,240
这个是我们之后要用比较深的

149
00:06:55,240 --> 00:06:55,959
审计网络

150
00:06:55,959 --> 00:06:58,399
它通常用的一个输入都是比较大的

151
00:06:58,879 --> 00:06:59,680
实际上来说

152
00:06:59,680 --> 00:07:02,120
224×224的图片也是一个很小的图片

153
00:07:02,120 --> 00:07:03,959
就那么你看起来就那么一点点的

154
00:07:05,399 --> 00:07:08,319
那么假设你用这么一个大小的图片的话

155
00:07:08,480 --> 00:07:11,680
而且在你使用5×5的卷集合的情况下

156
00:07:12,240 --> 00:07:14,839
你想要最后得到你的输出比较小

157
00:07:14,839 --> 00:07:17,959
假设我的输出要成为一个4×4的输出的话

158
00:07:18,800 --> 00:07:21,879
我需要44层

159
00:07:24,199 --> 00:07:28,360
就是说假设我就想用把我一个图片

160
00:07:28,560 --> 00:07:30,199
慢慢变得小

161
00:07:30,199 --> 00:07:31,360
然后做输出的话

162
00:07:32,039 --> 00:07:35,079
我需要至少我要44层才行

163
00:07:36,839 --> 00:07:38,000
这就比较痛苦了

164
00:07:38,439 --> 00:07:40,240
因为你乘数越多

165
00:07:40,240 --> 00:07:41,639
你的计算就越复杂

166
00:07:41,639 --> 00:07:43,959
我如果想用一个比较小一点

167
00:07:43,959 --> 00:07:45,279
乘数低一点的话

168
00:07:45,279 --> 00:07:47,680
当然你可以使用比较大的卷集合了

169
00:07:47,680 --> 00:07:49,040
但我们之前有讲过

170
00:07:49,040 --> 00:07:52,040
通常我们会选用5×5 3×3

171
00:07:52,040 --> 00:07:53,560
但不会用太大的卷集合

172
00:07:54,279 --> 00:07:58,480
那么你就需要大量的计算

173
00:07:58,480 --> 00:07:59,920
才能得到较小的输出

174
00:08:01,319 --> 00:08:03,360
不服其实是来解决这个问题

175
00:08:03,960 --> 00:08:04,480
就是说

176
00:08:05,040 --> 00:08:09,960
因为你之前是我的输出的大小

177
00:08:09,960 --> 00:08:12,160
是跟你乘数线性相关

178
00:08:12,680 --> 00:08:14,920
那么不服可以让它变成指数相关

179
00:08:16,400 --> 00:08:17,520
我们来看一下不服

180
00:08:18,800 --> 00:08:20,080
不服的意思就是说

181
00:08:20,080 --> 00:08:21,480
我们这里有个小动画

182
00:08:23,319 --> 00:08:24,600
其实他就是想说

183
00:08:24,600 --> 00:08:27,360
你在每一次移动窗口的时候

184
00:08:28,040 --> 00:08:32,399
之前我们每一次都是往右移格

185
00:08:32,439 --> 00:08:33,759
或者往下移格

186
00:08:34,799 --> 00:08:35,959
不服的意思是说

187
00:08:36,319 --> 00:08:37,720
我可以控制它

188
00:08:37,720 --> 00:08:39,600
每一次不要移一个可以移两个

189
00:08:41,319 --> 00:08:42,679
我们这里举了一个具体的例子

190
00:08:43,720 --> 00:08:44,319
大家看一下

191
00:08:45,720 --> 00:08:46,959
就是说假设我们

192
00:08:49,120 --> 00:08:50,639
选一个高度的

193
00:08:50,639 --> 00:08:53,279
在高度上我的不服为3

194
00:08:53,959 --> 00:08:56,039
我的宽度上的不服为2

195
00:08:56,039 --> 00:08:57,000
会发生什么事情呢

196
00:08:57,639 --> 00:08:59,759
第一个假设我们的和还是2×2的话

197
00:08:59,759 --> 00:09:02,120
第一个很显然

198
00:09:02,200 --> 00:09:03,679
我们这有个padding记得

199
00:09:04,519 --> 00:09:06,759
第一个我们还是之前跟它作用

200
00:09:07,440 --> 00:09:08,799
那么得到它的值是等于0

201
00:09:10,200 --> 00:09:11,000
那么接下来

202
00:09:11,000 --> 00:09:14,519
假设我的宽度上的不服为2的情况下

203
00:09:15,279 --> 00:09:17,600
那么我的下一个不再是之前

204
00:09:17,600 --> 00:09:19,399
我们去考虑这一个输入

205
00:09:19,919 --> 00:09:22,799
而是我们往右边一两列

206
00:09:23,440 --> 00:09:24,960
就是说直接移到这个地方

207
00:09:27,159 --> 00:09:27,720
OK

208
00:09:27,720 --> 00:09:30,560
这就是在宽度上不服为2的情况

209
00:09:31,000 --> 00:09:32,720
我们默认不服为1

210
00:09:32,720 --> 00:09:34,720
现在我们2×2的话

211
00:09:34,720 --> 00:09:36,080
我们就每次跳两列

212
00:09:37,440 --> 00:09:38,520
那么跳到这个地方

213
00:09:38,520 --> 00:09:39,560
你会发现说

214
00:09:39,560 --> 00:09:41,800
我往这边跳没得跳了

215
00:09:41,800 --> 00:09:43,520
因为我还要往这边跳的话

216
00:09:43,520 --> 00:09:44,800
那就只跳到这个地方

217
00:09:44,800 --> 00:09:46,720
这个地方已经这边空一列了

218
00:09:46,720 --> 00:09:47,400
就是说

219
00:09:47,400 --> 00:09:48,640
所以这边就没有值了

220
00:09:50,000 --> 00:09:50,960
这样子你的输出

221
00:09:50,960 --> 00:09:52,200
你的列数就为2

222
00:09:54,240 --> 00:09:55,640
那么在高度上来说

223
00:09:55,640 --> 00:09:57,400
我们假设我们去3的话

224
00:09:57,960 --> 00:09:59,440
那么第一个在这个地方

225
00:09:59,920 --> 00:10:02,560
往下我们要往下走三行

226
00:10:02,560 --> 00:10:03,720
而不是之前的一行

227
00:10:04,800 --> 00:10:06,720
那么就会直接走到这个地方

228
00:10:07,840 --> 00:10:09,120
那么跟他做输入的话

229
00:10:09,120 --> 00:10:10,160
可以得到他的输出

230
00:10:12,360 --> 00:10:13,480
那么就意味着是说

231
00:10:13,480 --> 00:10:14,640
之前我们说

232
00:10:14,640 --> 00:10:17,320
我们当你padding是为

233
00:10:17,320 --> 00:10:18,080
现在是为2

234
00:10:18,440 --> 00:10:21,400
就是宽度和高度的padding都是为2

235
00:10:24,160 --> 00:10:26,280
我们不做不服的调整

236
00:10:26,280 --> 00:10:27,760
我们不服等于1的话

237
00:10:28,080 --> 00:10:29,639
我们的输出是一个4乘4

238
00:10:31,799 --> 00:10:32,720
那么现在我们说

239
00:10:32,720 --> 00:10:34,319
我们高度的不服为3

240
00:10:34,319 --> 00:10:36,240
宽度的不服为2

241
00:10:36,240 --> 00:10:37,879
我们直接把我们的输出

242
00:10:37,879 --> 00:10:39,600
变成了一个2乘2的一个小矩阵了

243
00:10:40,360 --> 00:10:42,200
这就是不服的概念

244
00:10:42,720 --> 00:10:45,080
就是每一次你在滑动窗口的时候

245
00:10:45,080 --> 00:10:48,200
控制你是去往右边走多少列

246
00:10:48,200 --> 00:10:49,720
和往下走多少行

247
00:10:49,720 --> 00:10:50,519
这就是不服

248
00:10:52,319 --> 00:10:54,879
我们可以直接来算一下

249
00:10:55,080 --> 00:10:56,200
我们会怎么算

250
00:10:57,200 --> 00:11:01,200
首先假设我的高度的不服为sh的话

251
00:11:01,200 --> 00:11:03,400
我的宽度是sw的话

252
00:11:03,840 --> 00:11:05,720
那么我的输出的形状

253
00:11:05,720 --> 00:11:07,640
就是几乎你可以看到

254
00:11:07,640 --> 00:11:09,600
是有除了一个sh

255
00:11:11,800 --> 00:11:12,879
当你等1的时候

256
00:11:12,879 --> 00:11:14,320
当然是没有什么变化的

257
00:11:14,680 --> 00:11:18,640
当你等于2的话

258
00:11:18,640 --> 00:11:19,800
基本上你可以认为

259
00:11:19,800 --> 00:11:22,360
是被把我的东西砍了一半

260
00:11:22,879 --> 00:11:24,879
当然是说你要处理说

261
00:11:25,279 --> 00:11:27,639
我可以跳到最后发现不够了

262
00:11:27,799 --> 00:11:28,960
我得丢掉那一些

263
00:11:28,960 --> 00:11:31,559
所以这里有一个加上一个sh在这个地方

264
00:11:31,559 --> 00:11:34,559
然后还取了一个floor

265
00:11:34,559 --> 00:11:36,919
就是取了一个往下去这样的操作

266
00:11:39,240 --> 00:11:40,200
一般来说我们知道

267
00:11:40,360 --> 00:11:41,600
我们的padding

268
00:11:41,600 --> 00:11:42,679
就是我们的填充

269
00:11:42,679 --> 00:11:45,600
一般会选取和的大小减1

270
00:11:46,039 --> 00:11:48,159
那么就是说你把这个带进去之后

271
00:11:48,439 --> 00:11:50,759
我们直接可以这里就可以算出来是

272
00:11:50,759 --> 00:11:53,720
nh加上sh减1除以sh

273
00:11:53,759 --> 00:11:54,759
这是我们的东西

274
00:11:55,480 --> 00:11:56,639
另外一个是说

275
00:11:56,639 --> 00:12:00,519
假设你的输入的高度和宽度

276
00:12:00,519 --> 00:12:02,720
都可以被不复整除的时候

277
00:12:03,200 --> 00:12:04,600
这个也是我们经常的情况

278
00:12:04,879 --> 00:12:06,440
我们不复通常取2

279
00:12:07,200 --> 00:12:09,600
所以你假设你的宽度和高度

280
00:12:09,600 --> 00:12:10,720
都是偶数的话

281
00:12:10,720 --> 00:12:14,000
那么你直接可以写成nh除以sh

282
00:12:14,399 --> 00:12:16,360
然后nw除以sw

283
00:12:17,480 --> 00:12:19,040
大家可以去算一下

284
00:12:19,040 --> 00:12:21,160
这些往下取整是怎么算出来的

285
00:12:21,680 --> 00:12:22,560
但是一般来说

286
00:12:22,560 --> 00:12:24,360
大家不用考虑那么复杂的情况

287
00:12:24,720 --> 00:12:27,400
一般你取的填充比较好

288
00:12:27,400 --> 00:12:31,400
然后你的高和宽都是2的倍数的话

289
00:12:31,400 --> 00:12:32,720
而且不复取2的话

290
00:12:32,920 --> 00:12:34,320
你基本上可以认为

291
00:12:34,320 --> 00:12:36,320
我每一次把我的输入和输出

292
00:12:37,360 --> 00:12:40,200
输入的高和宽全部除了2

293
00:12:41,120 --> 00:12:41,480
OK

294
00:12:41,480 --> 00:12:43,840
这就是我们不复的概念

295
00:12:46,080 --> 00:12:46,920
那么总结一下

296
00:12:49,080 --> 00:12:49,600
总结一下

297
00:12:49,600 --> 00:12:52,279
就是说我们的填充和不复

298
00:12:52,279 --> 00:12:55,279
都是卷积层的超参数

299
00:12:55,960 --> 00:12:57,320
我们上一次有讲过

300
00:12:57,320 --> 00:12:58,680
卷积层另外一个超参数

301
00:12:58,680 --> 00:13:00,320
是我们的和的大小

302
00:13:02,240 --> 00:13:04,200
所以填充在这个地方是说

303
00:13:04,200 --> 00:13:06,800
我们在输入的周围

304
00:13:07,080 --> 00:13:08,840
添加额外的一些行和列

305
00:13:09,040 --> 00:13:10,200
通常只是为0

306
00:13:10,840 --> 00:13:12,960
来控制输出的减少量

307
00:13:13,600 --> 00:13:15,680
因为你填充永远是让你的输出

308
00:13:15,960 --> 00:13:18,560
至少是不变或者变大

309
00:13:20,600 --> 00:13:22,320
这个是处理在

310
00:13:22,320 --> 00:13:24,399
当你的图片比较小的时候

311
00:13:24,399 --> 00:13:25,920
而且你不想让你

312
00:13:26,800 --> 00:13:28,440
卷积层给你减少输出

313
00:13:28,440 --> 00:13:31,200
使得你能达到比较大的一个

314
00:13:32,240 --> 00:13:33,960
比较深的一个模型的时候

315
00:13:33,960 --> 00:13:35,000
通常用的办法

316
00:13:36,159 --> 00:13:37,480
不复是说

317
00:13:37,600 --> 00:13:40,440
我可以控制每一次滑动窗口

318
00:13:40,440 --> 00:13:43,240
是每一次罗的行和列的步长

319
00:13:43,680 --> 00:13:45,680
这样子我能成倍的减少

320
00:13:45,680 --> 00:13:46,920
我的输出的形状

321
00:13:47,560 --> 00:13:48,800
这是用来控制说

322
00:13:48,920 --> 00:13:52,360
当你的输入的大小比较大的时候

323
00:13:52,360 --> 00:13:54,280
我可以通过不复来

324
00:13:54,280 --> 00:13:57,200
使得我能够把我的输出的大小

325
00:13:57,200 --> 00:13:58,400
成倍的往下减

326
00:13:59,160 --> 00:14:01,520
使得我能够减少我的计算量

327
00:14:02,840 --> 00:14:03,160
OK

328
00:14:03,640 --> 00:14:06,080
这就是填充和不复

