1
00:00:00,000 --> 00:00:00,680
好

2
00:00:00,680 --> 00:00:02,800
我首先给大家总结一下

3
00:00:03,000 --> 00:00:08,320
我们上一次竞赛的牛仔装备检测的一个总结

4
00:00:08,960 --> 00:00:11,439
首先非常简洋的回顾一下

5
00:00:11,480 --> 00:00:14,439
我们这个任务就是检测那些牛仔的装备

6
00:00:14,480 --> 00:00:15,439
牛仔的夹克

7
00:00:15,560 --> 00:00:16,679
墨镜靴子

8
00:00:16,800 --> 00:00:18,000
牛仔帽腰带

9
00:00:18,199 --> 00:00:19,640
大家参加过了

10
00:00:19,640 --> 00:00:20,440
可能已经注意到

11
00:00:20,519 --> 00:00:23,199
就是夹克是一件很大的一个东西

12
00:00:23,199 --> 00:00:23,679
对吧

13
00:00:23,760 --> 00:00:24,719
靴子很小

14
00:00:24,719 --> 00:00:26,320
让你腰带就更加小了

15
00:00:27,039 --> 00:00:29,199
我们有大概7000张照片

16
00:00:29,399 --> 00:00:31,359
13000个表注框

17
00:00:32,439 --> 00:00:34,039
它的一个挑战是说

18
00:00:34,039 --> 00:00:37,200
你的腰带基本上没有多少

19
00:00:37,560 --> 00:00:39,000
因为你其实很正常

20
00:00:39,000 --> 00:00:40,439
你戴墨镜其实很正常

21
00:00:40,640 --> 00:00:42,439
比如说我出门都得戴墨镜

22
00:00:42,439 --> 00:00:44,719
因为这边太阳太晒了

23
00:00:45,039 --> 00:00:46,719
夹克也大家穿多

24
00:00:46,840 --> 00:00:48,039
牛仔帽和靴子

25
00:00:49,399 --> 00:00:50,519
很多人还是会穿

26
00:00:51,439 --> 00:00:53,960
但是腰带这个东西确实不那么方便

27
00:00:54,519 --> 00:00:56,280
而且你可能不一定能拍得到

28
00:00:56,320 --> 00:00:59,280
所以导致说你的腰带在里面特别少

29
00:00:59,719 --> 00:01:03,439
牛仔帽子和靴子就算属于也是偏少

30
00:01:03,719 --> 00:01:05,719
主要就是墨镜和夹克

31
00:01:06,480 --> 00:01:09,879
当然是说这都会带来一点点的问题

32
00:01:10,280 --> 00:01:13,520
所以这个也是在目标解决之外

33
00:01:13,879 --> 00:01:15,040
有一点点的挑战

34
00:01:15,079 --> 00:01:16,920
这也在现实生活中特别常见

35
00:01:17,079 --> 00:01:19,560
你会发现说有一类数据特别少

36
00:01:19,840 --> 00:01:21,400
有一些数据特别多

37
00:01:23,120 --> 00:01:24,319
结果就是说

38
00:01:24,320 --> 00:01:26,320
我们一共有23名同学

39
00:01:26,320 --> 00:01:28,840
提交了大概300次的提交

40
00:01:30,320 --> 00:01:32,280
相对我们前两次来说

41
00:01:32,280 --> 00:01:33,000
会少很多

42
00:01:33,160 --> 00:01:34,000
这个在意料之中

43
00:01:34,040 --> 00:01:35,400
因为目标检测

44
00:01:35,800 --> 00:01:37,520
整体来讲门槛比较高

45
00:01:37,800 --> 00:01:41,360
整个我们其实也没有特别详细讲说

46
00:01:42,160 --> 00:01:44,760
我们讲的东西不足以让大家

47
00:01:44,920 --> 00:01:46,600
能够得到很好的成绩

48
00:01:46,640 --> 00:01:47,880
然后你想得到很好的成绩

49
00:01:47,880 --> 00:01:48,760
后面讲的中间

50
00:01:48,800 --> 00:01:50,920
还有一个超级大的一个区

51
00:01:50,920 --> 00:01:52,960
一个gap在那里

52
00:01:53,960 --> 00:01:55,960
我们也是因为时间原因

53
00:01:56,080 --> 00:01:57,800
不可能讲到那么多细节

54
00:01:58,040 --> 00:01:59,360
就算大家去看论文

55
00:01:59,360 --> 00:01:59,920
那好

56
00:02:00,120 --> 00:02:02,960
那一块其实还是比较深的

57
00:02:03,400 --> 00:02:05,320
我们有15名同学公布了代码

58
00:02:05,440 --> 00:02:06,240
在开口上面

59
00:02:06,240 --> 00:02:07,160
我觉得特别好

60
00:02:07,160 --> 00:02:08,159
因为我觉得竞赛

61
00:02:08,159 --> 00:02:10,000
其实对大家主要的好处是说

62
00:02:10,040 --> 00:02:11,600
大家真的去看一下

63
00:02:12,960 --> 00:02:14,920
大家相互分享代码学习

64
00:02:14,960 --> 00:02:16,560
我觉得这个是主要的目的

65
00:02:16,719 --> 00:02:18,879
我建议大家没有去参加竞赛的

66
00:02:18,879 --> 00:02:20,360
也去看一看那些代码

67
00:02:20,600 --> 00:02:22,240
给大家一个直观上的体验

68
00:02:22,960 --> 00:02:25,520
所以请我们在final phase

69
00:02:25,680 --> 00:02:27,000
前10名的同学

70
00:02:27,360 --> 00:02:30,040
并提交了代码的同学

71
00:02:30,200 --> 00:02:31,280
将你的微信号

72
00:02:31,360 --> 00:02:32,000
开口号

73
00:02:32,000 --> 00:02:33,680
和你的code lab

74
00:02:33,680 --> 00:02:35,719
就是提交的排名的账号的ID

75
00:02:35,719 --> 00:02:36,159
发给我

76
00:02:36,520 --> 00:02:37,680
我来统计一下

77
00:02:37,840 --> 00:02:39,000
然后我们希望

78
00:02:40,719 --> 00:02:42,000
然后我们加一个群

79
00:02:42,000 --> 00:02:42,960
这样子的话

80
00:02:42,960 --> 00:02:44,760
我们在中文书出版的时候

81
00:02:44,760 --> 00:02:47,120
我会给你寄你一个签名的版本

82
00:02:47,480 --> 00:02:48,560
我们中文书

83
00:02:48,879 --> 00:02:50,280
如果你要问我们什么时候出版

84
00:02:51,520 --> 00:02:52,400
这是个很好的问题

85
00:02:52,400 --> 00:02:54,640
我们尽量我们在想

86
00:02:54,840 --> 00:02:56,000
10月份之前

87
00:02:56,120 --> 00:02:56,719
不能盯稿

88
00:02:56,879 --> 00:02:57,480
给出版社

89
00:02:57,480 --> 00:02:58,080
但出版社

90
00:02:58,080 --> 00:03:00,840
出版这个东西是一个非常

91
00:03:01,520 --> 00:03:02,759
有严格标准的事情

92
00:03:02,759 --> 00:03:03,840
跟造硬件有点像

93
00:03:03,960 --> 00:03:05,159
不像我们造软件

94
00:03:05,159 --> 00:03:05,879
造软件

95
00:03:06,080 --> 00:03:07,960
你就是你可以

96
00:03:08,200 --> 00:03:09,840
每一个版本的出去

97
00:03:09,840 --> 00:03:10,159
就是说

98
00:03:10,159 --> 00:03:11,640
我说我快速给一个版本

99
00:03:11,920 --> 00:03:12,560
弄出来

100
00:03:12,560 --> 00:03:13,280
大家用

101
00:03:13,560 --> 00:03:14,159
有问题

102
00:03:14,159 --> 00:03:15,879
我们赶紧去改

103
00:03:15,920 --> 00:03:17,680
所以你可能一个月发一个版本都行

104
00:03:17,680 --> 00:03:18,920
或者三个月发一个版本

105
00:03:18,960 --> 00:03:20,520
但出书有点像造硬件

106
00:03:20,520 --> 00:03:22,360
你出本书可能得用个

107
00:03:22,560 --> 00:03:23,319
你印出来之后

108
00:03:23,319 --> 00:03:24,800
可能得印个一两年

109
00:03:24,840 --> 00:03:27,480
所以就像造硬件一样

110
00:03:27,480 --> 00:03:29,000
就是说硬件可能是

111
00:03:29,400 --> 00:03:30,360
你造一代出来

112
00:03:30,480 --> 00:03:31,680
用一个一两年

113
00:03:31,719 --> 00:03:33,719
所以出书的逻辑

114
00:03:33,840 --> 00:03:36,759
和发软件的逻辑是很不一样的

115
00:03:36,960 --> 00:03:37,840
我们这个书

116
00:03:37,960 --> 00:03:39,319
我们动手学生读学机

117
00:03:39,319 --> 00:03:40,800
更像一个造软件的方法

118
00:03:40,800 --> 00:03:41,920
我们是用一个

119
00:03:42,360 --> 00:03:44,800
用写开源软件的方法来写书

120
00:03:44,800 --> 00:03:46,719
所以我们可以每个月更新一个版本

121
00:03:46,719 --> 00:03:47,800
或每几个月更新一个版本

122
00:03:47,800 --> 00:03:48,800
可以不断的更新

123
00:03:49,240 --> 00:03:51,680
但是导致的问题是说

124
00:03:51,680 --> 00:03:52,599
你永远都不知道

125
00:03:52,599 --> 00:03:54,240
什么时候应该去出一个书

126
00:03:54,760 --> 00:03:55,159
对了

127
00:03:55,159 --> 00:03:56,159
就是说我永远觉得

128
00:03:56,319 --> 00:03:57,680
我还有那么多东西可以改进

129
00:03:57,680 --> 00:03:58,400
可以那么改

130
00:03:58,640 --> 00:03:59,480
我一直改下去的话

131
00:03:59,480 --> 00:04:00,640
就是一个无缘

132
00:04:00,680 --> 00:04:03,319
我就是个无穷无尽的过程

133
00:04:03,480 --> 00:04:05,920
所以出版社的编辑

134
00:04:05,920 --> 00:04:06,840
就一直鼓励说

135
00:04:07,159 --> 00:04:07,760
不用紧

136
00:04:07,760 --> 00:04:08,319
不要紧

137
00:04:08,560 --> 00:04:09,120
赶紧出

138
00:04:09,280 --> 00:04:11,879
然后你永远不会有完美的时刻

139
00:04:11,879 --> 00:04:13,640
OK

140
00:04:13,920 --> 00:04:15,560
这就是我们的出版的一些

141
00:04:15,560 --> 00:04:17,439
小小的好有意思的东西

142
00:04:18,759 --> 00:04:19,040
好

143
00:04:19,040 --> 00:04:19,879
我给大家讲一下

144
00:04:19,879 --> 00:04:21,839
就是说两个我觉得值得讲的东西

145
00:04:22,480 --> 00:04:25,800
这一次从主要是大家提交代码上来看

146
00:04:26,240 --> 00:04:29,480
就第一个技术是数据的重采样

147
00:04:29,920 --> 00:04:31,920
就当你有的类别

148
00:04:32,439 --> 00:04:34,560
样本严重不足的时候

149
00:04:34,879 --> 00:04:36,040
你在训练会什么问题

150
00:04:36,240 --> 00:04:36,920
就是说

151
00:04:37,199 --> 00:04:38,159
假设你的腰带

152
00:04:38,439 --> 00:04:40,199
你现在腰带是严重不足

153
00:04:40,199 --> 00:04:42,360
假设你是用我们正常的

154
00:04:42,920 --> 00:04:44,199
SGD的训练的话

155
00:04:44,199 --> 00:04:46,480
你每一次采样一个小批量的时候

156
00:04:46,480 --> 00:04:47,480
你会发现

157
00:04:47,520 --> 00:04:50,040
采样到腰带的

158
00:04:51,200 --> 00:04:52,960
可能概率就非常低了

159
00:04:53,080 --> 00:04:55,879
导致模型就不会去

160
00:04:55,879 --> 00:04:57,800
主要都是在看墨镜和夹克

161
00:04:57,800 --> 00:04:59,480
所以整个模型的模型根因

162
00:05:00,200 --> 00:05:02,759
会朝着墨镜和夹克那边走

163
00:05:02,759 --> 00:05:04,439
而在你的腰带那边

164
00:05:04,560 --> 00:05:06,720
就因为没有看太多腰带

165
00:05:07,040 --> 00:05:08,800
所以导致说整个模型

166
00:05:08,800 --> 00:05:11,040
对腰带这一块训练是不充分的

167
00:05:13,520 --> 00:05:14,600
最简单的答案

168
00:05:14,879 --> 00:05:16,080
就是你要怎么做

169
00:05:16,079 --> 00:05:18,560
你就是把你不足的那些类别

170
00:05:18,919 --> 00:05:20,839
复制几次

171
00:05:21,919 --> 00:05:23,039
不是我们现在图片

172
00:05:23,159 --> 00:05:24,199
图片是每一个类别

173
00:05:24,199 --> 00:05:25,279
是一个文件夹

174
00:05:25,319 --> 00:05:26,359
里面很多张图片

175
00:05:26,359 --> 00:05:26,800
对吧

176
00:05:26,800 --> 00:05:28,639
假设你什么都不想改代码的情况下

177
00:05:28,959 --> 00:05:30,399
你就去腰带文件夹

178
00:05:32,000 --> 00:05:33,479
把图片给复制几分

179
00:05:33,959 --> 00:05:36,199
当然是说我们现在是目标检测

180
00:05:36,279 --> 00:05:37,439
我们目标检测标号

181
00:05:37,439 --> 00:05:39,599
是在一个文本文件里面

182
00:05:39,879 --> 00:05:42,639
你还可以把文本文件里面东西复制几次

183
00:05:42,680 --> 00:05:43,799
如果你去图片分类的话

184
00:05:43,799 --> 00:05:45,319
你就把图片给复制几次

185
00:05:45,319 --> 00:05:45,959
都可以

186
00:05:46,199 --> 00:05:49,120
这个是最简单快操猛的办法

187
00:05:50,959 --> 00:05:52,839
当然这个东西的会带来一些

188
00:05:52,879 --> 00:05:54,800
说你读取的时候

189
00:05:55,120 --> 00:05:55,759
就是

190
00:05:56,439 --> 00:05:57,240
不那么灵活

191
00:05:57,479 --> 00:05:59,360
就是说你到底要复制多少次

192
00:05:59,800 --> 00:06:01,240
然后特别图片

193
00:06:01,560 --> 00:06:02,519
你复制起来的话

194
00:06:02,519 --> 00:06:03,879
你有读取的开销

195
00:06:04,000 --> 00:06:06,319
一般的正常的做法有两种

196
00:06:06,360 --> 00:06:07,519
一种是说

197
00:06:07,680 --> 00:06:10,599
在你随机采样小批量的时候

198
00:06:11,000 --> 00:06:12,839
你不是均匀的采样

199
00:06:13,039 --> 00:06:14,479
我们之前都是说

200
00:06:14,680 --> 00:06:16,280
我把整个样本拿过来

201
00:06:16,280 --> 00:06:17,600
随机shuffle一下

202
00:06:17,600 --> 00:06:19,280
然后一次过去

203
00:06:19,319 --> 00:06:22,400
这个可以认为是比较均匀的采样

204
00:06:22,680 --> 00:06:23,800
现在你可以说

205
00:06:23,800 --> 00:06:25,240
我可以根据每个类别

206
00:06:27,080 --> 00:06:28,680
然后比如说

207
00:06:29,120 --> 00:06:30,120
腰带这个类

208
00:06:30,120 --> 00:06:31,960
我可以采样这个类里面

209
00:06:31,960 --> 00:06:33,400
采样的频率会高一点

210
00:06:34,200 --> 00:06:36,520
然后你的牛仔帽和靴子

211
00:06:36,560 --> 00:06:38,360
那些类的采样中的

212
00:06:38,400 --> 00:06:40,439
墨镜夹克采样的频率

213
00:06:40,439 --> 00:06:41,560
我可以低一点

214
00:06:41,720 --> 00:06:42,720
这样子的话

215
00:06:42,720 --> 00:06:44,400
就算在整个数据里面

216
00:06:44,520 --> 00:06:46,360
他们是非常分布不均的

217
00:06:46,360 --> 00:06:47,760
但是我采样之后

218
00:06:47,760 --> 00:06:49,400
使得我小批量里面

219
00:06:49,720 --> 00:06:50,880
他们出现的频率

220
00:06:50,920 --> 00:06:52,320
就差别没那么大

221
00:06:52,640 --> 00:06:55,360
这个是一个叫做从采样

222
00:06:55,520 --> 00:06:57,000
一般的做法是说

223
00:06:57,000 --> 00:06:58,320
你可以比如说

224
00:06:58,320 --> 00:07:00,200
我能算出每一个类别

225
00:07:00,360 --> 00:07:02,400
它在整个数据中出现的概率

226
00:07:03,120 --> 00:07:05,160
比如说是墨镜这个地方

227
00:07:05,160 --> 00:07:06,480
大概是比如说是0.3

228
00:07:07,800 --> 00:07:08,840
夹克是0.3

229
00:07:09,040 --> 00:07:10,080
牛仔帽靴子

230
00:07:10,080 --> 00:07:12,160
比如说是0.1

231
00:07:12,240 --> 00:07:13,840
然后腰带是0.01

232
00:07:13,880 --> 00:07:14,520
比如说

233
00:07:14,840 --> 00:07:16,400
然后你正常采样的话

234
00:07:16,400 --> 00:07:16,960
当然是说

235
00:07:16,960 --> 00:07:19,680
你墨镜就是按照0.3来采样

236
00:07:19,960 --> 00:07:20,720
但我怎么做

237
00:07:20,880 --> 00:07:22,000
我可以说0.3

238
00:07:22,000 --> 00:07:23,360
我加一个p次方

239
00:07:23,360 --> 00:07:25,760
对所谓的概率加一个p次方

240
00:07:26,480 --> 00:07:27,000
这个p

241
00:07:27,560 --> 00:07:29,240
就你可以取一个

242
00:07:29,600 --> 00:07:30,920
比如说很小的数

243
00:07:31,400 --> 00:07:32,760
当你取到特别小的数

244
00:07:32,760 --> 00:07:33,360
都变成一了

245
00:07:33,400 --> 00:07:34,720
就每个样都是一样的

246
00:07:34,760 --> 00:07:35,240
对吧

247
00:07:35,720 --> 00:07:36,160
就是说

248
00:07:36,160 --> 00:07:37,160
但你也不需要说

249
00:07:37,160 --> 00:07:38,960
你每一个类别都采样一样

250
00:07:38,960 --> 00:07:41,280
因为毕竟腰带就那么几个腰带

251
00:07:41,280 --> 00:07:42,880
你一直在学它

252
00:07:42,880 --> 00:07:44,480
导致整个分类器

253
00:07:44,480 --> 00:07:46,560
只看见腰带也没什么意思

254
00:07:46,560 --> 00:07:47,920
就是太over fitting了

255
00:07:48,080 --> 00:07:49,320
所以你可以取一个p

256
00:07:49,320 --> 00:07:49,920
就是说

257
00:07:49,920 --> 00:07:52,280
把它们整个拉得平那么一点点

258
00:07:52,280 --> 00:07:53,520
不要差别那么大

259
00:07:53,760 --> 00:07:55,200
这个是一种做法

260
00:07:56,520 --> 00:07:57,920
另外一种做法是说

261
00:07:58,200 --> 00:07:59,360
我不采

262
00:07:59,760 --> 00:08:03,040
不是随机采样做改进

263
00:08:03,040 --> 00:08:05,800
还是说在计算损失的时候

264
00:08:06,080 --> 00:08:08,480
就是说对不足类别的样本

265
00:08:08,640 --> 00:08:10,400
它给比较大的权重

266
00:08:10,800 --> 00:08:11,680
通常来说

267
00:08:12,120 --> 00:08:14,160
我们知道在我们现在

268
00:08:14,160 --> 00:08:15,400
就是说深度学习框架

269
00:08:16,400 --> 00:08:17,520
Cross entropy loss

270
00:08:18,040 --> 00:08:18,800
损失函数

271
00:08:19,080 --> 00:08:21,320
你都可以给每个样本一个权重

272
00:08:21,560 --> 00:08:22,720
我们用这个做过事情

273
00:08:22,840 --> 00:08:24,320
我们用来做mask用的

274
00:08:24,440 --> 00:08:24,720
就是说

275
00:08:25,080 --> 00:08:26,280
说这个样本是一个

276
00:08:26,280 --> 00:08:27,800
都是一些padding的东西

277
00:08:27,840 --> 00:08:30,080
我说不要它来计算损失

278
00:08:30,080 --> 00:08:31,520
我们给它一个0的权重

279
00:08:31,720 --> 00:08:33,040
但你现在这个地方的话

280
00:08:33,040 --> 00:08:34,720
就是说你对腰带这个样本

281
00:08:34,960 --> 00:08:36,680
可以给它一个比较大的权重

282
00:08:37,200 --> 00:08:39,720
使得虽然我看到它的概率小

283
00:08:39,800 --> 00:08:41,200
但是一旦看到它

284
00:08:41,200 --> 00:08:43,279
因为它有比较大的权重

285
00:08:43,279 --> 00:08:44,920
所以在算损失的时候

286
00:08:45,080 --> 00:08:46,840
整个t度会往那边偏

287
00:08:46,840 --> 00:08:49,200
所以它的根系就会往那边偏

288
00:08:49,519 --> 00:08:50,440
这两个

289
00:08:51,040 --> 00:08:53,960
都是我们非常常用的一个做法

290
00:08:55,759 --> 00:08:57,519
而且我感觉说

291
00:08:58,480 --> 00:08:59,800
你一定说谁

292
00:08:59,800 --> 00:09:00,920
这两个算法

293
00:09:00,920 --> 00:09:02,600
我觉得在一定程度上是等价的

294
00:09:02,600 --> 00:09:06,560
所以你们用谁都行

295
00:09:07,160 --> 00:09:08,440
另外有意思的是说

296
00:09:08,440 --> 00:09:09,800
有一个同学用了一个

297
00:09:09,800 --> 00:09:11,520
叫做smooth的

298
00:09:11,520 --> 00:09:14,040
smooth的一个算法

299
00:09:14,320 --> 00:09:15,560
这个算法是挺有意思

300
00:09:15,560 --> 00:09:15,960
一个算法

301
00:09:16,080 --> 00:09:17,320
这个是一个很经典的

302
00:09:17,320 --> 00:09:19,960
在统计里面的一个算法

303
00:09:20,240 --> 00:09:21,280
虽然我不知道

304
00:09:21,280 --> 00:09:22,000
在

305
00:09:22,400 --> 00:09:24,520
在目标检测这个数据上

306
00:09:24,520 --> 00:09:25,800
用它会不会有问题

307
00:09:26,880 --> 00:09:29,040
但是这样大家有同学用到

308
00:09:29,160 --> 00:09:30,640
所以我给大家讲一下这个算法

309
00:09:30,680 --> 00:09:32,680
这个算法就是说

310
00:09:33,120 --> 00:09:34,440
我们之前都是讲说

311
00:09:34,440 --> 00:09:35,480
我不改数据

312
00:09:35,480 --> 00:09:37,560
就是改变采样的频率

313
00:09:37,560 --> 00:09:38,760
或改变它的权重

314
00:09:39,080 --> 00:09:40,240
这个算法是说

315
00:09:40,280 --> 00:09:43,760
我在那些小的那些类别里面

316
00:09:45,680 --> 00:09:48,640
去做找一些新的样本出来

317
00:09:48,880 --> 00:09:50,960
就是说假设我腰带类别

318
00:09:52,040 --> 00:09:53,240
就那么几张图片

319
00:09:53,320 --> 00:09:55,040
那么我就是说

320
00:09:55,040 --> 00:09:56,080
我每次去里面

321
00:09:56,520 --> 00:09:57,680
找两个

322
00:09:58,040 --> 00:10:00,240
就是说腰带类别里面两个数据

323
00:10:00,760 --> 00:10:01,560
找两个最近

324
00:10:01,560 --> 00:10:02,720
找两个特别近的数据

325
00:10:02,720 --> 00:10:04,360
就随机选一个数据

326
00:10:04,720 --> 00:10:05,760
然后把它最近的

327
00:10:05,759 --> 00:10:07,639
在类别里面数据选出来

328
00:10:07,799 --> 00:10:08,840
这两个数据之间

329
00:10:09,319 --> 00:10:11,799
我认为说两个数据之间

330
00:10:12,000 --> 00:10:13,120
就做差值

331
00:10:13,200 --> 00:10:14,679
就这两个点之间

332
00:10:14,679 --> 00:10:16,080
那个线上面所有的点

333
00:10:16,080 --> 00:10:17,919
都可以作为我类别的数据

334
00:10:18,519 --> 00:10:19,080
所以就是说

335
00:10:19,080 --> 00:10:21,319
我就可以中间做出很多

336
00:10:21,319 --> 00:10:22,159
通过差值

337
00:10:22,159 --> 00:10:23,240
就通过两个加起来

338
00:10:23,240 --> 00:10:24,360
做很多数据出来

339
00:10:26,240 --> 00:10:27,799
虽然这个不一定是合法

340
00:10:28,879 --> 00:10:30,919
但是你可以认为

341
00:10:30,960 --> 00:10:32,960
有点点像我们说

342
00:10:33,200 --> 00:10:35,120
在做data augmentation是吧

343
00:10:35,279 --> 00:10:37,240
有比如说mixup

344
00:10:37,240 --> 00:10:40,879
其实虽然也是把两个图片加起来

345
00:10:40,879 --> 00:10:43,679
现在是说我尽量是在一个类别里面

346
00:10:43,679 --> 00:10:45,519
两个最近的图片做差值

347
00:10:46,360 --> 00:10:49,320
这样子得出一些新的样本出来

348
00:10:49,639 --> 00:10:50,240
有同学用了

349
00:10:51,399 --> 00:10:53,240
虽然我不是很清楚

350
00:10:53,240 --> 00:10:56,320
到底这个东西效果怎么样

351
00:10:56,480 --> 00:10:58,799
但是确实是在很多应用里面

352
00:10:58,799 --> 00:11:00,960
这个算法是用的比较多的

353
00:11:01,360 --> 00:11:02,279
用来给大家

354
00:11:02,279 --> 00:11:03,240
就是说在小类别

355
00:11:03,240 --> 00:11:04,799
生成很多新的样本出来

356
00:11:05,080 --> 00:11:06,400
你可以认为

357
00:11:06,400 --> 00:11:08,560
也是一种数据增强的一种做法

358
00:11:09,720 --> 00:11:10,400
OK

359
00:11:11,200 --> 00:11:12,200
这是第一个

360
00:11:12,200 --> 00:11:13,440
就是数据从采样

361
00:11:13,440 --> 00:11:14,640
就是说来处理

362
00:11:14,680 --> 00:11:16,480
有些类别特别小的时候

363
00:11:17,120 --> 00:11:18,280
第二个重要的东西

364
00:11:18,280 --> 00:11:19,880
就是说用的是什么模型

365
00:11:20,360 --> 00:11:22,280
模型这个东西也挺好玩的

366
00:11:22,600 --> 00:11:24,080
我发现就是说

367
00:11:24,120 --> 00:11:27,080
大家基本上是三类模型

368
00:11:27,840 --> 00:11:31,400
其中以EULA V5用的比较多

369
00:11:32,360 --> 00:11:35,720
另外是Detection2和FastRCN系列

370
00:11:35,759 --> 00:11:37,439
和EULA X系列用的

371
00:11:37,480 --> 00:11:41,000
也是差不多的多

372
00:11:42,319 --> 00:11:43,639
首先我们讲过

373
00:11:43,639 --> 00:11:45,199
我们FastRCN是讲过的

374
00:11:46,480 --> 00:11:48,600
Detection2我们也大概提过一次

375
00:11:48,600 --> 00:11:49,559
就是说Detection2

376
00:11:49,600 --> 00:11:52,480
它提供了RCN一系列的算法

377
00:11:52,639 --> 00:11:53,679
用FastRCN

378
00:11:53,679 --> 00:11:54,959
然后你到更复杂一点的

379
00:11:54,959 --> 00:11:56,199
比如Cascade RCN

380
00:11:57,079 --> 00:11:59,240
他们就是说还是一样的

381
00:11:59,279 --> 00:12:01,560
就是说它实现了FastRCN

382
00:12:01,600 --> 00:12:04,440
跟你的论文的差别还是挺大的

383
00:12:04,680 --> 00:12:07,680
它里面加了大量的新的技术进来

384
00:12:07,720 --> 00:12:08,720
使得它的精度

385
00:12:08,720 --> 00:12:11,120
确实是在不断的改进中

386
00:12:11,840 --> 00:12:14,200
所以用它确实是问题不大的

387
00:12:14,360 --> 00:12:16,799
当然是说大家对它的主要的看法

388
00:12:16,799 --> 00:12:18,519
是说这个算起来比较贵

389
00:12:18,720 --> 00:12:20,320
虽然效果还行

390
00:12:20,320 --> 00:12:21,399
但是算起来比较贵

391
00:12:21,399 --> 00:12:23,399
另外一个是我看到有同学说

392
00:12:23,399 --> 00:12:24,560
尝试用了它

393
00:12:25,120 --> 00:12:26,240
没搞清怎么用

394
00:12:26,399 --> 00:12:28,080
确实我们也提过一次

395
00:12:28,800 --> 00:12:30,120
Detection2这个东西

396
00:12:30,360 --> 00:12:31,840
确实给research用的

397
00:12:32,000 --> 00:12:32,800
给research

398
00:12:32,840 --> 00:12:35,240
而且是很懂这一块的人用的

399
00:12:35,280 --> 00:12:37,080
所以它整个是一个很大的

400
00:12:37,080 --> 00:12:38,320
一个configuration

401
00:12:38,480 --> 00:12:40,800
它可以配很多很多东西

402
00:12:40,960 --> 00:12:42,280
所有东西都让你可以配

403
00:12:42,400 --> 00:12:44,320
但是你如果不是很懂

404
00:12:44,320 --> 00:12:45,520
那些东西是干嘛的话

405
00:12:45,879 --> 00:12:47,240
你用起来会比较难用

406
00:12:48,120 --> 00:12:50,000
所以Detection2主要还是说

407
00:12:50,000 --> 00:12:52,440
你对这一块系列算法很熟

408
00:12:52,800 --> 00:12:54,120
你是用的比较多

409
00:12:55,120 --> 00:12:56,160
就ULOV系列

410
00:12:56,480 --> 00:12:57,199
就ULO系列

411
00:12:57,199 --> 00:12:58,319
当然是卖的是快

412
00:12:59,319 --> 00:13:02,719
所以在ULO我们讲了

413
00:13:02,719 --> 00:13:04,399
最原始的ULO是干嘛的

414
00:13:04,399 --> 00:13:06,600
主要是说从SSD到ULO

415
00:13:06,600 --> 00:13:07,719
大概是怎么样子

416
00:13:07,959 --> 00:13:09,159
就是ULO V1

417
00:13:09,480 --> 00:13:11,719
ULO后来作者做了一个VR

418
00:13:11,959 --> 00:13:13,399
VR的话加了一些东西

419
00:13:13,559 --> 00:13:15,039
就是说改进了一些小的

420
00:13:15,039 --> 00:13:16,439
主要是可以做一些小的

421
00:13:16,439 --> 00:13:18,719
那些东西改进的比较好

422
00:13:19,319 --> 00:13:20,319
因为ULO你知道

423
00:13:20,319 --> 00:13:21,159
就是说为了快

424
00:13:21,319 --> 00:13:24,319
它是把整个anchor box

425
00:13:24,320 --> 00:13:28,080
切的就是一个550还是770

426
00:13:28,080 --> 00:13:30,920
就是说一个很大的一个块

427
00:13:30,920 --> 00:13:32,920
所以导致对小的优化不好

428
00:13:32,920 --> 00:13:34,160
然后ULO V2

429
00:13:34,280 --> 00:13:35,120
它做了很多改进

430
00:13:35,160 --> 00:13:37,440
包括了说我要对那些anchor box

431
00:13:37,440 --> 00:13:38,120
做clustering

432
00:13:38,320 --> 00:13:38,800
看一看

433
00:13:38,800 --> 00:13:40,720
就真实的出现在什么地方

434
00:13:40,720 --> 00:13:42,879
然后我能够对此针对的

435
00:13:42,879 --> 00:13:45,560
去设计好我的那些anchor box的

436
00:13:45,560 --> 00:13:46,000
做法

437
00:13:46,879 --> 00:13:48,960
ULO V3它做了一些改进

438
00:13:49,200 --> 00:13:49,960
也很多改进

439
00:13:49,960 --> 00:13:52,280
ULO V3是我读过的

440
00:13:52,279 --> 00:13:54,439
最写的最糟糕的论文

441
00:13:54,600 --> 00:13:56,079
所以正好你可以去看一下

442
00:13:56,600 --> 00:14:00,240
这有点像自媒体界的blog

443
00:14:00,919 --> 00:14:01,759
就是说这个东西

444
00:14:01,759 --> 00:14:03,199
绝对不能称之为论文

445
00:14:03,399 --> 00:14:04,600
但是citation还挺高

446
00:14:04,600 --> 00:14:07,799
因为这个东西确实还挺好用的

447
00:14:07,919 --> 00:14:09,559
ULO V3加了很多细节

448
00:14:09,959 --> 00:14:11,399
而且很多细节调整

449
00:14:11,439 --> 00:14:13,279
以及说它加了一个up sampling

450
00:14:13,279 --> 00:14:16,000
就是说它能做多个尺度的

451
00:14:16,000 --> 00:14:16,879
有点像SSD

452
00:14:17,319 --> 00:14:21,799
做多个尺度的检测

453
00:14:23,199 --> 00:14:25,000
然后大家知道

454
00:14:25,000 --> 00:14:26,639
不知道大家看过八卦没有

455
00:14:26,720 --> 00:14:29,480
就是说ULO V3的作者

456
00:14:29,480 --> 00:14:30,799
是一个挺好玩的作者

457
00:14:30,919 --> 00:14:33,039
是UW当年的一个学生

458
00:14:33,879 --> 00:14:36,959
他反正也是特立独行

459
00:14:37,319 --> 00:14:38,600
天才一般都特立独行

460
00:14:40,240 --> 00:14:42,879
然后他写了V3之后

461
00:14:43,039 --> 00:14:44,039
他就说

462
00:14:44,199 --> 00:14:45,399
他就发了个推特说

463
00:14:45,399 --> 00:14:46,039
我不干了

464
00:14:46,039 --> 00:14:47,120
我退圈了

465
00:14:47,319 --> 00:14:49,159
我退圈了的意思是说

466
00:14:49,559 --> 00:14:50,839
他觉得说

467
00:14:50,840 --> 00:14:52,360
你们用我的ULO都是

468
00:14:52,360 --> 00:14:53,360
因为ULO很快

469
00:14:53,759 --> 00:14:57,480
所以ULO被大量的用在摄像头里面

470
00:14:57,480 --> 00:14:59,200
监控摄像头很喜欢用ULO

471
00:14:59,200 --> 00:15:00,440
因为这个系列比较快

472
00:15:00,800 --> 00:15:03,480
然后比如说你去看很多

473
00:15:03,480 --> 00:15:05,560
大家说用ULO跑

474
00:15:05,560 --> 00:15:07,480
在Raspberry Pi上面跑ULO

475
00:15:07,680 --> 00:15:08,800
没有人很少人看到

476
00:15:08,800 --> 00:15:11,399
在Raspberry Pi上跑FastACN

477
00:15:12,040 --> 00:15:13,200
所以导致说

478
00:15:13,240 --> 00:15:16,040
这一块被用在很多的摄像头里面

479
00:15:16,280 --> 00:15:18,080
物体检测整个算法

480
00:15:18,200 --> 00:15:20,240
在监控摄像头里面用的比较多的

481
00:15:20,360 --> 00:15:22,279
所以他觉得说你们这个东西用了

482
00:15:22,279 --> 00:15:24,159
你们这些人用了我东西给监控

483
00:15:24,360 --> 00:15:26,120
做什么军事用途

484
00:15:26,240 --> 00:15:27,360
他就不开心了

485
00:15:27,560 --> 00:15:32,600
他说我不想贡献我的成果

486
00:15:32,600 --> 00:15:33,560
给你们干这个事情

487
00:15:33,560 --> 00:15:34,879
所以他就说不干了

488
00:15:35,759 --> 00:15:36,080
好

489
00:15:36,080 --> 00:15:36,519
不干了

490
00:15:36,519 --> 00:15:38,440
就是说他就说我就退圈了

491
00:15:38,440 --> 00:15:39,120
不做CV了

492
00:15:39,120 --> 00:15:40,759
但其实现在我觉得他还是做

493
00:15:41,039 --> 00:15:42,159
就看到推特

494
00:15:42,720 --> 00:15:44,039
他还是转一转

495
00:15:44,039 --> 00:15:44,680
看一看

496
00:15:45,320 --> 00:15:46,879
所以他转完之后

497
00:15:46,879 --> 00:15:47,279
好了

498
00:15:47,279 --> 00:15:48,399
你说你不干了

499
00:15:48,399 --> 00:15:50,000
那剩下怎么办

500
00:15:50,960 --> 00:15:51,200
好

501
00:15:51,200 --> 00:15:54,039
这就是说引起了很多的confusion

502
00:15:54,360 --> 00:15:56,080
就是说EULA V4 V5

503
00:15:56,639 --> 00:15:59,200
两个东西它不是原作的

504
00:16:00,240 --> 00:16:01,519
因为你原作不干了

505
00:16:01,519 --> 00:16:02,759
所以后面的人都说

506
00:16:03,279 --> 00:16:04,159
那我来接着弄

507
00:16:04,519 --> 00:16:06,200
所以EULA这个名字

508
00:16:06,360 --> 00:16:07,519
就是说理论上来说

509
00:16:07,519 --> 00:16:08,240
虽然EULA这个

510
00:16:08,240 --> 00:16:10,720
就是说它其实在英语是一个很

511
00:16:11,159 --> 00:16:11,919
用的很多了

512
00:16:11,919 --> 00:16:12,519
就是说

513
00:16:13,440 --> 00:16:14,879
You only live once

514
00:16:14,879 --> 00:16:16,560
就是说让你说你就活一次

515
00:16:16,560 --> 00:16:18,000
所以你就应该开心一点

516
00:16:19,000 --> 00:16:20,240
然后

517
00:16:21,240 --> 00:16:22,840
所以但是他用了这个名字

518
00:16:22,840 --> 00:16:23,720
他当然是说

519
00:16:23,720 --> 00:16:25,240
你You only look once

520
00:16:25,240 --> 00:16:25,519
对吧

521
00:16:25,519 --> 00:16:27,240
他还是他取的这个名字

522
00:16:27,240 --> 00:16:29,639
所以EULA用于目标检测

523
00:16:29,639 --> 00:16:31,120
这个名字是他取的

524
00:16:32,519 --> 00:16:33,720
原作的取的

525
00:16:33,879 --> 00:16:35,360
所以他不干了之后

526
00:16:35,879 --> 00:16:37,759
大家就说别人都跑出来说

527
00:16:37,919 --> 00:16:39,519
我也是EULA的后续

528
00:16:39,720 --> 00:16:41,200
包括EULA X我觉得还行

529
00:16:41,360 --> 00:16:42,840
就是EULA V4 V5

530
00:16:42,840 --> 00:16:44,159
这个东西就很奇怪了

531
00:16:44,320 --> 00:16:46,799
它两个都是社区的改进版

532
00:16:48,000 --> 00:16:49,720
EULA V4是

533
00:16:50,080 --> 00:16:51,639
首先我们回到EULA这个东西

534
00:16:51,840 --> 00:16:53,120
他作者也挺好玩

535
00:16:53,120 --> 00:16:54,759
他实现了一个自己的框架

536
00:16:54,759 --> 00:16:55,639
叫DocuNet

537
00:16:55,720 --> 00:16:57,000
他是用C++写的

538
00:16:57,240 --> 00:16:58,799
他网络也叫DocuNet

539
00:16:58,799 --> 00:17:00,279
他框架也叫DocuNet

540
00:17:00,279 --> 00:17:02,279
反正就是说他用C++写的

541
00:17:02,279 --> 00:17:04,160
就是说反正他说我什么都能写

542
00:17:04,160 --> 00:17:05,839
我自己写的快

543
00:17:06,359 --> 00:17:07,279
这也是对的

544
00:17:07,960 --> 00:17:09,960
他就是比较纯粹的做CV的

545
00:17:09,960 --> 00:17:11,640
当年都是用C++来写

546
00:17:12,039 --> 00:17:16,519
所以然后他自己不干了之后

547
00:17:16,559 --> 00:17:19,160
EULA V4的作者

548
00:17:19,599 --> 00:17:21,200
他就把这个fork了

549
00:17:21,240 --> 00:17:22,799
然后就一直在维护它

550
00:17:23,119 --> 00:17:24,160
就是说维护它

551
00:17:24,160 --> 00:17:26,720
维护了一阵子之后

552
00:17:27,200 --> 00:17:28,440
他就说你这样不做

553
00:17:28,599 --> 00:17:29,480
我来接着做

554
00:17:30,160 --> 00:17:32,599
我就说他又提出了一点改进

555
00:17:34,240 --> 00:17:35,519
他做了一些改进之后

556
00:17:37,240 --> 00:17:38,799
其实我都忘了做什么改进了

557
00:17:38,799 --> 00:17:40,319
反正这些算法之间

558
00:17:41,200 --> 00:17:42,759
反正改进也是挺多的

559
00:17:42,759 --> 00:17:44,440
反正做了还做了一堆改进

560
00:17:44,480 --> 00:17:45,079
看上去

561
00:17:45,679 --> 00:17:47,119
然后做了一堆改进之后

562
00:17:47,119 --> 00:17:49,240
他就把这个东西命名为EULA V4

563
00:17:50,119 --> 00:17:50,319
好

564
00:17:50,319 --> 00:17:51,799
EULA V4这个东西就很尴尬了

565
00:17:51,799 --> 00:17:53,759
就是说他跟他的EULA V4

566
00:17:53,759 --> 00:17:55,039
有三个作者论文

567
00:17:55,039 --> 00:17:56,639
他跟原作的两个作者

568
00:17:56,639 --> 00:17:58,839
就学生和老师是没有任何关系的

569
00:17:58,960 --> 00:18:03,799
更多是说他是之前是维护过原作

570
00:18:03,799 --> 00:18:05,399
开发的DocNet的版本

571
00:18:05,720 --> 00:18:07,199
他后来自己fork了一个版本

572
00:18:07,199 --> 00:18:08,519
然后继续往下开发

573
00:18:08,559 --> 00:18:10,599
然后把自己的东西叫做EULA V4

574
00:18:11,480 --> 00:18:12,639
因为你叫EULA V4

575
00:18:12,639 --> 00:18:13,679
就是说大家一看名字

576
00:18:13,720 --> 00:18:15,680
以为就会有一点confuse

577
00:18:15,680 --> 00:18:17,880
说觉得你应该是原作系列

578
00:18:17,880 --> 00:18:18,279
对吧

579
00:18:18,840 --> 00:18:21,799
应该是质量可以保证的

580
00:18:21,960 --> 00:18:24,600
但是因为原作不干了

581
00:18:24,600 --> 00:18:26,880
所以他就用了V4这个名字

582
00:18:26,960 --> 00:18:29,279
所以大家会有很多争议

583
00:18:29,480 --> 00:18:31,600
就是觉得你不应该这么干这个事情

584
00:18:31,600 --> 00:18:33,080
就是说你有点像

585
00:18:34,240 --> 00:18:36,400
为了抢ID上头条

586
00:18:36,400 --> 00:18:36,840
对吧

587
00:18:37,440 --> 00:18:39,480
然后作者就跳出来说

588
00:18:39,799 --> 00:18:40,880
其实你反正用了

589
00:18:40,960 --> 00:18:42,920
我就是说作者反正说

590
00:18:43,080 --> 00:18:44,039
你反正我也不干了

591
00:18:44,039 --> 00:18:45,160
这个事情你们想怎么办

592
00:18:45,160 --> 00:18:45,360
怎么办

593
00:18:45,519 --> 00:18:46,600
就是说你们用就用了

594
00:18:46,759 --> 00:18:47,840
反正说看上去

595
00:18:47,840 --> 00:18:49,480
你的版本是确实维护的

596
00:18:49,480 --> 00:18:50,519
确实是在维护

597
00:18:50,519 --> 00:18:53,200
然后比我的不维护的版本当然好

598
00:18:53,200 --> 00:18:53,960
就是说你就用它

599
00:18:54,360 --> 00:18:57,360
所以大家就觉得既然是原作都答应了

600
00:18:57,360 --> 00:18:58,560
其实原作也没有说答应

601
00:18:58,640 --> 00:18:59,720
原作反正挺无赖的

602
00:18:59,720 --> 00:19:00,360
反正我也不干了

603
00:19:00,360 --> 00:19:01,560
所以你们想怎么办

604
00:19:02,480 --> 00:19:03,640
所以他就用了这个名字

605
00:19:05,200 --> 00:19:05,480
好

606
00:19:05,480 --> 00:19:09,759
EULA V5又是另外几个小哥做的

607
00:19:10,320 --> 00:19:12,000
EULA V5又是个很好玩的东西

608
00:19:12,039 --> 00:19:14,359
EULA V5是一个startup

609
00:19:15,240 --> 00:19:17,920
这几个人他最早是把EULA V3

610
00:19:18,119 --> 00:19:21,359
把Darknet那个东西搬到了PyTorch上面

611
00:19:22,799 --> 00:19:24,200
搬到PyTorch上面

612
00:19:24,200 --> 00:19:26,240
就是当时他是用

613
00:19:27,359 --> 00:19:28,960
EULA是用Darknet的CSS的

614
00:19:29,119 --> 00:19:30,519
所以他搬到PyTorch上面

615
00:19:30,519 --> 00:19:32,839
就是说对PyTorch用户会友好一点

616
00:19:33,759 --> 00:19:35,440
然后他又做了一些改进之后

617
00:19:37,240 --> 00:19:39,839
他就直接把它命名成EULA V5

618
00:19:39,839 --> 00:19:41,599
而V5是没有论文的

619
00:19:42,000 --> 00:19:43,440
所以理论上说你没有论文

620
00:19:43,440 --> 00:19:45,680
你真的就是一个软件了

621
00:19:45,920 --> 00:19:47,640
他就把自己东西叫做EULA V5

622
00:19:48,480 --> 00:19:52,680
然后看上去似乎是EULA V4的

623
00:19:52,680 --> 00:19:53,480
改进版是吧

624
00:19:53,480 --> 00:19:55,279
其实我觉得是一个平信版本

625
00:19:56,160 --> 00:20:00,839
所以大家又开始讨论这个事情了

626
00:20:00,839 --> 00:20:02,680
就是你为什么能叫EULA V5是吧

627
00:20:03,720 --> 00:20:05,160
然后大家好像吵了好久

628
00:20:05,160 --> 00:20:06,279
也没什么结果

629
00:20:06,319 --> 00:20:08,359
但我看到大家这一次竞赛

630
00:20:08,359 --> 00:20:09,559
很多人用EULA V5

631
00:20:09,559 --> 00:20:11,160
我觉得可能有两个原因

632
00:20:11,160 --> 00:20:12,080
一个是说

633
00:20:13,120 --> 00:20:15,160
毕竟觉得5比4比3要好

634
00:20:15,160 --> 00:20:15,440
对吧

635
00:20:15,440 --> 00:20:17,080
这个可能是个心理作用

636
00:20:17,080 --> 00:20:17,960
实际上好多话

637
00:20:17,960 --> 00:20:18,800
我还真不知道

638
00:20:19,120 --> 00:20:20,120
我看过那种评测

639
00:20:20,120 --> 00:20:22,080
但是你不要太相信评测这个东西

640
00:20:22,400 --> 00:20:24,400
所有的评测都是有偏的

641
00:20:24,519 --> 00:20:26,240
网上所有的评测都是有偏的

642
00:20:26,279 --> 00:20:27,400
不管是论文的评测

643
00:20:27,400 --> 00:20:27,560
好

644
00:20:27,680 --> 00:20:28,880
也是谁评测好

645
00:20:28,880 --> 00:20:31,400
都是有很难做到无偏

646
00:20:32,000 --> 00:20:33,160
即使下意识没有

647
00:20:33,160 --> 00:20:34,400
但是很容易就是说

648
00:20:34,400 --> 00:20:36,759
你评测自己的东西很熟

649
00:20:36,759 --> 00:20:37,480
评测别的东西

650
00:20:37,480 --> 00:20:38,600
你可能没有设对

651
00:20:38,640 --> 00:20:40,640
所以导致说别人可能会差一点点

652
00:20:40,840 --> 00:20:43,520
所以我不确信到底谁好

653
00:20:44,080 --> 00:20:45,080
第二个是说

654
00:20:47,160 --> 00:20:48,759
我觉得因为是用了Pytorch

655
00:20:48,759 --> 00:20:49,400
所以相对来说

656
00:20:49,400 --> 00:20:50,400
用起来比较简单一点

657
00:20:50,560 --> 00:20:51,400
这是我的感觉

658
00:20:51,400 --> 00:20:52,080
所以我就说

659
00:20:52,080 --> 00:20:55,560
为什么大家在用EULA V5

660
00:20:55,560 --> 00:20:56,600
是用的比较多的

661
00:20:56,600 --> 00:20:57,640
这是我的看法

662
00:20:57,640 --> 00:20:59,200
当然是说大家有不同的见解

663
00:20:59,200 --> 00:21:00,600
可以在评论里面

664
00:21:00,640 --> 00:21:01,600
跟我们分享

665
00:21:02,920 --> 00:21:04,280
另外一个是EULA X

666
00:21:04,280 --> 00:21:07,880
EULA X还是震惊的

667
00:21:07,880 --> 00:21:10,160
我们国内公司的论文

668
00:21:10,519 --> 00:21:12,480
它是在EULA V3上的一个改进版本

669
00:21:12,480 --> 00:21:14,200
它加了anchor free

670
00:21:14,560 --> 00:21:16,240
我们有很简单讲过

671
00:21:16,240 --> 00:21:18,360
anchor free的版本

672
00:21:18,360 --> 00:21:21,240
就是有点点像用了FCN

673
00:21:21,240 --> 00:21:24,200
就是说整个对每个点像素点做预测

674
00:21:24,440 --> 00:21:25,640
就不用处理那么多

675
00:21:25,640 --> 00:21:27,040
anchor相关的东西了

676
00:21:27,360 --> 00:21:28,560
整体算下来

677
00:21:28,560 --> 00:21:30,560
就是说整个流程会简单一点

678
00:21:30,600 --> 00:21:32,720
然后从论文角度来看

679
00:21:32,720 --> 00:21:33,640
效果也不错

680
00:21:34,080 --> 00:21:36,200
然后大家也是看上去

681
00:21:36,600 --> 00:21:37,680
整个维护的还不错

682
00:21:37,880 --> 00:21:41,440
大家也在有两三名同学用了它

683
00:21:42,440 --> 00:21:43,160
所以就是说

684
00:21:43,160 --> 00:21:46,680
这是整个三个的框架

685
00:21:46,799 --> 00:21:47,799
就是说你问我说

686
00:21:47,799 --> 00:21:48,920
到底用谁好

687
00:21:49,560 --> 00:21:52,400
我觉得这个东西很难说

688
00:21:52,400 --> 00:21:53,640
谁一定比谁好

689
00:21:53,680 --> 00:21:54,160
为什么

690
00:21:54,160 --> 00:21:56,080
是因为整个目标检测

691
00:21:56,160 --> 00:21:57,960
整个那一块是比较复杂的

692
00:21:57,960 --> 00:21:59,960
每个人的实现细节的不一样

693
00:21:59,960 --> 00:22:01,960
所以说你真的说要去评测

694
00:22:01,960 --> 00:22:03,360
谁比谁好就很难

695
00:22:03,400 --> 00:22:04,200
很多时候就是说

696
00:22:04,200 --> 00:22:05,000
你有些细节

697
00:22:05,000 --> 00:22:06,360
你加没加的问题

698
00:22:06,640 --> 00:22:07,640
另外一块就是说

699
00:22:07,640 --> 00:22:10,600
我觉得在很多程度上来看

700
00:22:10,600 --> 00:22:12,040
因为它是一个很复杂的系统

701
00:22:12,320 --> 00:22:15,080
你很难把一个东西调的特别好

702
00:22:15,120 --> 00:22:16,600
我建议大家是说

703
00:22:16,600 --> 00:22:17,360
你挑一个

704
00:22:17,360 --> 00:22:19,000
你觉得用的还顺手的

705
00:22:19,000 --> 00:22:20,720
你还用起来比较简单

706
00:22:20,720 --> 00:22:22,560
你觉得还能用的就行了

707
00:22:22,600 --> 00:22:26,200
而且这些版本差别可能没那么大

708
00:22:26,360 --> 00:22:27,480
就技术上来说

709
00:22:27,480 --> 00:22:29,040
大家可能做都好的

710
00:22:29,080 --> 00:22:31,800
所以就不用一定去追求谁比谁好

711
00:22:32,720 --> 00:22:33,680
另外一个是说

712
00:22:33,960 --> 00:22:34,840
当然大家都用了

713
00:22:34,840 --> 00:22:35,680
因为刷分

714
00:22:35,840 --> 00:22:37,720
大家都用了多模型

715
00:22:37,720 --> 00:22:39,320
就是你一个框架里

716
00:22:39,320 --> 00:22:41,080
就是你用了某一个库

717
00:22:41,279 --> 00:22:42,759
库里面通常有很多个

718
00:22:42,759 --> 00:22:44,920
什么Large Medium

719
00:22:45,080 --> 00:22:46,160
就大的小的

720
00:22:46,840 --> 00:22:50,080
什么在不同的pre-trained训练过的版本

721
00:22:50,080 --> 00:22:52,640
所以你可以反正training个版本

722
00:22:52,680 --> 00:22:54,039
然后去做融合

723
00:22:54,320 --> 00:22:55,440
另外一块就是说

724
00:22:55,960 --> 00:22:56,920
大家也用的多了

725
00:22:56,920 --> 00:22:59,799
就是说如果我做了K则交叉验证的话

726
00:22:59,799 --> 00:23:00,680
做5则的话

727
00:23:00,880 --> 00:23:01,759
我会训练5个模型

728
00:23:01,759 --> 00:23:02,160
对吧

729
00:23:02,200 --> 00:23:03,600
那么就是把这5个模型

730
00:23:03,600 --> 00:23:04,840
最后的结果做injump

731
00:23:04,839 --> 00:23:05,959
得到最终的模型

732
00:23:06,279 --> 00:23:07,199
多模型的融合

733
00:23:07,199 --> 00:23:09,480
通常会给你带来它的提升

734
00:23:10,240 --> 00:23:10,519
OK

735
00:23:10,519 --> 00:23:11,879
这就是模型的部分

736
00:23:14,279 --> 00:23:16,159
然后总结一下

737
00:23:16,159 --> 00:23:18,240
就是说目标检测代码

738
00:23:18,519 --> 00:23:20,240
实现还是挺复杂的

739
00:23:20,359 --> 00:23:21,599
训练代价比较大

740
00:23:21,639 --> 00:23:24,039
上手不那么容易

741
00:23:24,039 --> 00:23:25,759
所以我的建议还是说

742
00:23:25,759 --> 00:23:27,199
你不一定要追求谁

743
00:23:27,199 --> 00:23:29,439
说谁是最好的目标检测框架

744
00:23:29,679 --> 00:23:31,279
没有很难说

745
00:23:31,599 --> 00:23:33,559
我觉得你可能找一个

746
00:23:33,839 --> 00:23:35,919
比较容易上手的库为主

747
00:23:35,919 --> 00:23:38,720
然后你就是慢慢的去熟悉这个库

748
00:23:38,720 --> 00:23:39,879
因为它的超参数

749
00:23:40,159 --> 00:23:42,519
再简单的库超参数也是挺多的

750
00:23:42,919 --> 00:23:44,559
一般需要比较长的时间

751
00:23:44,559 --> 00:23:45,200
去熟悉它

752
00:23:45,200 --> 00:23:46,079
去探索它

753
00:23:46,079 --> 00:23:48,279
然后知道这些超参数在干什么

754
00:23:48,319 --> 00:23:49,399
然后可能就

755
00:23:50,559 --> 00:23:52,240
你可能就花一两年的时间

756
00:23:52,919 --> 00:23:53,240
OK

757
00:23:53,240 --> 00:23:56,639
这就是我们这一次的总结

