1
00:00:00,000 --> 00:00:04,580
接下来讲我们今天的第二个网络

2
00:00:04,600 --> 00:00:05,879
叫做GoogleNet

3
00:00:06,480 --> 00:00:08,560
虽然NNN几乎上没有

4
00:00:08,560 --> 00:00:09,720
现在没有被使用

5
00:00:09,720 --> 00:00:12,720
但是GoogleNet还是在大量的被使用

6
00:00:12,720 --> 00:00:14,919
在比如说Google内部当然是用的挺多的

7
00:00:14,919 --> 00:00:17,600
在外面也是被经常使用

8
00:00:17,920 --> 00:00:21,039
这个网络当时候出来的时候也是吓了大家一跳

9
00:00:21,039 --> 00:00:22,440
你看横着图

10
00:00:22,679 --> 00:00:24,240
横着图应该是竖过来

11
00:00:24,240 --> 00:00:27,359
就是说它是第一次

12
00:00:27,359 --> 00:00:31,519
大家说我可以做一个几乎快到100层的卷积层

13
00:00:31,519 --> 00:00:35,320
几乎是你可以认为是第一个卷积神级网络

14
00:00:35,600 --> 00:00:38,719
可以做到超过100层

15
00:00:39,280 --> 00:00:43,119
虽然它不是直接有100层深

16
00:00:43,119 --> 00:00:45,960
但它确实里面的卷积层的个数是超过了100

17
00:00:47,200 --> 00:00:48,799
而且你看它的名字

18
00:00:48,799 --> 00:00:51,320
它的名字是L是大写的

19
00:00:51,320 --> 00:00:53,519
所以它是致敬Learnnet

20
00:00:53,920 --> 00:00:55,920
所以它跟Learnnet什么关系都没有

21
00:00:56,039 --> 00:00:57,960
但是它是为了取了个名字

22
00:00:57,960 --> 00:01:00,600
所以它是Google一帮人做的

23
00:01:00,600 --> 00:01:03,359
然后在Imagine.net上拿了挺好的成绩

24
00:01:03,359 --> 00:01:04,120
应该是拿了冠军

25
00:01:04,560 --> 00:01:07,519
然后他为了把自己的公司的名字放在那里

26
00:01:07,519 --> 00:01:09,200
然后再还能玩一个梗

27
00:01:09,200 --> 00:01:10,840
就是说能致敬一下Learnnet

28
00:01:11,640 --> 00:01:13,280
所以我们接下来讲这一个网络

29
00:01:15,079 --> 00:01:18,120
就是说我们之前为什么要讲NIN

30
00:01:18,120 --> 00:01:21,439
是因为NIN它严重的影响网络的设计

31
00:01:21,679 --> 00:01:25,159
我们所以讲完NIN之后

32
00:01:25,159 --> 00:01:27,439
再来理解GoogleNet会方便一些

33
00:01:27,439 --> 00:01:30,000
就是说这是我们讲NIN的主要的一个目的

34
00:01:31,799 --> 00:01:34,599
好 我们来看一下它的Motivation是什么样子

35
00:01:36,200 --> 00:01:39,120
所以我们之前有大家很多问过

36
00:01:39,120 --> 00:01:41,200
说你这个卷积为什么这么选

37
00:01:41,599 --> 00:01:44,439
为什么要5000523337x7

38
00:01:44,439 --> 00:01:46,239
然后你的通道数怎么选

39
00:01:46,840 --> 00:01:49,479
就你可以认为说Learnnet是怎么样子

40
00:01:49,479 --> 00:01:50,879
AlexNet是把它变宽

41
00:01:50,879 --> 00:01:52,159
再多加了一点

42
00:01:52,159 --> 00:01:55,719
VGG说我几乎用33

43
00:01:55,719 --> 00:01:59,119
而NIN其实还是用的是AlexNet那一套

44
00:01:59,119 --> 00:02:00,679
但是加入了一层一的卷积

45
00:02:01,759 --> 00:02:03,399
就当然你会去想说

46
00:02:03,399 --> 00:02:05,799
到底是什么样的东西比较好

47
00:02:05,799 --> 00:02:08,519
比如说你是用一层一的卷积

48
00:02:08,519 --> 00:02:09,359
33的卷积

49
00:02:09,359 --> 00:02:10,079
55的卷积

50
00:02:10,079 --> 00:02:11,000
或者7x7

51
00:02:11,000 --> 00:02:13,560
你是用max pooling也好

52
00:02:13,560 --> 00:02:15,000
还是用average pooling也好

53
00:02:15,000 --> 00:02:18,079
还是要不要什么时候要放max pooling

54
00:02:19,080 --> 00:02:22,680
或者说你是不是还要多个一层一的卷积

55
00:02:23,160 --> 00:02:25,200
就是说你有这么多的选择

56
00:02:25,200 --> 00:02:26,560
你到底用谁比较好

57
00:02:26,560 --> 00:02:31,120
就是说GoogleNet里面最重要的叫做

58
00:02:31,120 --> 00:02:32,400
Inception快

59
00:02:33,200 --> 00:02:35,160
Inception快的意思是说

60
00:02:35,160 --> 00:02:36,880
我不给你做选择

61
00:02:37,160 --> 00:02:38,200
我全部要

62
00:02:38,680 --> 00:02:41,840
就我在快里面抽取的有不同的通道

63
00:02:41,840 --> 00:02:43,520
然后不同通道有不同的设计

64
00:02:43,520 --> 00:02:44,920
把我想要的那些

65
00:02:44,920 --> 00:02:47,120
试的那些东西都放在里面

66
00:02:48,039 --> 00:02:51,159
这就是Inception快的一个想法

67
00:02:51,520 --> 00:02:55,120
就是说Inception就是来自于的电影

68
00:02:55,120 --> 00:02:55,920
就是

69
00:02:56,360 --> 00:02:56,960
我没

70
00:02:56,960 --> 00:02:57,759
我叫

71
00:02:57,759 --> 00:02:58,800
中文名叫什么来着

72
00:02:58,800 --> 00:03:00,159
Inception那个电影

73
00:03:00,159 --> 00:03:01,879
就是说你做梦的时候

74
00:03:01,879 --> 00:03:03,080
里面还可以嵌淘梦

75
00:03:03,280 --> 00:03:04,960
就是一个嵌淘的关系

76
00:03:05,200 --> 00:03:07,879
大家在深度学习

77
00:03:07,879 --> 00:03:09,240
大家特别喜欢取名字

78
00:03:09,240 --> 00:03:11,159
取的越fancy越好

79
00:03:11,159 --> 00:03:11,439
对吧

80
00:03:11,439 --> 00:03:13,000
Bert这个名字对吧

81
00:03:13,759 --> 00:03:14,240
OK

82
00:03:14,240 --> 00:03:15,360
所以我们来看一下

83
00:03:15,680 --> 00:03:17,520
Inception快在干什么事情

84
00:03:20,040 --> 00:03:21,720
就是说首先

85
00:03:24,600 --> 00:03:26,360
输入在这个地方

86
00:03:27,880 --> 00:03:29,080
这是输入

87
00:03:29,800 --> 00:03:31,480
然后你的输出在这个地方

88
00:03:31,480 --> 00:03:33,040
输出我们等会叫输出出去了

89
00:03:33,040 --> 00:03:33,880
我们再仔细看

90
00:03:33,880 --> 00:03:35,560
就输入这个地方

91
00:03:35,560 --> 00:03:37,360
你看到是说它被

92
00:03:37,960 --> 00:03:39,680
copy成了4块

93
00:03:39,680 --> 00:03:41,320
就这个输入在之前

94
00:03:41,320 --> 00:03:42,560
我们就是一条路就下去了

95
00:03:42,560 --> 00:03:43,000
对吧

96
00:03:43,000 --> 00:03:44,200
在这个地方不一样

97
00:03:44,240 --> 00:03:45,240
它有4条路

98
00:03:45,960 --> 00:03:46,960
就第一条路

99
00:03:46,960 --> 00:03:49,400
就是说输入先接到一个

100
00:03:49,400 --> 00:03:50,960
1×1的卷积层

101
00:03:50,960 --> 00:03:52,080
一个卷积层里面

102
00:03:52,840 --> 00:03:54,240
那把输出到这个地方

103
00:03:56,080 --> 00:03:58,120
然后第二条路

104
00:03:58,960 --> 00:04:01,400
先通过一个1×1的卷积层

105
00:04:01,400 --> 00:04:02,840
对通道做变换

106
00:04:03,920 --> 00:04:05,400
再加入到

107
00:04:05,400 --> 00:04:06,320
再输入到一个

108
00:04:06,320 --> 00:04:07,800
3×3的卷积层里面

109
00:04:07,800 --> 00:04:08,560
派的等于

110
00:04:08,560 --> 00:04:11,000
使得你的输入和输出的高款

111
00:04:11,000 --> 00:04:11,680
是一样的

112
00:04:12,240 --> 00:04:13,440
然后这是第二条路

113
00:04:14,439 --> 00:04:16,399
第三条路就是说输入

114
00:04:16,399 --> 00:04:17,920
又是一个1×1的卷积层

115
00:04:17,920 --> 00:04:20,040
来对通道数做变换

116
00:04:20,040 --> 00:04:21,439
不改变高宽

117
00:04:21,480 --> 00:04:22,600
但是就是说

118
00:04:22,600 --> 00:04:24,480
通过一个5×5的卷积层

119
00:04:24,480 --> 00:04:25,759
来做一些空间信息

120
00:04:25,759 --> 00:04:26,600
派的等于2

121
00:04:26,600 --> 00:04:27,959
输入和输出等宽

122
00:04:29,040 --> 00:04:30,399
还有第4条pass

123
00:04:30,399 --> 00:04:31,519
第4条pass用了一个

124
00:04:31,519 --> 00:04:33,079
3×3的max pooling

125
00:04:33,399 --> 00:04:34,279
派的等于

126
00:04:34,439 --> 00:04:36,879
然后再在后面加一个

127
00:04:36,879 --> 00:04:38,199
1×1的卷积层

128
00:04:40,040 --> 00:04:43,040
所以而且所有这4条路的

129
00:04:43,960 --> 00:04:44,720
输出

130
00:04:44,920 --> 00:04:45,319
就是说

131
00:04:45,319 --> 00:04:46,360
因为他可以看到

132
00:04:46,360 --> 00:04:47,960
他都没有改变高宽

133
00:04:48,240 --> 00:04:50,000
然后他做一个空开的操作

134
00:04:50,000 --> 00:04:51,120
就把合并起来

135
00:04:51,560 --> 00:04:52,160
怎么合并

136
00:04:52,960 --> 00:04:55,640
在你的输出的通道数上做合并

137
00:04:56,400 --> 00:04:58,800
他不是把你的图片放一起

138
00:04:58,920 --> 00:05:00,400
不是放一个更大图片

139
00:05:00,439 --> 00:05:01,520
他不就是说

140
00:05:01,520 --> 00:05:04,879
输出是不会改变你的高宽

141
00:05:04,879 --> 00:05:05,520
就是说

142
00:05:05,560 --> 00:05:06,120
你可以发现

143
00:05:06,120 --> 00:05:08,800
输出的高宽和输入的高款是一样的

144
00:05:08,920 --> 00:05:10,280
但是说输出的高宽

145
00:05:10,280 --> 00:05:11,560
他就会非常的

146
00:05:11,560 --> 00:05:13,079
通道数可能会非常多

147
00:05:13,079 --> 00:05:14,639
是4个通道

148
00:05:14,639 --> 00:05:16,199
跟一个通道数并在一起的

149
00:05:16,959 --> 00:05:17,560
OK

150
00:05:18,240 --> 00:05:19,240
所以这个就是

151
00:05:19,280 --> 00:05:21,839
inception的一个核心的定义

152
00:05:22,360 --> 00:05:23,199
当我们来看一下

153
00:05:23,199 --> 00:05:23,840
就是说

154
00:05:23,840 --> 00:05:25,120
到底他的

155
00:05:25,360 --> 00:05:26,199
就是说

156
00:05:26,280 --> 00:05:27,280
你可以基本可以看到

157
00:05:27,280 --> 00:05:27,600
就是说

158
00:05:27,600 --> 00:05:28,959
你的高宽不变

159
00:05:29,120 --> 00:05:30,079
你变的是什么

160
00:05:30,360 --> 00:05:31,800
变的是你的通道数

161
00:05:32,800 --> 00:05:33,800
当你反过来看

162
00:05:33,800 --> 00:05:34,399
你再看一下

163
00:05:34,399 --> 00:05:36,560
就是说这里面有1×1的卷积

164
00:05:36,840 --> 00:05:37,840
3×3的卷积

165
00:05:37,840 --> 00:05:38,920
5×5的卷积

166
00:05:38,959 --> 00:05:40,600
然后3×3的max pooling

167
00:05:40,720 --> 00:05:42,600
还有一堆1×1的卷积

168
00:05:42,640 --> 00:05:43,480
所以基本上1×1

169
00:05:43,480 --> 00:05:43,920
3×5

170
00:05:43,920 --> 00:05:45,120
max pooling都有了

171
00:05:45,120 --> 00:05:45,520
对吧

172
00:05:45,720 --> 00:05:47,320
所以你就不用特别去想说

173
00:05:47,320 --> 00:05:48,640
到底用谁好一点

174
00:05:48,640 --> 00:05:49,480
用谁坏一点

175
00:05:51,120 --> 00:05:52,160
那接下来我们来看一下

176
00:05:52,160 --> 00:05:52,920
就是说

177
00:05:53,200 --> 00:05:54,760
我们的通道数

178
00:05:56,480 --> 00:05:57,920
所以假设我的通道

179
00:05:57,920 --> 00:05:59,840
我假设我的输入是一个

180
00:05:59,879 --> 00:06:01,879
输入通道是192

181
00:06:02,360 --> 00:06:05,080
我的高宽是28×28的话

182
00:06:05,080 --> 00:06:06,160
反正高宽我们不用管

183
00:06:06,160 --> 00:06:06,879
反正不会变

184
00:06:06,879 --> 00:06:07,280
对吧

185
00:06:07,680 --> 00:06:09,400
那我们看一下通道数怎么变

186
00:06:10,680 --> 00:06:12,040
首先第一条路

187
00:06:12,160 --> 00:06:13,560
1×1的卷积参数

188
00:06:13,680 --> 00:06:16,360
直接把通道数压到了64

189
00:06:17,080 --> 00:06:17,879
压到这个地方

190
00:06:19,080 --> 00:06:19,879
那么接下来

191
00:06:20,600 --> 00:06:21,400
接下来是说

192
00:06:21,400 --> 00:06:25,200
我把通道数从192压到了96

193
00:06:26,840 --> 00:06:27,920
为什么压到96

194
00:06:27,920 --> 00:06:28,520
是因为

195
00:06:29,200 --> 00:06:32,080
我想把后面3300的卷积的

196
00:06:32,080 --> 00:06:33,240
输入数降低

197
00:06:33,240 --> 00:06:34,560
就降低通道数

198
00:06:34,560 --> 00:06:36,200
来降低你的模型复杂度

199
00:06:36,400 --> 00:06:37,640
因为所谓的模型复杂度

200
00:06:37,640 --> 00:06:38,600
基本上你可以认为是

201
00:06:38,600 --> 00:06:41,680
你的模型科学系的参数的个数

202
00:06:42,600 --> 00:06:44,800
我们知道卷积层的科学系的参数

203
00:06:44,800 --> 00:06:47,800
个数是输入通道乘以输出通道

204
00:06:47,800 --> 00:06:50,920
再乘以你的科农的大小

205
00:06:50,920 --> 00:06:51,840
科农是33

206
00:06:51,840 --> 00:06:52,320
定了

207
00:06:52,560 --> 00:06:54,480
所以这个地方就是说

208
00:06:54,480 --> 00:06:55,280
我的192

209
00:06:55,280 --> 00:06:56,480
我觉得太大了

210
00:06:56,480 --> 00:06:58,520
我就把你降到96

211
00:06:59,120 --> 00:07:00,600
然后再增加一点

212
00:07:00,600 --> 00:07:01,800
增加到128

213
00:07:03,160 --> 00:07:04,000
这个地方更加

214
00:07:04,000 --> 00:07:05,280
因为它是5×5的卷积

215
00:07:05,400 --> 00:07:06,160
因为它更贵

216
00:07:06,600 --> 00:07:07,600
所以我降了更多

217
00:07:07,600 --> 00:07:09,520
降到了192

218
00:07:09,520 --> 00:07:10,600
降到了16

219
00:07:11,160 --> 00:07:13,000
然后再5×5

220
00:07:13,000 --> 00:07:14,640
其实是通道数分配的不多

221
00:07:15,320 --> 00:07:15,960
32

222
00:07:16,400 --> 00:07:18,560
然后Max pooling不会改变通道数

223
00:07:18,560 --> 00:07:20,879
然后1×1的直接降到了32

224
00:07:21,879 --> 00:07:23,400
这你可以看到是说

225
00:07:23,600 --> 00:07:27,080
我们标成白色的1×1的卷积

226
00:07:27,160 --> 00:07:28,400
你可能就这种框

227
00:07:28,560 --> 00:07:29,000
你可以认为

228
00:07:29,000 --> 00:07:30,879
基本上是用来变化通道数的

229
00:07:31,480 --> 00:07:32,439
就要么改变输入

230
00:07:32,439 --> 00:07:33,400
要不改变输出

231
00:07:34,480 --> 00:07:35,720
那蓝色的卷积

232
00:07:35,840 --> 00:07:38,080
你可以真是用来

233
00:07:38,080 --> 00:07:41,320
确实你可以认为是用来抽取信息的

234
00:07:41,680 --> 00:07:43,760
这个就不抽取空间信息

235
00:07:43,760 --> 00:07:45,080
只抽取通道信息

236
00:07:45,520 --> 00:07:47,680
这个两个当然是抽取了你的空间信息

237
00:07:48,080 --> 00:07:50,200
当然Max pooling也是抽取你的空间信息

238
00:07:50,200 --> 00:07:53,840
就是说让你使得更加的鲁莽一点

239
00:07:54,040 --> 00:07:55,120
我们也讲过这个原因

240
00:07:56,760 --> 00:07:57,960
当然你可以看到是说

241
00:07:58,280 --> 00:08:00,160
这个地方比较诡异的是什么

242
00:08:00,160 --> 00:08:01,120
诡异的是说

243
00:08:01,120 --> 00:08:03,120
你对数字是什么地方来的

244
00:08:04,000 --> 00:08:05,400
这个是一个很好的问题

245
00:08:06,200 --> 00:08:07,840
作者从来就没有说过

246
00:08:07,840 --> 00:08:09,120
我这个数字是怎么来的

247
00:08:09,480 --> 00:08:11,280
这里大致的可以看到是说

248
00:08:12,720 --> 00:08:13,480
首先

249
00:08:13,840 --> 00:08:16,920
因为你最后的通道是等于是64

250
00:08:16,920 --> 00:08:17,920
加上128

251
00:08:17,920 --> 00:08:18,600
加上32

252
00:08:18,600 --> 00:08:19,200
加上32

253
00:08:19,200 --> 00:08:20,120
就等于256

254
00:08:20,120 --> 00:08:20,520
对吧

255
00:08:21,000 --> 00:08:25,360
所以假设我是想从192变成256的话

256
00:08:25,520 --> 00:08:27,360
就是说我先不管里面是怎么样

257
00:08:27,680 --> 00:08:32,000
就我想我把我的输入通道从192

258
00:08:32,000 --> 00:08:34,360
然后增加到256

259
00:08:34,680 --> 00:08:37,399
那么接下来我去看说我的通道数

260
00:08:37,560 --> 00:08:39,759
就是我的每个通道

261
00:08:39,759 --> 00:08:40,440
我们知道

262
00:08:41,279 --> 00:08:43,639
差不多跟你去识别一些模式

263
00:08:44,639 --> 00:08:47,159
那么我就说我们要把重要的通道数

264
00:08:47,159 --> 00:08:50,159
重要的那些数留给我们觉得比较重要的

265
00:08:50,159 --> 00:08:51,440
那些通道

266
00:08:52,159 --> 00:08:53,159
所以这个地方就是说

267
00:08:53,159 --> 00:08:55,279
你觉得我一半的通道数留给他

268
00:08:55,720 --> 00:08:57,480
留给33卷集那一块

269
00:08:57,480 --> 00:09:00,720
因为33就是说33就是比较好

270
00:09:00,960 --> 00:09:02,399
就是说计算也不大

271
00:09:02,399 --> 00:09:05,559
其实也能够抽取很好的空间信息

272
00:09:06,480 --> 00:09:08,600
那么剩下的128边

273
00:09:08,600 --> 00:09:10,120
我们一半分给了卷集

274
00:09:10,519 --> 00:09:11,360
1乘1卷

275
00:09:11,360 --> 00:09:13,480
就是说空间就不看空间信息

276
00:09:13,480 --> 00:09:14,639
只看通道信息

277
00:09:15,120 --> 00:09:17,159
那么剩下64里面就是对半分了

278
00:09:17,360 --> 00:09:19,639
叫5乘5的卷集分了32

279
00:09:19,679 --> 00:09:21,199
1乘1的卷集分了32

280
00:09:22,679 --> 00:09:24,919
那么通道数就是说基本上就是说

281
00:09:25,759 --> 00:09:27,720
在他的下面往下减了

282
00:09:27,720 --> 00:09:28,679
要么就减半了

283
00:09:28,679 --> 00:09:30,480
或者是说3的样子

284
00:09:31,279 --> 00:09:33,519
OK就是说基本上你可以认为

285
00:09:33,879 --> 00:09:38,279
大致的是这样子一个设计的思路

286
00:09:38,720 --> 00:09:39,879
但具体用什么数字

287
00:09:39,879 --> 00:09:42,680
他们确实是调出来的

288
00:09:44,000 --> 00:09:44,360
OK

289
00:09:48,680 --> 00:09:50,320
所以可以比较一下

290
00:09:50,440 --> 00:09:52,120
就为什么要用Inception块

291
00:09:52,639 --> 00:09:54,480
就假设我不要Inception块

292
00:09:54,480 --> 00:09:57,320
就是要得到我的从输入通道数

293
00:09:58,560 --> 00:10:00,159
做到我的输出通道的话

294
00:10:00,879 --> 00:10:02,600
那么比如说我的输入是64

295
00:10:02,600 --> 00:10:04,200
输出是128通道数

296
00:10:04,560 --> 00:10:06,600
那么你如果你是通过Inception的话

297
00:10:07,240 --> 00:10:09,279
因为它里面有大量的1乘1卷集

298
00:10:09,440 --> 00:10:10,320
这样子的事情

299
00:10:10,320 --> 00:10:13,240
那么他可以认为它的参数是0.16兆

300
00:10:14,120 --> 00:10:16,600
如果你用一个单单的一个3乘3的卷集

301
00:10:16,680 --> 00:10:17,840
不用这个块的话

302
00:10:17,840 --> 00:10:19,519
那么你的参数数会变多

303
00:10:19,519 --> 00:10:22,120
是0.44兆

304
00:10:22,519 --> 00:10:24,200
如果你选用5乘5的卷集的话

305
00:10:24,200 --> 00:10:25,560
当然你的参数更多

306
00:10:25,720 --> 00:10:28,519
因为你的窗口大小更大

307
00:10:28,639 --> 00:10:30,799
所以就变成了1.22兆

308
00:10:31,480 --> 00:10:33,240
所以你可以看到说Inception

309
00:10:33,240 --> 00:10:37,480
它确实通过各种块的设计

310
00:10:37,480 --> 00:10:39,960
而且通过1乘1的那些卷集层

311
00:10:39,960 --> 00:10:41,159
来降低通道数

312
00:10:41,159 --> 00:10:44,679
使得你参数的个数变得非常的小

313
00:10:44,960 --> 00:10:46,679
比直接用3乘3还要小

314
00:10:46,679 --> 00:10:48,639
还小了大概两倍多了

315
00:10:49,519 --> 00:10:51,240
将近是1%去了

316
00:10:52,199 --> 00:10:53,720
然后你另外看到计算

317
00:10:53,720 --> 00:10:55,079
计算也是会少很多

318
00:10:55,079 --> 00:10:56,799
就是说因为你参数少

319
00:10:56,799 --> 00:10:58,039
计算也会跟着少

320
00:10:58,240 --> 00:11:01,399
几乎是一个差不多是一个线性关系

321
00:11:01,679 --> 00:11:02,839
所以你看到是说

322
00:11:03,199 --> 00:11:05,199
你5乘5的卷集最大了

323
00:11:05,199 --> 00:11:07,519
就是900兆的GL复联计算

324
00:11:07,879 --> 00:11:09,599
3乘3的话是350兆

325
00:11:09,639 --> 00:11:10,919
然后Inception的话

326
00:11:10,919 --> 00:11:12,839
那就是128兆

327
00:11:13,639 --> 00:11:16,199
所以就是说一个核心的想法

328
00:11:16,199 --> 00:11:18,199
就是说我的Inception

329
00:11:18,199 --> 00:11:20,839
不仅的增加了我里面的多样性

330
00:11:21,000 --> 00:11:24,039
我有大量的不同的设置的卷集层

331
00:11:24,399 --> 00:11:27,120
而且参数数变少了

332
00:11:27,840 --> 00:11:29,480
计算量也变低了

333
00:11:29,519 --> 00:11:30,960
所以这个就是它的好处

334
00:11:34,960 --> 00:11:36,120
然后我们GoogleNet

335
00:11:36,960 --> 00:11:38,120
所谓的GoogleNet

336
00:11:38,120 --> 00:11:43,679
就是一大堆Inception block

337
00:11:44,240 --> 00:11:46,840
就跟你的VGG没有本质太多区别

338
00:11:47,080 --> 00:11:48,200
就是你可以看到是说

339
00:11:48,200 --> 00:11:50,480
它的就是说分成了5个stage

340
00:11:50,759 --> 00:11:52,480
就跟之前的VGG是一样的

341
00:11:52,480 --> 00:11:55,159
就第一个stage是这样

342
00:11:55,159 --> 00:11:57,000
你的输入输入在这个地方

343
00:11:57,879 --> 00:12:00,159
输入进来是一个7成G的卷集

344
00:12:00,200 --> 00:12:01,919
然后到一个3乘3的Max pooling

345
00:12:01,919 --> 00:12:03,639
跟之前是应该是一样的

346
00:12:04,399 --> 00:12:05,639
接下来就是说

347
00:12:05,679 --> 00:12:06,399
第二个stage

348
00:12:06,399 --> 00:12:07,639
你还是没有Inception

349
00:12:07,679 --> 00:12:09,320
就是说用了一个1乘1的

350
00:12:09,480 --> 00:12:10,720
就是用的是中间

351
00:12:10,720 --> 00:12:12,560
他们觉得最重要的那条路

352
00:12:12,560 --> 00:12:14,000
就是1乘1的卷集

353
00:12:14,120 --> 00:12:15,480
降低通道数

354
00:12:15,519 --> 00:12:17,440
再使用3乘3的卷集

355
00:12:17,480 --> 00:12:19,799
然后再到了一个3乘3的Max pooling

356
00:12:20,120 --> 00:12:20,480
OK

357
00:12:20,480 --> 00:12:21,680
这是第一个stage

358
00:12:21,680 --> 00:12:22,560
第二个stage

359
00:12:23,680 --> 00:12:24,560
所谓的stage

360
00:12:24,560 --> 00:12:26,000
就是说你把高宽减半

361
00:12:26,000 --> 00:12:26,799
就是一个stage

362
00:12:27,159 --> 00:12:28,440
就跟VGG是一样的

363
00:12:30,080 --> 00:12:31,120
那么接下来

364
00:12:31,399 --> 00:12:33,480
接下来它用的是

365
00:12:33,919 --> 00:12:36,320
用两个Inception block

366
00:12:38,960 --> 00:12:40,600
因为Inception不改变高宽

367
00:12:40,600 --> 00:12:41,519
只改变通道数

368
00:12:42,200 --> 00:12:44,759
然后再用一个3乘3的Max pooling

369
00:12:45,399 --> 00:12:47,720
strat等于2来降低高宽

370
00:12:48,559 --> 00:12:50,519
接下来stage4

371
00:12:50,519 --> 00:12:51,679
4就比较厉害

372
00:12:51,679 --> 00:12:54,440
就是用了5个Inception block

373
00:12:55,240 --> 00:12:56,880
最后再使用一个Max pooling

374
00:12:56,880 --> 00:12:58,000
来降低高宽

375
00:12:59,080 --> 00:13:00,240
然后最后一层

376
00:13:00,800 --> 00:13:03,480
最后一层用的是两个Inception block

377
00:13:04,320 --> 00:13:07,200
然后使用了全局的Average pooling

378
00:13:09,480 --> 00:13:12,280
最后他拿到你的Fully connected layer

379
00:13:13,000 --> 00:13:13,680
就是说

380
00:13:13,720 --> 00:13:15,600
首先我们为什么会去讲说

381
00:13:15,640 --> 00:13:17,560
NIN讲在GoogleNet之前

382
00:13:17,560 --> 00:13:18,800
是因为你可以看到

383
00:13:18,800 --> 00:13:19,840
GoogleNet大量的

384
00:13:19,840 --> 00:13:21,160
使用了1乘1的卷集

385
00:13:22,000 --> 00:13:23,840
他当也是用

386
00:13:23,840 --> 00:13:25,879
很多时候也是当全连接在用

387
00:13:26,040 --> 00:13:27,280
就是降低你的通

388
00:13:27,560 --> 00:13:28,920
把你的通道数做变换

389
00:13:29,560 --> 00:13:30,120
第二个是说

390
00:13:30,120 --> 00:13:32,840
他也使用了Global Average pooling

391
00:13:32,840 --> 00:13:35,120
就全局的平均齿滑层

392
00:13:35,480 --> 00:13:36,759
但不一样的是说

393
00:13:36,800 --> 00:13:38,200
因为他这个

394
00:13:38,280 --> 00:13:40,320
就是说他没有说

395
00:13:40,320 --> 00:13:42,519
我一定要设计Inception block

396
00:13:42,519 --> 00:13:44,639
使得最后一个Inception block

397
00:13:44,639 --> 00:13:45,759
它的输出通道数

398
00:13:45,759 --> 00:13:46,840
等于你的类别个数

399
00:13:46,840 --> 00:13:49,360
因为这个东西设计起来挺奇怪的

400
00:13:49,600 --> 00:13:50,800
所以他们还是说

401
00:13:51,040 --> 00:13:52,280
这个东西你不管多大

402
00:13:52,279 --> 00:13:54,879
我做完全局Average pooling之后

403
00:13:54,879 --> 00:13:56,519
会拿到你的一个

404
00:13:57,039 --> 00:13:58,639
常为通道数的一个向量

405
00:13:58,639 --> 00:14:00,519
那就通道数不过是150

406
00:14:01,079 --> 00:14:03,559
182或者1024都OK

407
00:14:03,679 --> 00:14:06,000
然后再通过最后一次全连接层

408
00:14:06,039 --> 00:14:07,879
来映射到你的标号

409
00:14:07,879 --> 00:14:08,959
所要的类别数

410
00:14:09,679 --> 00:14:11,199
所以他不再去强求说

411
00:14:11,199 --> 00:14:12,639
你这里一定要最后一个

412
00:14:12,639 --> 00:14:14,679
一定要通道数等于你的类别数

413
00:14:14,959 --> 00:14:17,079
这就是他的一个简化版本

414
00:14:17,079 --> 00:14:17,559
我觉得

415
00:14:17,600 --> 00:14:19,559
所以你可以更加灵活性

416
00:14:20,519 --> 00:14:21,000
OK

417
00:14:21,120 --> 00:14:23,440
这就是GoogleNet

418
00:14:23,440 --> 00:14:25,679
在大致上的一个想法

419
00:14:26,039 --> 00:14:27,759
我们接下来仔细来看一下

420
00:14:27,759 --> 00:14:29,360
每一个block是怎么设计的

421
00:14:32,360 --> 00:14:35,440
首先就是stage就断了一和二

422
00:14:36,600 --> 00:14:37,320
就你可以看一下

423
00:14:37,320 --> 00:14:37,759
对比一下

424
00:14:37,759 --> 00:14:38,919
GoogleNet和AlexNet

425
00:14:38,919 --> 00:14:40,279
它的区别是什么样子

426
00:14:41,240 --> 00:14:42,759
首先你可以看到

427
00:14:44,600 --> 00:14:45,679
窗口数更小了

428
00:14:45,679 --> 00:14:46,360
7x7

429
00:14:46,360 --> 00:14:47,240
这里是7x7

430
00:14:47,279 --> 00:14:50,519
那么AlexNet是11x11

431
00:14:50,720 --> 00:14:52,439
然后你的strategy等于2

432
00:14:52,439 --> 00:14:55,159
就是你不想把一下就变得特别的小

433
00:14:55,399 --> 00:14:58,240
然后通道数其实没有AlexNet那么多

434
00:14:58,240 --> 00:14:59,600
就是64在这个地方

435
00:15:00,360 --> 00:15:03,279
然后你再通过一个33x33的max pooling

436
00:15:03,279 --> 00:15:04,759
然后strategy等于2

437
00:15:05,039 --> 00:15:07,199
AlexNet在这里

438
00:15:07,199 --> 00:15:10,439
直接就是你先降4倍高宽

439
00:15:10,439 --> 00:15:11,399
再降两倍高宽

440
00:15:11,399 --> 00:15:12,600
是降的比较狠的

441
00:15:13,679 --> 00:15:15,879
AlexNet相对来说就是保守一点

442
00:15:15,919 --> 00:15:16,759
先降两倍

443
00:15:16,919 --> 00:15:17,919
再降两倍

444
00:15:18,800 --> 00:15:23,080
然后接下来就是一个1x1的卷积

445
00:15:23,520 --> 00:15:25,120
然后通道数没变

446
00:15:25,360 --> 00:15:28,760
就是做一下通道数的融合

447
00:15:28,920 --> 00:15:30,920
然后再到一个33x33的卷积

448
00:15:32,200 --> 00:15:33,520
这里就比较多了

449
00:15:33,520 --> 00:15:34,880
就是192了

450
00:15:35,520 --> 00:15:36,360
做一个pooling

451
00:15:36,720 --> 00:15:38,840
所以这个地方你做完一次之后

452
00:15:39,000 --> 00:15:41,120
就是基本上你可以认为是我减了几倍

453
00:15:41,120 --> 00:15:42,760
我减了这个地方

454
00:15:42,760 --> 00:15:43,960
我减了8倍

455
00:15:44,080 --> 00:15:49,080
所以就是从224x224变成了28x28

456
00:15:49,080 --> 00:15:52,560
就前面几乎可以认为前面两个段

457
00:15:52,680 --> 00:15:54,080
虽然我卷积层不多

458
00:15:54,080 --> 00:15:58,040
但是我也是很快的要把我的通道数拉上去

459
00:15:58,040 --> 00:15:59,280
然后把高宽减下去

460
00:15:59,600 --> 00:16:02,160
使得我后面的计算可以控

461
00:16:02,160 --> 00:16:04,200
如果你的输入高宽太大的话

462
00:16:04,400 --> 00:16:06,480
那么后面就计算就比较大了

463
00:16:06,879 --> 00:16:08,960
但他确实比AlexNet还是要好一点

464
00:16:08,960 --> 00:16:10,680
AlexNet直接降到了12了

465
00:16:10,840 --> 00:16:12,280
他这里还有28x28

466
00:16:12,679 --> 00:16:14,639
所以是说你可以认为

467
00:16:16,159 --> 00:16:20,199
他用了更小的一些卷积层

468
00:16:20,360 --> 00:16:24,240
但是用了更你的高宽保留的更多一点

469
00:16:24,839 --> 00:16:26,839
使得这样子后面你能支撑

470
00:16:26,839 --> 00:16:28,199
你用更深的一些网络

471
00:16:31,319 --> 00:16:34,399
好 我们来看我们的第三个stage

472
00:16:34,720 --> 00:16:37,720
第三个stage使用了两个inception block

473
00:16:38,959 --> 00:16:40,000
就是说你可以看一下

474
00:16:40,960 --> 00:16:42,679
输入是192x188

475
00:16:43,240 --> 00:16:45,840
那么首先看你的输出就直接通道数

476
00:16:45,840 --> 00:16:47,960
从192变成了256

477
00:16:48,960 --> 00:16:52,440
接下来你256又变成了480

478
00:16:53,320 --> 00:16:55,799
然后再通过一个strategy2的mass pooling

479
00:16:55,799 --> 00:16:59,399
从28x28变成了14x14

480
00:17:00,320 --> 00:17:03,120
但是你的通道数从192变成了480

481
00:17:05,000 --> 00:17:08,160
然后他的两虽然我是说这是两个inception block

482
00:17:08,200 --> 00:17:10,600
但实际上它的通道数的分配是不一样的

483
00:17:11,200 --> 00:17:14,440
可以看到这个是256的通道数

484
00:17:15,279 --> 00:17:16,400
就是我们之前讲的

485
00:17:16,800 --> 00:17:18,640
一半的通道分在这条pass

486
00:17:19,200 --> 00:17:20,720
剩下的一半里面在这里

487
00:17:20,720 --> 00:17:23,600
然后剩下的1 4都是在这个地方

488
00:17:25,600 --> 00:17:29,920
然后在这一个地方通道数增加了

489
00:17:30,279 --> 00:17:33,279
但是他其实是没有拿到一半

490
00:17:35,120 --> 00:17:37,080
然后你可以看到是说

491
00:17:38,400 --> 00:17:39,720
这里增加到128

492
00:17:39,720 --> 00:17:42,160
这里变成128变成了192

493
00:17:42,160 --> 00:17:44,240
然后这个地方其实是真的比较大的

494
00:17:44,240 --> 00:17:46,000
就是扩大了三倍的样子

495
00:17:46,000 --> 00:17:47,920
从这个地方32变成了96

496
00:17:48,800 --> 00:17:50,800
最后这里是变到两倍的样子

497
00:17:52,000 --> 00:17:55,400
而且这些这个地方也没有

498
00:17:55,400 --> 00:17:58,040
你可以看到没有太多的规律可言

499
00:17:58,680 --> 00:18:02,680
就挺难总结是说你到底是一半在这个地方

500
00:18:02,680 --> 00:18:03,800
1 4分之一在那个地方

501
00:18:03,800 --> 00:18:06,640
或就是说你很难总结说你整个

502
00:18:07,120 --> 00:18:09,400
不同的路上你到底要分配多少通道

503
00:18:09,880 --> 00:18:12,160
和你两个的关系是什么样子

504
00:18:12,160 --> 00:18:14,160
就是128和196

505
00:18:14,160 --> 00:18:16,880
就256和128和196192什么关系

506
00:18:16,880 --> 00:18:18,120
其实不好总结

507
00:18:18,440 --> 00:18:20,840
所以整话我觉得那是因为

508
00:18:22,320 --> 00:18:24,440
那是那群作者

509
00:18:24,800 --> 00:18:25,480
Google那么人

510
00:18:26,520 --> 00:18:27,320
也是有钱

511
00:18:27,320 --> 00:18:29,160
就不缺钱

512
00:18:29,600 --> 00:18:30,280
不缺钱的话

513
00:18:30,280 --> 00:18:33,240
那我就说我可以做超参数的搜索

514
00:18:33,720 --> 00:18:36,079
就是说他反正写很多

515
00:18:36,079 --> 00:18:38,120
要么拍拍脑袋分一分

516
00:18:38,120 --> 00:18:40,200
要么就是说我写很多个不同版本

517
00:18:40,200 --> 00:18:41,680
然后跑最后谁效果最好

518
00:18:42,799 --> 00:18:43,640
是我才更多

519
00:18:43,640 --> 00:18:46,120
很多时候他们机器比较多

520
00:18:46,120 --> 00:18:47,880
所以搜了一把

521
00:18:47,880 --> 00:18:51,000
搜了一把搜出来之后就长得特别奇怪

522
00:18:52,559 --> 00:18:56,079
然后你的段4和段5也是一样的

523
00:18:56,079 --> 00:19:00,120
那里面你就根本就不知道他到底是怎么样算的

524
00:19:00,440 --> 00:19:03,840
所以导致GoogleNet论文特别的难以复现

525
00:19:04,240 --> 00:19:06,840
就是说你那么多超参数对吧

526
00:19:06,840 --> 00:19:10,400
你怎么去跟着论文实现呢

527
00:19:11,440 --> 00:19:14,760
但基本上总体的原则你可以看到是说

528
00:19:15,440 --> 00:19:18,760
就stage4就第4段里面有5个inception block

529
00:19:19,160 --> 00:19:22,160
可以看到是说你的通道数从480到512

530
00:19:22,160 --> 00:19:26,240
512到832

531
00:19:26,240 --> 00:19:31,319
然后到第5个stage就是832不变

532
00:19:31,319 --> 00:19:32,920
然后跳到1.24

533
00:19:33,880 --> 00:19:35,880
最后你的global average pooling就是

534
00:19:36,880 --> 00:19:38,880
成为1.24的一个输出

535
00:19:39,599 --> 00:19:41,400
就等于是说你一张图片进来

536
00:19:41,400 --> 00:19:44,039
然后我最后抽出的一个124

537
00:19:44,039 --> 00:19:45,799
成为124的一个项量

538
00:19:46,039 --> 00:19:48,319
这是我最后干的事情

539
00:19:50,039 --> 00:19:50,519
OK

540
00:19:51,720 --> 00:19:54,720
所以就是说这个就是大概是整个GoogleNet

541
00:19:54,720 --> 00:19:55,400
长什么样子

542
00:19:55,960 --> 00:19:58,280
就核心就是跟你的VGG一样的

543
00:19:58,280 --> 00:19:59,640
有5个stage

544
00:19:59,640 --> 00:20:01,560
但是他不再使用VGG block

545
00:20:01,560 --> 00:20:02,960
他用的是inception block

546
00:20:03,320 --> 00:20:06,640
然后每个inception block长得也挺奇怪的

547
00:20:06,840 --> 00:20:09,640
唯一的就是说你看到就是说

548
00:20:09,640 --> 00:20:11,320
他不断就增加你的通道数

549
00:20:11,320 --> 00:20:13,040
最后会增加到1.24

550
00:20:13,759 --> 00:20:15,240
就是说比VGG要大了

551
00:20:15,400 --> 00:20:16,720
VGG是512对吧

552
00:20:16,720 --> 00:20:18,400
他现在是变成1.24

553
00:20:21,720 --> 00:20:23,240
然后接下来看一下说

554
00:20:23,279 --> 00:20:27,319
这inception后面有很多大量的变种

555
00:20:28,200 --> 00:20:31,359
就是说我们介绍是V1

556
00:20:31,359 --> 00:20:33,400
V1这个版本几乎没有被用过了

557
00:20:33,400 --> 00:20:35,079
就是说我们现在用的是

558
00:20:36,279 --> 00:20:40,480
V3或者V4

559
00:20:41,319 --> 00:20:42,440
就是说V2的话

560
00:20:42,440 --> 00:20:43,480
其实是用的

561
00:20:43,480 --> 00:20:46,599
就是在你的第一个版本里面加入了

562
00:20:46,599 --> 00:20:47,720
batch normalization

563
00:20:48,079 --> 00:20:49,160
我们明天会来讲

564
00:20:50,839 --> 00:20:51,880
那么你的V3

565
00:20:52,400 --> 00:20:54,080
V3就是说在V2的基础上

566
00:20:54,080 --> 00:20:55,440
再修改了inception块

567
00:20:57,040 --> 00:20:58,280
他用了很多

568
00:20:58,640 --> 00:21:00,840
尝试了很多不一样的思想

569
00:21:00,840 --> 00:21:02,400
就是说他把你比如说

570
00:21:02,400 --> 00:21:07,320
把5×5卷进程换成两个3×3

571
00:21:07,840 --> 00:21:09,800
或者5×5换成一个1×7

572
00:21:09,800 --> 00:21:12,040
再接一个7×1的一个卷进程

573
00:21:12,480 --> 00:21:16,920
就是现在你宽

574
00:21:16,920 --> 00:21:19,360
就是说行上面看一下空间信息

575
00:21:19,360 --> 00:21:20,760
就列信息我先不看

576
00:21:20,759 --> 00:21:22,640
然后再列上面看一下空间信息

577
00:21:22,640 --> 00:21:23,640
然后行信息不看

578
00:21:24,519 --> 00:21:25,400
然后3×3也是一样

579
00:21:25,400 --> 00:21:27,680
你给换成1×3和3×1的卷进程

580
00:21:28,039 --> 00:21:29,000
而且你可以更深

581
00:21:29,680 --> 00:21:32,359
而且他的输入应该是我记得

582
00:21:32,359 --> 00:21:35,519
V3从224变成了299×299

583
00:21:35,799 --> 00:21:39,559
所以他论文我记得当年我们去重复实现

584
00:21:39,559 --> 00:21:40,279
这个论文的时候

585
00:21:40,279 --> 00:21:42,039
是非常的难实现

586
00:21:42,039 --> 00:21:44,319
因为他的输入变成了299

587
00:21:44,319 --> 00:21:46,640
就跟你所有人都不一样

588
00:21:46,640 --> 00:21:47,519
就是很诡异

589
00:21:48,240 --> 00:21:50,480
然后V4的话就在V3的技术上

590
00:21:50,480 --> 00:21:51,759
加入了残差连接

591
00:21:51,759 --> 00:21:53,240
叫recedual connection

592
00:21:53,240 --> 00:21:55,440
我们会在讲resnet的时候回去讲

593
00:21:56,279 --> 00:21:57,480
所以基本上就是说

594
00:21:57,480 --> 00:21:59,440
V2就是加入了batch normalization

595
00:21:59,440 --> 00:22:00,400
我们之后会讲

596
00:22:00,400 --> 00:22:02,400
V4就是加入了recedual network

597
00:22:02,400 --> 00:22:03,680
我们也之后会讲

598
00:22:03,960 --> 00:22:06,279
那么核心的是说在V3上面

599
00:22:06,279 --> 00:22:08,519
他又去重新去看了一下

600
00:22:08,519 --> 00:22:09,480
Inception block

601
00:22:09,680 --> 00:22:12,039
他觉得里面还有什么样的可以调的东西

602
00:22:12,839 --> 00:22:14,720
调了太多

603
00:22:18,519 --> 00:22:19,879
OK

604
00:22:19,879 --> 00:22:22,200
就是说这里其实是idea了

605
00:22:22,200 --> 00:22:25,559
就是说在V3里面做了什么样的改变

606
00:22:25,960 --> 00:22:27,200
可以看到是说

607
00:22:27,599 --> 00:22:28,639
本来这里有个5×5

608
00:22:28,639 --> 00:22:29,319
对不对

609
00:22:29,559 --> 00:22:31,839
他改成了一个两个三层三

610
00:22:33,079 --> 00:22:38,680
然后接下来就是这边就是我们原始的

611
00:22:38,680 --> 00:22:42,559
接下来他就是把这个三层三

612
00:22:42,839 --> 00:22:44,879
换成了一个1×7

613
00:22:45,000 --> 00:22:45,960
7×1

614
00:22:46,400 --> 00:22:50,200
然后他的5×5换成了1×7

615
00:22:50,200 --> 00:22:50,799
7×1

616
00:22:50,799 --> 00:22:51,720
1×7

617
00:22:51,840 --> 00:22:52,440
7×1

618
00:22:52,440 --> 00:22:53,319
就换了

619
00:22:53,319 --> 00:23:00,319
就是说用两个这样子的东西来替换掉三层三和5×5

620
00:23:01,160 --> 00:23:03,000
这是第4段的做法

621
00:23:03,160 --> 00:23:05,120
前面是stage3

622
00:23:05,120 --> 00:23:06,680
stage3里面换成这个样子

623
00:23:06,799 --> 00:23:08,440
stage4就换成这个样子

624
00:23:10,120 --> 00:23:12,079
stage5就更奇怪了

625
00:23:12,079 --> 00:23:15,000
stage5是说把三层三

626
00:23:15,279 --> 00:23:17,519
换成了两个并行的

627
00:23:17,519 --> 00:23:18,759
一个是一个三层

628
00:23:18,759 --> 00:23:20,079
一个是一个一层三

629
00:23:20,680 --> 00:23:22,160
然后接下来5×5

630
00:23:22,160 --> 00:23:25,000
5×5先换成了一个三层三

631
00:23:25,200 --> 00:23:27,480
然后又后面接个三层一个一层三

632
00:23:28,519 --> 00:23:28,960
对吧

633
00:23:29,000 --> 00:23:30,559
这是stage5做的变化

634
00:23:33,119 --> 00:23:34,559
然后基本上就是说

635
00:23:34,720 --> 00:23:37,039
V3就是说这个东西虽然很诡异

636
00:23:37,039 --> 00:23:38,799
但是实际上效果还挺好的

637
00:23:39,279 --> 00:23:42,200
就我们来给大家看就是V3是哪个

638
00:23:42,200 --> 00:23:44,559
Inception V3是这个黄色点点

639
00:23:45,359 --> 00:23:47,319
这个点是你的V3的效果

640
00:23:47,639 --> 00:23:50,679
你的x就是你的处理的速度

641
00:23:50,919 --> 00:23:51,720
越往这边越好

642
00:23:51,720 --> 00:23:52,799
这是个lock分布的

643
00:23:53,200 --> 00:23:55,399
所以就是说实际上这一块就非常快的

644
00:23:55,679 --> 00:23:57,399
每秒就能够跑个7000个样本

645
00:23:57,839 --> 00:24:00,599
V3就是说属于比较慢

646
00:24:01,319 --> 00:24:02,679
就是说他每秒就能够跑个

647
00:24:02,679 --> 00:24:05,240
大概800个样本的样子

648
00:24:05,919 --> 00:24:07,480
这是预测的不是训练

649
00:24:07,480 --> 00:24:08,559
训练还要慢一倍

650
00:24:09,839 --> 00:24:12,119
Accuracy V3还挺高的

651
00:24:12,200 --> 00:24:13,240
你可以看到是说

652
00:24:13,560 --> 00:24:14,800
基本上到了

653
00:24:15,080 --> 00:24:17,600
ImageNet上将近到0.8了

654
00:24:18,280 --> 00:24:19,000
这就V3

655
00:24:19,640 --> 00:24:21,760
我们那天讲的VGG在这里

656
00:24:21,920 --> 00:24:22,760
这是VGG

657
00:24:23,120 --> 00:24:25,120
所以他其实是完胜VGG的

658
00:24:25,120 --> 00:24:25,560
对不对

659
00:24:26,000 --> 00:24:27,880
虽然他内存要的多

660
00:24:27,960 --> 00:24:28,760
然后计算量慢

661
00:24:28,800 --> 00:24:30,920
但是他的进度会比VGG高很多

662
00:24:32,360 --> 00:24:34,320
但是他跟别人比没太多优势

663
00:24:34,400 --> 00:24:36,920
现在当年还是挺厉害的一个版本

664
00:24:37,400 --> 00:24:38,920
所以这就是Inception V3

665
00:24:39,200 --> 00:24:40,400
当然他圈比较大

666
00:24:40,400 --> 00:24:41,840
是因为他比较好内存

667
00:24:42,240 --> 00:24:45,080
圈的大小是等于你的内存数号的大小

668
00:24:45,520 --> 00:24:46,880
就是说V3你可认为是

669
00:24:47,240 --> 00:24:48,400
耗内存比较多

670
00:24:48,760 --> 00:24:50,520
计算也还算慢

671
00:24:50,520 --> 00:24:52,520
但进度还挺好的一个网络

672
00:24:54,520 --> 00:24:56,720
跟现在比也是一个没有

673
00:24:57,080 --> 00:25:00,080
在做速度和进度的权衡里面

674
00:25:00,080 --> 00:25:02,040
也亏不到哪里去的一个网络

675
00:25:02,040 --> 00:25:04,720
所以V3现在还是被经常使用

676
00:25:07,640 --> 00:25:08,680
好 我们总结一下

677
00:25:08,680 --> 00:25:13,480
Inception块有4条

678
00:25:14,000 --> 00:25:17,080
不同的超参数的卷积层的

679
00:25:17,080 --> 00:25:18,759
持块层通道来抽取信息

680
00:25:19,039 --> 00:25:20,920
等于是说每一个层

681
00:25:20,920 --> 00:25:22,640
你去使用不同的组合

682
00:25:22,680 --> 00:25:24,600
来抽取不一样的空间信息

683
00:25:25,400 --> 00:25:27,000
它的主要优点是模型参数少

684
00:25:27,240 --> 00:25:28,320
计算复杂度低

685
00:25:29,200 --> 00:25:31,400
然后所以就意味着是说

686
00:25:31,440 --> 00:25:33,759
GoogleNet用了9个Inception块

687
00:25:33,960 --> 00:25:35,720
一个Inception块里面多少个卷积层

688
00:25:35,759 --> 00:25:39,039
里面有123有多6个卷积层

689
00:25:39,519 --> 00:25:41,400
然后9个Inception块

690
00:25:41,440 --> 00:25:43,720
那就是6959不是4个卷积层

691
00:25:44,360 --> 00:25:46,519
然后他七七八八加起来

692
00:25:46,559 --> 00:25:48,240
就是说你到后面那些改进

693
00:25:48,559 --> 00:25:49,759
基本上是说

694
00:25:49,799 --> 00:25:51,960
一个到了上百层的网络

695
00:25:51,960 --> 00:25:52,440
就

696
00:25:53,640 --> 00:25:56,400
但是他不是纯升100

697
00:25:56,720 --> 00:25:58,480
因为升到100现在还做不了

698
00:25:58,720 --> 00:26:00,240
直到ResNet出现

699
00:26:00,279 --> 00:26:02,000
就是到在GoogleNet那一块

700
00:26:02,000 --> 00:26:03,279
还做不了升成100

701
00:26:03,279 --> 00:26:06,399
但是他就通过加运行那些通道

702
00:26:06,440 --> 00:26:08,440
来使得达到上百层

703
00:26:08,639 --> 00:26:10,639
但后续有一系列的改进

704
00:26:11,000 --> 00:26:14,160
也就是说你一个网络想存到现在的话

705
00:26:14,200 --> 00:26:17,000
你那些作者需要不断的进行改进

706
00:26:17,000 --> 00:26:18,639
把新的那些技术加进去

707
00:26:18,680 --> 00:26:20,079
不然的话你不改进的话

708
00:26:20,079 --> 00:26:22,359
基本上就在历史

709
00:26:22,359 --> 00:26:23,639
就是一个历史了

710
00:26:24,200 --> 00:26:27,319
所以就是说GoogleNet到V3 V4

711
00:26:27,319 --> 00:26:30,200
在目前还是在被持续使用的

712
00:26:30,319 --> 00:26:33,519
而且GoogleNet一开始进度其实不高

713
00:26:33,799 --> 00:26:37,319
在BN V3 V4之后进度才上去

714
00:26:37,360 --> 00:26:41,120
现在也是常使用的一个模块了

715
00:26:41,960 --> 00:26:43,039
但他的问题是什么

716
00:26:43,039 --> 00:26:44,480
他问题是特别复杂

717
00:26:44,759 --> 00:26:45,840
就是通道是不是

718
00:26:45,840 --> 00:26:47,200
你完全不知道他怎么来的

719
00:26:47,240 --> 00:26:49,279
而且里面各种奇奇怪怪的口罩

720
00:26:49,319 --> 00:26:51,000
这也是使得GoogleNet

721
00:26:51,120 --> 00:26:53,360
不这么受欢迎的一个原因

722
00:26:53,360 --> 00:26:54,319
因为太复杂了

723
00:26:54,319 --> 00:26:57,720
那里面就基本上就不是人能设计出来的

724
00:26:57,720 --> 00:26:58,240
感觉

